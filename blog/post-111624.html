<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"207129665337bf04423c44c818f42fe10e17975a333ae39dabb187044124d6de05d0c093c333e969cbc80ca8713ca940c4a03e2e615f9f045ef0b44b7ae249d03364ac4cc4d1e80948913e3f36cc1b18608b20eb88e5c29ea71361e33ead602c3f4a6d6934cdc7edb7acd728ced22ca61baaf3500b7d3d1f57d399dac5fc72dcb032d9c87d2f69dec25c8466b00acc6c9203d68f0ff4beba867978fe7ae66c229b1fc6f514bd2f0475d4f0fcf03841abb9a2172c08226dfae7f00c13d6a38d71a545a246f6ff81b3960526302b69bed336213c616eefc8eef9ac8ede5342b4409a623592b108e2e2d0a763dbac9eb093f84dd2c6af14e6b5a0660cb0cbb210087a606c5d9e62eb4bf8a268a9c67f5ff6117acc9de06fe052d5adc186c59bc81760ec70c835e1762147dda245ec88937b74fc9330836029d3ec8c8b1179f1f8d8a0cdc157124ddd7688386d5f369b8b2345c8a71dc3f8af7c0ff0f9e8e3834d8a60ed620df999085a77e41f1fea876c4a792b01b490e77601777572e40ff6bc1491cb99d92f2541314f40fd9550483162e6e8c532343d338e53c5d2365aa7a51de07e7f1433ce6968d516aef87387065a4a130314047b4a06207ac73070fa3e976caae12f13fefec809ea6ca75e9ff44d6edfa906a393fab5235a2b61587d8431da504ba907b10757523e06efda36d92d1f59e56accb78a3ae15573b8defaa70dcb63db1e99afa6ce77eec951abda33c6f6c07ed86fe8739c9cd2d18bd1ae9ab68fa9a79a198564da62a2bd3d5bf239632eaf9f43e8107ddba97af86de58dcf7fa7124003e23d0e6b4b977162cd66012b526b49f393428f695427a1372d686a5033a98d969f28593e127da0474e2f76568eaa01e0777d7da3cbb0b20eb551728a9890455478a0b4c8c6b65dfb69baa7f496b8c4e99f686f657213b19345e7fac38a9c52af1d792bc7ef635b0b96844be291d75d91bd9f8191c125a4f04e5e1a18c982d8b3f4732e7974f0d6965fdafd9e85e2b916c5b0182ed8b7168547c8b0fc51889c6b0e6b6f633ae5fc3181dbcfb75ea822feaadc07264b330e24512e80ba782286d97a23cd10437356dc6e04d3f0c7551cc98f4bf68fd723cdac2696ee442fa48cb76687d73a765c95029e0c6f88a33e44e697e2dbe1fbd4e7fd25fbd3a5e2e0f27fe0650d2004828899e9f849a2ae831583cc6ffd68e82766d0157baf3fcf81cb3b6ccd48dbdf49d4f1b27e59b3aa3bdb3a62e5558fbcd22f5cddcc24bd0b141759034acd5c5310a81ab235fd2e405ff2f27ecd77182929d6a768c99259300d6e341e88a444004abaa5faf31e72d7965df5b792f7bea5fcbc17ffc5cbfa57450b2fa59a75473341bcd2b8cfec51e4821416e1b85a8a230567ac43612ea84af113aec79bab1ab4ce6882d76a4a562c122320062b63b945c245de7da6f716d2e4224cd6eb9a3742cbbad6f3b8f66a598bc38fca9a6d067d26e4dc6486dd67a4d440f4c5fd6092347b12f897d03f3d75bdb751c7741cf599290ad1d0d64f74f2f7e73b73ff1332e69497e955e8da97b5f9afbbeebdf4752bc9b3d024d5b61207ee44d4135443ebe09e2de78f3386ff8cf1736021d595f9073a6ef3bc6632d38e48173b1d90d1353ddd1acb0327d166954597d0c7a33156150a0b891fb7e04f7c9f8d4e8c2c9847f2cb5234108ca89cab07dcbe798c2934d47b3e5da6ec22f66bd65119a6ef6069645e04832022044e301fa86756a5e32bdec8ab7d69de08680a99887b69f98353bcc7828c356ea208f6261d5151951a9ec05d38c4d0e7729974b619c50905581ec0f11a9786dc0d5bb379d98e9e31617270738b2d0480b002c80e754fe008a06b73c14a24fa782953f187a26a0e2e311985b6d3d1944b6389798003ea9a9dafda542347673195c6408a6aed1eb74de68e10d392706a0d31706a2cec411555281f16d06b5c92d32a1cf1bd0b4a77716320bbe77a6819996508be8e72aa8d606dc6347aa77f209d94748a2c7fd6597c25f8ebee65a89d1a28ad03e8d6d0c4e116721b26b77e4827de7c0cb40c4519552f5a2b05217f7f24b95f075f89b7aca82025abdc61c51ea1a05717bb2ff2d0f820d2e2d007b620cc85b5ec13001089a0505799e1719eba3461d7ad62b0411bb616ea812542c35639115feae37cdbbfa67f544d0be2681ee22c9ec86fb92cf25472c795b30518f77e434daeeb1918e1f66ad8a4585d80c4354e9f2f93cce39b0e574a47af67b1b4a6b3fbce52075c198609d759bebcace42030d39daf5044d1225827de9f0ba2c85df5f31c0d53cb44d081a433b5cf653fa0fc874395f1461368f8fb5339c3e262808518e21ae3f358189363f25f2d65d37e6b22b68a19d1d6c6fbb89ce0e0c5a8d35a0a9bf58c289324282988cddbd948872a858a0b0f80ae19e1aa1f52b9550649e30aceb37c3b5f6f74f76e63bd2362f700731c15012734534d1240bb997856034a6c6b7a241fefba24417e0381be61dde42f31f387b9fe95cbb543415bd9588b2659f4f8150e6ffdc459ce20b1293bb704ee92f2035823fd7560bdde92fa74e099110c5bb01e1e90050e4c8439c742ea3eb509d08d7e071cd08810b2488001c378d2ac19a96c1b0a19f6687cd544e462b177bd11889a2218c286813b421a2a2c06d9bdba3ec039e5bada9cd816bc25c4278d8be2c95c830ce41b18b565315776154d867e34880a71a29e57b92f870d21f1e1041e8fe8f06afdd03b6a672aefa51d3a3e509e3cf503d09a9e2333150717ddce943e0f939ba60b3d1c8af4cf4afd126d052ae9c580ee4e6a20869020f165fbb193cfc36735ad353c092eeeed5072233a01ea357f06d7430e6eca6627d5a26e38e354b146bf1842827331318f1bda00af5be3a3063dbf3961647235d5199c9b3f0d74670125e14e8f2a1307ae5e17909a1224b4c5df6aaa64bfedef22535b16a3d4c9dcf48e51b11adf4cc8ac9aca7b4a1bc2f3cabedcb3145b371c466863fd00dc779354ec10bc6ca977ad5aa46ad182808fd0297e370dbe71a7bb52d6efaf602a8521ccde3e7a9d05a80c5c50a854baa4d31ed6c020023f81780b87d5ab49879393b9ce75f003634738031e9cdba45d5fa16bcf49821be30961cf21ba1b80b6fb97d5f156bd0fe2a645d16816d00026ec1f0b04558245c0521d3b02f5859bfad920876b4b9047b9c1b4ab06c54d0bf39769654508251791fb516d6cdfe62dbfc9354e0fd125838ebfe40ee222534a958dda3ae4fca3aa0c695dc1e25b60833665d839d635dc051fa682c3d1e948048d6e13cc6e7229e01417ff513d6505888fd4fffc24cdd679090600adf9aaf9a1d593e0941e1d44deb0fbd0ceaaec5b601b07d169bb1f81e36fa2e4a738065b59246a06208135d283a72ac1390125187ede988e8918857233f5d2407d7a8b26c16660bed161aaae0ee41362f89d10e3cec99e28c44684619ada69ac810f45d0f914ba2c9cae0fa2c3ab7d2afaf008f137045568ae4e0226d616df3fd856f0463a14481bb55771e71cb380e0bfa8a187353eab020499f5f9e0e6f52956a74fcb989ddc5fc4600a1774f5554dd7f2f7f21e413ea85f2177db384a09de7ec124cb2152582eef8253312bc499d8b35862add343fd658698b72879cc3f2f1ce1cb3585edc15b87abb284c9558e017f2760cd53bb1f98141e4c60892f26caa70095d9cafa9fae831e59e508bbcde376d00ec847bf39daf3f48a00d067d687fc7d518047bfb1732271cd2e42f980f65cdeaafc6030af3c1702bb3254f5d10de5bc64ed9a5e2b53ca7143bdf96ede159e91c33d82a5ab2c77762c365496e4c14a877f883a8906ebf11f5b55e9018984f296efc21e5f7f10aa3518b14f18100c186d78d614dc7c30fa3eb1f917028dee33570578652beed6b40f432e9d6300c076bdcdeca349a729838984b88087b34f7d5dc3df55b67ba8ab86762a507cf3d384f260a975cb03f33b43f247981fdd5e58a16a11fb559954ce0bc9ddfdcdeb7c82e761df597306b097ef5352f3bc1a91bbe5dd564ab8b04bb710487e3bc9ba93841fef59db8c9ed1da222a8166066e5d1218c7f56456ee5f1feee752480d184c433d03662d0c1cec9fb6fddaeb501366cea1a1a0f8d0e0352fcda3e5a4f195d3a0fc122ab56d7aa961da752aa67372720477e8f0b47a3e5f50b4ed25827ba50cd76019dc37c257a5f54eb31d82e56e9f16abcb6ab9d633bddaa3a72d3299d19fa23aee8c474de550a32c9f3a73e74e92c2a3470c45ccdc1ca5c7a475245e6ca527d60ed3961ed0df17b6c1ff6d202968ff8dfa5649d1f99e3028dad17a407359c17478933d0a60700f7161f0107fe178911c76a868dcf3b422eeef9d3a3b9dccee87d3e41f846f07ee2770207cbeded2aeebd6c684f327eeb43b2ab315fcb55e41b1787fef7bfff163bbe24d159682bebb038e024a4763fd38bf2911e3c0bd88e9f91ac82a944dca7632b62d85aa064a6075971cff0faf55b803230f923f939a6f24f094b350328237a8e5f89d1ae9b726345120b1e6301a38bc4bb6c9629ae6381b3ae3d02ba0ca46ee01ac09977b31be76e83f95e5b9101528747ab0b0630cc0bf98c79cfb781caba8ea7381775e0171d6a171da413636334974565de4daf2f428ffe25e91d2a52a33630ccdb4617390d578d9605dd0557efe7cf93b72ba3243cc570cd409c083bb3f65d03f8c0e15cc9a88f89e17c856b6297ef26363b698307f64228f2b1c0226a1b59c75c00dadc780a0cfe4004ceaa796407b332b59081fa301a3bfa083e3b89aa54925438d8ad09b892500196f8032ad384d918ba6b56584b7b404ad82f154713b980bfbc942465d008b87fce3dba292cf70b2dacfce9202f5381b4efd759a79ab7f66a9c0b8a68e3d0a1c579665f3b54b4c3cce6c3cd983fc86db559f27ab83c2d2a2b0ee4a4bd7e9e72577597622363481085c5aeaa8f73281c70480fc31c6c3c837c08d6013904093467d2d696c39f4614f32fb8844941382f5a5c28a2883c79dfdd207137ca85b5e9d5f766c5e36a70edb0c37cfbd1d6aa20cd6ba03ec34b18362a1c9f9a041f128dadb6606aee0b77048391aa9b2d5239f3722634d2619f913eb3fd859dbd814de061682b09a9a950c95d5f8988bb7099d94daf80731ca4527fbfa4b203a9e891d2e5a0bb7fa4a73db1b28fadae2625c3102eaaffb8bdd7b06ccfad375f4b45ccef93df88b0c3f477be2fad10bebe234a6119e3cf1a57409ca54c0044db61b9235a8b251920d041a2620687971ee900636c8f8836b19335671b006bea9b10853fcd96b2f9570c6e198a8df5487137501857d9d3c82b7fb347e8891365ab6d153c91add4d3a2b621fa26e5fcef221af038f0bfc03a0e493ccc665c9f7ef89ab9d49739a890f22f7a8873c3cd6a8f5581ce0487749709c6903aa980d111210362c8485a4763a1fba83d2f7acbc96ee616e05f3a2095b815116a8c389335acad64e54422230dfb425657427278d8a34690bdc4c43460b9bb9b92d3ed3f809004259bb21215911197ddcd140870f1382163d419f1f208ab6710ec3f2fd5f2716829b6640a5098330747fc39a9197650f91c75f8319cac4180dc38fa6f2c9977d858e4cb9844c8e48dc051f62a879c7615b8826752f146086617e78312d4424d1df5dcdaf76b7f6193ca51652f630664e63f4f499c4b9f958046b78d8d82e33bc5ffa74efb3900fc4c5862abb70aa2a097abceeafdcd83d58066ca5d53cbcd54576d3a46a432f297a2a48dd801a30bd0c3668389118c8bdbededccf75acb55105e73a4af101cb728b15656a30946e9a4cafd8ea2164ba17fb94144ae946d9a52085c7cb3aa946cf007b260d406b5578065eb96ae13c6110d4f766e64c1243ba55088647ff4cce98212ca3cc9b7cf0ef854048d3bcf5aff7c4e53954cd12342b0eb333a3372f1459a58ce18fcb4cdd5dc7c1cc82c1c3849f3c24fbca925b1d38cbd16a09e882d8acbcb3b8a573769ff84bb45693d3400ab1055b39f9d7187fe99fb8dde8ce9bba8035a86c349ba68d7498d6f08b7d010ab1498180b32c7558878957fbfefa66ea85d3c864dba47a4e0c57b1829343cff60348bc33926ae3ee58bc85fb805f4c2c0f4d014324ac3f963fe8f48c475d9218d71a25d6f3db30a7009d0fd468a41c2a2d89a47ca4c14b5c43eb510327b47c47621c326bd4ca714bb00f745e7389c88c5bfd1872f8319c4113242a0049c93621ef70f941bff2033446f2ce87e3c8c68a652f818ca0449b6d77c5b92f9ce5f90bcbeac361d7b3f0c92f7462717153127763f03ed3576d69c8b701b12b71064211361e55eae6ef43ae7871f28636715df99eb12e5ba2e48e71d25c2f602a0e13c49c6ef1d82322e99defd2a7580413d2688f6d3093df15cfb233d2aea5feca265ab2504bd8f6cdef9c0d71b75ade7505591cbbc69b80ba12748f5eb01d5d358029cdb26189717801fedcc228921ed3ef033bf13b05c6147e6be734da1bb41c61207f08ae2a89c0102c162f6ab8e7f4321955c8aca65df124fc2105647840390c20d0ba1ad88b4e0a8a527f7484150de2c3528b44dd1e428f74a802f414906cf68be97416c3156b67bbbf664ab9ad871079053071aa23a75869bbbbbb162b55b72a046d2cbf7acde58bf7893c8ea6998f74f383ff297c03b01b070020386668954b2eac3a0f6ef28f9167104530c5db3697b4406b012809d5a246cf3e79819e68053e85a6dc6d81cd71ea410079fc76478545ac030e7b74026700a1e5bbe090b96aa68a763b5bd122e400ed0cd4fe92cc309a3ddb53388f25d95bde1c85a1c7ebc893f3bed694e6eec89339a2da0ff7845f742bf1eb19450e19f12703708d31e91a23b40165c19f309f835fc076f2a6dbbd9b79583358f7ce2452119cc9d371bd552992513ffaac4c60b8ff58c9efc54deb148d56f02d4d47a4cb6d7126f088618edef8badc4352982fc64087a490c6052e79f1f306b15d59fbca827548e0f343d10dc26d3c744d6dacece3281d11cb9e6db6bf720b4a3930f7157234c19a78ec89d90411dd1343809935d6a2a67fc4b06d006e214914837b73a9f851f788fb1265aaba80316c79fe224d9ecddde646eb07fe991d4f4917ccbd2ab8e64f5f0950435693688852715e5e334810f27c940b76f8b7878c6ff7e6f9c8e41140abd60aaef7a7b490ee23fc34dad890becaf5fa8aaebed2b5dde722927368aaa4417932f759844ebd3635dbfaf18c86229ccdb71b9076b09a948df78ddae09d204b18e15ec2aff63477e333da2a390017de92a3255ce09677dfc1019d4deca704639ccb1870c380cc50deb5373dd24ffc677a2fcbd762f323f9eca6648c57b72a9ab26b9f4aaa276498d2cf0f3785e3689d12cab3fa2ad7b674e687952f19ac673eaaffded20cf8dc7d9228b3de811502cf7c4cd062a46bd64534e215887402926c4c9e4a39e8c9652527b1aedc83f667532f0f00a06808e5fa5d08ad98e920f6799389b8fa4c59a1521b1088cb949c25c08d81678fcc0d55af58a10fa0cd162c9f442996f63bb8c79ad299d946488113833eee5f3866a018e05eec32006de6e40a017dca91211d0ded4066fce82d075f73376a33676046bf845d086bde80d90143e9b86c413114f77ef04feb31deecf172aae4bd8f956b62dce7e64c8086a86a6ec7d5d869fc740fb43254cfb62c87042e6cfe439dfa55b5948e538e1f28f0adaec3d649a287a883ae35cfe9c88e7e409e3654ab3e6b22182c655cd1be10f5a312c0eb390c81c26a75c0c4c2016053cb163b17f1030c47e06b6757739ed9016fbfc2dc490991e6983de96477ae06675e987e6001e759f945a2d70ffe3087e957c23c4cbec9ed06cda3ba6746ffeb7604d29e38a6ad9ec643ab61a314aa818d29d5e6c085000521111c2eb6e6689f44bfb66e72ef905041229a6c9871918a6d11ca6ec4931cecd782195b7b787026400769688dfe0aca6438db3b38223c0252fddea28f9198917a04dbe0b359b5f6771a96eb99607fa19b7137d9361ec7669dbb946715aa9d16c136a1456dc82d52bcec575d24a017c0a54d5b83b33aa3f8d922cbf285bb2a3d5bb6194a931784beeaa2736efa277ee1ba4a931b12ebdbc1d827bbc6fc59dc9f1dc159167f6391040a30cfa89bc5e68595ecee49154f97ad81e87df5f84f375d5c01eb0c5e9482150cc39305706bb07bca382f7266ba176e46db3eabbdd3810e26a5c806df90ef39e2690fcf90c7676bbc5e0543978d55dacdab9a3772af62c34076811bf6106b708647be41d2c5672804824239a0f577789218f9e005093dad7324233121a571deacc25b96ca71f9883936f7b47f0fb5dc12cefc8f3f99d263f8ee4ee486e5944e0eca73769ab4c76683256d224f2df0b4f560db450ce016f0ebe94a62c8ed674bf9673a7f711c129c7879d620d60e0d34c294c863fbd23a2a8d7f6e9df49b467f0544bee36bb80b3a6389e86828d7fade84cd5a43ca3bfcd8af7e9000efc1565f6dd7aa154827b0807f71d12427e2b42818c02844ed058f14ad9d139985750aa66c5be371e5e47bfb634c65839569e1ed22bbe5bd7dad0532b916b96f3e146bbd9653c3ec806418106d10ca8572ba1df13c8946aa47d77b4537ff527edad43358177b4cfc530d9afb31e1d063cca246308185cf60cf24348a26968c8b998059d625a2898b6a614078e375a6ff57eb00aa4e11baa770092c1dcb4ffdde37bf9640a6a3206ccbf7cacb1673e9f91d0cd5cbd3faa28e20d9d85580268bcd8cb252f8cf4a9bcabff89bc80f5424d4a7057c989a020984c0c0978128ef3cf8c5fcc493ba4554c072f2ed451ff8e96765ba2fde17a24aab64354560ccb333abd5cf389d4bd3dc8fc0ce68436b90360635540c010da74493595818bef26a10da9db0a57164fc227bbc7219c5618b99f2d0a06b3f8d7dbc02187faf4b27b154f311e578dc4597ebf6f2a17f8b24ab41ebf64983f811e0e0827f5f8fd96f61f8233ebc2d7955f16966cac917ebf897fcd5fd940df9f834b901656aae400536d8e5aa1c2617bcbcdee98c0190ee34e5ce513dd2f5f0320223ddc56d824c1f1a5cdeb735c3c790a22cfbf2d5b906ec8d80deb42f04a1cd4d1b99b209489122a37b636467723001ccfc902fc6fa7c309cf83d6942d7970ba0bbf96c0a8e9c4ca29435ef8c2356ede1214aa23776c0192e1e7be9f47cd1d50ecded403ee24f10c56b50866b39f6720f69d861931b8e6e245cf9786bd3cb5c9b1539932df7c29cfd6bc44a64f7dc989909d00aba5e9b4e119a0722b83a1dca47b4d8ebd0c1820ae653db22d3a21e57e5b6eecb0cb39be0c5173b6d392903d51ad2cfc8b7962f7b77f257be586d09f7b5e5b2509daece48cee6c5eb1dc1ff174e8906106b0aa550d7c1aeff7cc5db13751dd31d00deeef61048de4cbf52f33eccc0e4384e519b5beb951defe54746ad2766aba30ad6c46f9d122cd9c921bdfb9f71d1adf74bae7d27024c63169cf99431edde90b8c4970ad1c71372e9f4b02bee0a1b3a162320da912efea0b6b635fa3dc5b5a8f705017fbd55c022813bc442dfbe3b0b5e9a260345dd0882f9cc6cba8f9db6897cab444eaa7a7fbf932a4f477c2622610b4453ea627245673f694825cb3d810ac570dad2da53031252807591abd7a1a524bf240a4e0ec8af2aceeba3bf0c711ba6005833f42c4efa6295cac0842b1c8f176a6ba0152d266604be9c73ea65363d9e942e212b1c8f2c7d99f64b24a5039583990fd1a733895ab21deee88fee982bd8cf37e9c381cd888b02dcb180974e0cbd85a5c79cf0c42fa62e979e5c412e935bd378329458534cf026f7c0a8333169fdac3ecb2fdc508e901a1a97a06625854ff6b170eaa3ecbf16dacb90e617957a7528073966f93e85b199207bc555ff07e14f7188d5fdc881c246e758c2b904ea0c218a81362a750fc6ba977aa7b545af4ded2d7d4c7cd980250557a312d60b4da8a0f801a72775a0069410f786dca80c2e2f414eb95e9f1c3a6244f69ae865f17e5d30657ac4f74d4d146849828592f72f64cb16319b6aba3fb8d13d1cbc22b3bf2a834d24644fdc7861e7962ebcd15be484061ec1193b04a6ba9fd91af73b7d919c00c2360628a38b25c3a1e5bd153219bf6724aa4d75f00c53109eacad79837849bbe763a2c4750db55ccddb2306e4f13089390e89bcadfceec63157f973a5d2556d236a490da5a6006cf0a7d884a7950c59613cb4d9bf77860bbf7267f2a7c71ca6909f776db3677b436e652942d9de8838e668da92b8de59281715bebf97acc6a0faaf0a59d69d7a7597188fef687bc0549ab98c399b8dfff37fefdaabd19f3a9a5726c3ba7fc04d7700ba41f13c69a9738c2232f687105677c2d0396c19f8129a093955ed8f62fd1fad6fd7296c3ba9f3e4edb5fbc75656fbbb3c9865bb146aa880ac06946995951bf68843254e0ceb69c982ca7e8a2db91e8de415e48dd3991cc7dbea502cbd55c74a1706740325e2119b216f969a49f3aed17a7d02fee0118114acc7e29fa84db35f965ae987732d59681ceed2dcb120e208a363b78dde289985a73093890350e3a69f9bbf84ea65eb6133d60f54b0b49769b920e8633cf11fe7ce491429e63b91de75702259dc4897584cc091328a0a0d4c429faf1a3ae96b1651b2dac6d75b65222560d16daffbb35201d5f1111e8a35412e3c23c71507cdcd1bc98003fe43d38110d86fa9b0fd980ac49767f152b92de13758c450adfbf71b39e77920b94b7d4ac5ec4b4a4cc2ba63a9411c2ec644fb62e89a81df4db9938706ff742c6e08f5329b952fa6978542280c31a67e6c5a5d8b5a07d04b2b83ba094b93ae68afc4ebef049e577537cd0b649789e7dbf0edaffcb0b2251e72a4206ff2e612eaeaeb4c50116456435f7241a4955972d5992b091bb4b2e1106ebd8f6d6d86394bfcb7cfc18290440be5dee2032a1a4d20ab97f0c672d1e053f4e1b94ace6a9be97d1e64d8c465a19d1c5ccf6ec3c170c8c0c943d388c37666ab8feec6152341e3956c63575f6e8df1c43a72a995cf07f1a0bb7a521379564b65d93808a8cc4dcba2cbb39c245ac0672dfb4f45fef304b91f4c35f5f9b050d0b92736046b2012604084134df03f3422ca634168d96180e0a9489dee2370482f754fb5f2b8906e1849b57ce452b384935e3903f1f950af5c03b987df2f506e105148f5fe4b9e588b0acf37d595d2fd58a77952aa3f137dbfc90d4d1b218efb197c791d90039ce0511c082f2352dbe889a931ea59d9f6100e48848fa041fb5f3ba764d701d05f463fba132e09d2010ac396cd8139690f383288d5cc25fc51e04d427475d197742cb388900d80e71a971ad5f6065d42b7ecce29b7ae3c9c841c8846dc05dbf27e637d26d22037c1bdd95acceea310ce2e6ad592a78fe3b5824abd5fa323750d74d71d256319780063d7e933d03ded97a534ffecb888a0d8041e7c28029c2a46a999f8d02b1049e0adc1475a13d68bbe7cb7cd591dbd67fd825066b42e7596a7b7e315e4d4c04a9fe0d4ba180c4213d6e7e79a3423c4daf0c77fbb40c1954344ac85e4ef2688a068430a361faf85db19018040cbabb6d9e1ec582782c8bc8d1061d54c7047f0c4de31b246cbfe8d5979ad7756a1aa16616c54f9ae45e4e6e35026b051d1e8b793ab1872e1f6ab3cb3ad33696b7b450429b124ac6bc086a159f7b3e9b3c43af5aef182bbec9c9b79050ac1356763e90b3d419a0239233c0e0b92077cdd8ff02bb1b179dd011dc33fbb85c79b9c61783ad45d423dffc2e169c17e778dc5787dba27cff1d6c41e9966c6c06fcfacd20e5b0e684589e8789f6f6773c0a82fe6c5619606e0eee26022a71249d7025143bb74724b5609421e7698ba02e22fa3c00292a578342d4c517f3072927aa45ef86b8187f519f62ebe60e02b8bd657b69058fbdbac17069830983f13b86d67bcb6b8d261d9e42f658c03b56ef684d70483c2a0e44c2303445ad43c9e9df3a87d79b005e160e72cc64030ccd7e4541b00ec0661e29ca28f96acc467dbc7d3c56be75614395f67d27a479255285c94ea11af9f6247ef7b04efe227dc14a91d179a64d3cfc841884989899f0e973bc166d82e3b04676e83e684a910e40cde648b0179674b6e3986116d3efd4174f0923f450909f1043d069c83c91fb1bc68defecdbb7a845e1822da2d5f0ecc1274a8493ee17e22ee78169ef5b80934ee29ecd8ef092ce2b28dd973f244d7b8989fb443907ddd51c668570b79c6ade0caedafccc19e64ce966f4f336074d35bd8199212ba8ea74fb38623e010e06b4a6c3c6de3ac08b10d71e21c316b6bd992f627fc910416e9f4a13544a648237f78dd20329e4fd48e93ab423e5cf302aa516051930c191a2b7577eb8fd4580b4e095508f8cd7eb70cbb61ea11c3b3b3847cf7fb36dd71bf20081468ac7626","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
