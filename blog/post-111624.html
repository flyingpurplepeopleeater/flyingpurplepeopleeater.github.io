<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa42a4994e060a66ceebae83c0567595315774d832d452e27c61b2839046752d432b932c56f0b8118489be5080fffa632a1977112e8775fb58833636aed66346f2675d6d97d61808fc5dfd0dfd4652f81cd6eed463e520408510f7837d6f9f28e5bfd789e4471749279653cf82f21362e15df326d9f780b534323b933335017f77872772842f001122217075b2f4ea4dbcfec172415274235c47063fb403bc9482c7b56fa4de792e2fd94b6ceef46d858759c2ec84bdb93ebce798aa6aed48a696e49774fac57d2a039b44a3361839a00a12218c97b0f25c28c15dc7fe5395691b636d44ffae7cd7dd85f453bdc4f10565eda34e85882bdacdcef806aa2e68f5241d0df8fa72b7d537a121610d619b2518bf3d49f0072bf17d90b9b0b53961021d859ccc4278c3f08ebfa022ac7cc2991399de23e3aeb8d2910ef6d0e016671a6e3c40e53fe34a3acd0cc37d70fe5683c823d75475d74362c06e013a61f69686b8ac746286d78689ba61c41f196b69d9f7cf86bf7996be65491c2311d546b86b8be2bee61fbc7b8311564ba205dd95a38f1e04df3da10189ca005f4063b35f3c4051c99746d86654d113589385718f9427e6b637aa756db147c047ab2355ee2b61507abd123aadb90a484288a7ad66a03030af40f06b4d9a2b6075a499bf0d28e87d698b78fe70095dc4cd04423533f9bae1fe710d2594d145112e63f225753456d854693b8bf9b2cb12f6be19803ae1072a6caf3e35c4ef8d789b0a88613b967198677ed60cdc9795475397dd82bdec429061ec1a66994ce285f2103538c1fcd2f7157aa584dc9f0fd547207fede210f7f9d382020bc2b704f7b8b7184c87b1ff366590845cc28e51999b915106b1c4f43c9a528c7d0da42ff64205a5836a9ed2d02d01cca59ab91d832c70e4249148c51bfb3e62d3a37ed867928ef0a6d9a661efd2d3d37ae4e6a9f49de5ef3ea69c9892a5c9101557a3585ef9fec05cbd84736f0672e3cdfb71a2cd6fe32eb36a7c0d4ad97ca2f16a838c620092bfa1182e31692aada95ba156f122cbb4528aa8a5a295cb168672166f8aa094d98f6b1482bbda6543cf42f0aa5b4aeef2f1a969c864c7fe59f76d7f4d91a68db6ee87a481ad54c37f080d0aad6787ed2d77836abee3fce8ce3b1af6e1703f5a9421cb21e9df407cc4ba9a15452f0e14977bfb5944b80ed3968e7e8418024af4a91e9133acfaa2f794ebc0e6819c520ae20dfa5b1021ab54679853302c3fb599c976bc25dede33f2789f7a31e5369f1e5b5aac1d44e31da84a69894fdca246f5847ff2129cd9a4c9985a5728d1b9671396486626e53ff319540ba10678700b7ce2bf12cd5af4c5aab4de1d3899f69d4363cc5b5f2f2f18b6201d025e042e3f7599a783c4e82f5b1bdc5cd3c6ff30aeda3a2b0af99ed91b860c4a2cec67bb9d931c73f699683708317b01c282930bf87ba4206a5d240a1fc48e89bf8c373ce562b1dbdf51a5a8c32af0cf782b71d7f25c1be574b7092d3ed51b4c9124e6473417b8e4613adb7df001e25830e3110a50785ae798f90a0ffeaecca6caa7637c09b4a7d2c2de28a00a1d50e1cdbe2f0a0a707bf9ff02f284abe53b39979aa35594ae58a13ed8129a88f3f08ad8bf05a34de0f97571e6206e32930df329f6c2755a1912e60c494c26fc6c3671dbec2132083ccb763bcfe38c43502a7e0594d91b864218ad143dd8e836730f2763829ddd7c7e3d2ea79908a33e817eec967fb6f0f050dc33606b2de8e252d762b1f4e5dc674db9bba8200663f959cd50508d21af2054905b193a48a6644f28be313d9e33049eeeeab601bd348ba4187eda4b9c6f4063b04b6a53ca59a534c61553c3b005983c442837a52a6cc95910598ee322a3ba52471bd5dac5c44bb59b2f0e88458e8ec16623efd551a974f2503fa96379fb3c372cc5c9cdc6d9837a446397b56b0280448954b25ef4330a5a029bec4b37537db219bc0db652f1b8171a68c12198bdb17858b3895a8feab0969c02164fa7354690566b39e3542268279a131875b35505bd8c9ef10b2d8928b4a6a9605cb5b5e60c02b4b56e901ddd62b58a4e15a293df0eee8ad0da82799a586dcc8aa18c57f99c14edb4b0b9e893685a03df0c7409e08f3a3ce66c5cd10bed4b935999c79b472df6eaab2b459b6ad8c32df4dc20b75d3086a1a734720fb0f715d1367157954f5c959f3515984f422e06217ed25107f00a75d5928ac800a4c0cd2e8e8de7d67d900bd8d3b2e4fa45f15c5321e8c3cf0dadc7d06fe702e27fdd068c7d5ab623b1f9b9e992e5efbf0e7413db5558435bcacb35ba49af4332a460cb1e15995ae3fea74e67e50c843b5ae63add6e4f55ad8badae69f55a85dec3d5eaa4f94839c17009853d6c6c7335e3220de2d01d39f0384e8c8efbfdec75715da441f46b1cb398699bac771a1c469739b8b8284eb23887ed1d8a91ea00e4ae5097fb26519bd38281ab69522d2a0a10ccc39bc1814447580c8daf557cedc64568ef94e23f31ca9540d259633ee7861aeb9c41776850c03240071598081c28e31068a37be3f88781ea89e9c7a5e5bbd9d8cb0d780b2df89f8440ef874c657a8ef873cbbe7921c4da76773620e67197d01a47894050ed41cb89c309579eab8bbe3c22143bc9de0602a3b4d32c5009e4247d9358ee9c8cbbfaa704a4020df8205e6f3f2251093dd9fc2dd04d17cfd6f0b55dc862aa2d0d50d181d6d8db160997f1a7303538db6705529f4629c8cd42e1dcd711a272599267a810d1b7ec8aecc9438e8af4d63906b1f0c4a30c6c404e7b9026484a47db976e17b27bba652acb92573d6fbb3aa42ed70d1ec66363212d84095dd89d0e179ec6a3f4b52b2f3a01a9981db7e03a6769080d7b4d5901037d54f6ed12ac5af94138d27342ef28efa7d658297af139703aa4708871784b30ea95d502fb2f607e850894d95f2556b5dd752255a9a0a121cf94000e402991770bb42aaa36811f860a2aef2e7464a2ee480fec7329eb8d3c8ee8cb199475eb70f585a49a8a20226804834136cd0ed38d3f9f9366bf9e7bb6a2a1f590462961541f0db6a600e83c6a3c1c003ccaac26ed9fb66a7b73bbb853ba78033d451264779d085d128c58166a750b3a279beab6f43542e0533722a36716dd5661ac17f5afffd1ad776cd7268b451dc7ba8d058b63f2e07d30eaf38abedde8be0bde9ed8099139f67d5bab0bd7b5bfc5719e7686e66f1ee5f2a23975b136628e3eb60058798f47f0fdb62087d24c151445a8404b71b863e90e4af2bafc31320a72e908f68ebe1d9106b3ff707079856291edc7892cb2061e37365c643dc901cbb148e3a036c62d9eb6f6bfe7972663ebdbe7495981e431ac8d8cbc200fdeae7d853e13c6ad2da4ae74440563cf2d8e4530f5906929a6d95be94e9a5d97c564ecb970c229bd3438ee9d1c38d37bbd560e9a37a228e312ca898ca84043962dc386a9749e12774444bae84ad24ae54d609e99508b9dc1f20af0b39784bb38064ac21f94a5b8fb154f291ba6cee1ed6eb114b7982213b6dc69ba93bd190f63036c2d8e2ce27d9c89dadca3140eccf42869181402aa7443ce3fc3aa36aa1c9d661957723f14438543a6c920c6a2cfc52610251f17755e42fb5f29e39a472bb0767ec8c8a3313ee053742175470a41f70cc309a8556a8fdae41d40c2b33d7bf46ab301e5eaad04822bbab2c7c5255dd638380b51ca6f1f36d0c2853543c053a57f56d745c20dc226f85e17a1c438087bee251de54c7756ec3f5df8486cc4d887f435fc4c4081648c86c06726a7bafc35e319cd5426e6b56285a5ddc566575b860cacdae69306bf882371d8ca61ad7bccbc498015dbe4ac6a1da72d9279fed6f04f03ba584f735ab193eac75a10840adfeb5bc5eae134b30ba4f4912a01cb5a32a099ca6de470b13d39cf3471189b0a5423e676eb05df41f846b6d6ab300397003a5111b4f6522214786fb2b373c340c4cbc363e21698942c118309b194abca07c7e20cec8c52372ce3d45ae6d875f90280bfd8887c64affb8de1f50778f21fed8b5ea0cf3068754e76da753fc270c425332d94a6696243f2713814481f1444ccc0d05d6f4e9ec170fc522f35ada0f09a3e423bdaca6a07e1ec4c060cd76328874c0e654e49d3376589467b587c524b300e926bda0c76b2a7640f49d4f35451c0bd24da5105c6d527f89f5d138160f9c0c10a8c924bf56b68e8a817923457b75529bb84b38bdf4ece48b1858dd27c92d9cb7ee168c6259ce142f7756f102ad43a0dbdf459751c6dd5de5e02118a944011a37c032e61b67c6d79142fd5bf6764cca77c5f20f0d09f3243f47d95d81e3d6787efe6c58203b358428659873a8a38faa315e27966bd293d941019c67416e346c5ea4d54d96c0bf91b08150dd530bc63ddde91c7f48f128d1edc98e4d1af41081b4822d2b0b7e8c35bcffb2e92054c89462733f237cb5732b2ea5f6adafb6ff15ec1bb469375e6e7f89ffee11b00e8ebcac41b40b9c8afc13ecf527c2c7ee60e61c3ff495f2eaf581502724a0236ca1814a08c87585f57ba1834fa0793e859d91d69cd68bdc87149197aa985017501065f450d04c85bac89f0d1d05f16fc9a86c846ff348050412042d0e88f114d15821536487b3ec8b24ff21a260e53e5d1091cf40be5471e8908ce923f98cd6179bbbb4b6985af56f98249183f2a9f83a9cf38b4ac09bbdfd7fef0770f519c2de40065f01402eef876c063c586e96f22411fbe2d992753c905459ebd423e7cf6fd82a1b9b3d88562d6226426c763f17f9290b607fea7617e71de05f92074c523b56f7430f3721786ff70fc643f3946639f198edd090ec701e5ffdb3c1181cc542f56f13128487f8569e5458b4ea8d10d0fb90172b5c7f4fd4c44aad69916fbce8f554996bfdb283ed59c88f1cc533e604a778e4c2dad94f743d89c390312f9748a2579d5e98f9084ad2ddef1779f86dce1211c9e072b95ffdb664609a32d17bdc952445646fe0de548c0832fe9b43696fb8ac367ab94605ef138bb2db58c4c6c89071c04bbe06b3410312946efd40449c3b80c7c7b08a3414cff0a40db91566b18dd36f9cf193b00c074c942c4a3c9137aa4e57dc1297502efcd6933ba18271bd9674e9247d044e582ed097e45b51e1daa341c9ed9a8b0b7bd2d1c38a1238a923235b2569afcf7eb39d471741fa575047274543f14fe9b4914bbe00a30df3395e8f4592e4b195de255e4f1c1d98e4debc47aa97ca9e300c267ebaa86966c69552f49efaf27e689c58be150778ef1557b0b9c4d10262d0678ed94920c79ed2a2f1a0a9295174c9647b2ec5bfc5cf6bf250d9c70e0828f1ca888f8afac648ce3110dede5d5bf914efaf56e9a8144fe4d13b3f15f215835812b724e1d91c3420f8e92ba42ffc58bbfd498e7cfd68fce3b1b5d468965c60f0d6ff19b936e8373f3142d54ad2f8bfc383963bc8b2b21e4ef771fdde44c017bd467ccecb70045d2e4387199f59a3291ae0cf926872d8a80cd9d3ca08a8a5afef440f0f21199d66c9810a3cbda27ef01be8eac086249e7400d68f0e0a52c8eaa05e3fe8bce720a02c62fcbf14eaa28b2cc029e480374c042a64f65d02dd99df5272ca616d73ead8d152828d2a7595c4acd7d071a7fe3f0dff9d175ff93137261da7ce4e454b97a21a9fc6383f4f52781b16c052f2e0a37e47c8fba976020a732734d34bfb425fe1e86cbbebea96117c44682dd254e4e0ac09a66f5f5f982c6e449a74bca0676c2b752ce6e5c6bf6fc1760b98697bc0bdf8d1b6ee897fcd1d10c14f716a553a03a958ead0cc0307f199e948f1242e17bd93f6f0b664cbd9aa55be4989d554652674bf3eb7ddd1b88aac259b1c3f3e64cdd4de68875062b9db4e422f11af8a6e473b45bbd7aa8c6bb03cb04a13a1c30116c58a9fa5fb891e7cd391ccb7ca755f5482536de4e37e7ee53b434bc0cb10caef9df2f9e871cd614959145e00e079ab960a090744094d4b3222c58d6eda7a9275a7fef2764f7fc0ddedffe050f703e2cd1bdc07850f6a86d37f206c42c04413979ed7c7492661a8b3b4a714525cdd7ab7a6abdbb688d60db2d4c8dceb429ca69eafc2332d17969f6ffde034fb68c35d377d8fcb4fb2547b4ec0aa705818ae9996a40a5d55bf19ef86f3c1a3e70b3443a37d422f19cd904d82d2dcff910577f5ebe5a101a0818c8946d0c13bf809423abf748785ded0ba87604280fd14ce178ac6baa2e91d0e7af3f1bab578bf734a3ac0543d4c282bb619e1ab7ec0045ae424e9d31499995e57fae8ef3bcef3ade23216e0b0bee4705e6f2f3a0d7f99bf7f31372788797a1db2f17f5f4cd92c2a59e256ab1f9a98eac9bbe2ea6cb24aed6c9d57262e9cb832cd1dbad7fa8d12aa3827294e2aa3733e7a364231baa26911907b280d581bc96cde3147a1eb2070f1a19380792f4336b73dd371a558a89fa7121e91fc060705aedf8a675ebdfdef18411d40ccbce3637b138f0b26ba05649a6cfcc5c667938d264049bf79dd74a046d1aec42af5ddf988ed6177198f14912cb99284dfea359b53d80a267a809bed12c6d9241ae231bc7c2964b840bb1db1e2d39763ae96b33aea7f8a1ff7e50cc4d120ce26f11450356aa5966826c05ddff55366ced397c60a1c8c3179da698a00f3838b254cbdd8ca451d7a44d4813b505994f9e38b5ec59bdf1b04b34ea98e0e1dcb592b5886a531e304bb6928e7d7c81d7fb1f056ed3332ee3d283182cebe9fedf25cbb2e06400f4835bc85c9954aa0c85e256ad9a818f691594d9f20cce12c8d1af7e0ea85f102f87004b9c107d8c80fc5422549d1bb0474a2f65716f8d7111b6c82b0def8caa28facde65eca8ad2e6220254b0fd55a07c6ad7e2b1aaba2978efaa9f90ac7cd7615f4774737542ec55133250a8b9b86df31659870dbce74432407a1ce864ec86d79c119736f146d3178c5445f874c182658558733623854cbc758cc08f6a9c27221f3e5bad8a1e38fde87e8cfa8a7277c117c1976797c77f8662d219527042902784d09566508d0e51c7c26286dd6c80c33c510e0f319dc978d52d21838de69138c6640d6a4cd836c502d89409f2850ef25e2325f53d60eb57a15156d89a8ba13c2acfd239349fe9f8d0dc50ba351658a1030cdafe7d8533b06219472e5f63d2e863c49c1b3bece1f2824e88e574dc9f2db1e397a40db06313b12e44bb7b3184aac6325e3552d3ea468e1b1765a89c80883fa74db5943bdeae81ae4913cbc310321d8b0442c3fab6b56ad4f01ddb28f992952dce6953b0191e343a810cbe992c67acdde887853fa3606a73a3e72518539afaca16f227ab75f5b15b3146f7f7777bdb86d3c98908bf039eb2b1742ecc926dbaa34c642f26472cba3f2a5e7f0c3c3e0356cd51130fba3464c3926f70ac57661f72764f28eff5eb315257d6d442d177b078f9760c646f90e7b311a4da7383e05b4f3be04d581940dffebd6ce6887ee2b63c630e7ae37327221d3a75c807f7e7fc5760d79bba6aa97b9c0e2e360f928c964cf9449696126d7d75383bfe232b184e6eb5e9c706823f34c4ba4ed079011f296a758e72f0a01ab790c2d422565a42478aa2f4a79feec77e5cf5d3a34ebba8590f07dcc3c1963f673c1747f7074cd3be4ba99eeb79e76eea9095df1f063ad7f5e8805a9425c1cb909b270c715afcde5df321e1db181d398dab504e9a0471006f0f64d1baeddc5fcf9c5e8483e86aea2d206bcdeec03bd56a8c393e9d84be8826ba4697e64316af2f37cca7f43c400859edd569965f48e92f9d2b81dbc02ec3d9f08fa0ab08357f2e046859296e8a32a5704904229944d9575b0c6aba1251c82d7508f731224f83540e9e35763082eff544ff94f6db00251c3c828d7d63c72928c2b4f2e11a9972c23a1c74c7eac07444c63d3976ca26d96fd5ba267bccef44dfbff560155ca6f8feab6c60b99b3ca78b9975bcbdf98057787a567473512ee7886a3f20de7ace2a3bd19f9fcace008f7b8c31f042676e3c8f2d5dc32bc7825d95f557026a98cc95bc634fa4e0efa4f9d78fd172fb572944389b9ba92a2461999cc9753ba2909461f50da966cee7282324edc5f3d36b79f977478f528eb9ccb43040b34ff66bb8f6556768c7eb0033d897b9d95dcf5c7e27c12abb3ff8e56a7946dd18721dc039d56bda7cc69eadf1f668eb08c5d2b143149e3082c0bde5de26755de4055873b6d102915f50898924302edb44777bbda7d6991cb1a875436b8a7bed6cae19384e2e6200f32c6433c01d8e3d6e66d9070692307b66105550edf274e709b28c99f8a96e60611ab47a7c54eaf31d1dd575ba3cad5313638f8fa1dccbdc7351e974439d2b112f1206297314ee6c4ffeb1b703f547dde1fe19e2ec2f6d485fc3e5771c2e6eccd3d6cc5df1aee1d33cd204da64e1dc47fa2f559d0538aca2602b8f4faf4b3b76e90812c97c9aac94102320c87d7dbc94364b7bf92da4f77a92f244ff718315e89b0468e04d2f9608643de7ec337ba1d5f6839f42948d9f023ed719034a185852c6a30109a2eb1725beff2ef5130934aff63275c78012c628b20eae3da6cbc292944ca384b39ae086371d1ec375aa6e7ee41634e14be8a15916ce530d3901fd166ab5fcd73aa13d777e30519eeb5ce8486afea606245ba07b63e3f6399ea10c35091ee346c5d5acf179eabcbb098bb044aced9c7f8007a4319f32e252bee9fd923a83554f2ac17b788d7821dd9f8dde9b2b862cc09cbf9442f2fca86361b8aabfb837fed04e6e579f0806976d6bda7aa2396df969b69daffbd38c79cc6c194fe51f80dda1e06c781737190590cc498717245ef4ed06efc6d7e4da8e4ccca730eee2a65d5a8f2a1e18840f353b0bfca449d746607c58cd84518026578b077e033e26199330b08d4406d7265626a1bff464441b142fcd8d7d334c97387dcc4ec0735741968aaf466cc27b66beae6e9a4b674f5b5e18c7e414503a5c531684828e81e236f59e59294b5b210e0e5961a7a112b57dd922deabb371d5c62cb03e2c71ba0345ddfdb108e7557d217aaa9cf6804ade22f2f4a971b32ed1e544ad68ce53562eb89a81ae3f11a8d62081fcd1e18d1c7a00fd892ba09c6d083fbbe727cffe994b3754889066b8c3a15032e1b9e4c2c09943741365d3fb34b61a402f07c421cd0cd6b653be90b3b459be4b4cc89a95b98bb78d9bb6a7be7af6ba174486423c30f05c6cc565c9a428054dbcc485c17914b5766053d8437602b401e080f3650681b597370eb1c7c50b26ffb746e6c95d19c3ade6c007ca7304ed1bc5803c235a373131eb452e8d2472ae1afbb078f11348dc638256707793a47730deafd2f74cb1c030f5e718ec84ff8eef6269dd930c9a663b1d6c08b297f749d3859dd649a2ce06cf1adfb00f0f70bf88043a24d3595e4a6b70345ff27e61c58bc772e53456cfd3f3e9ad0cf39e8d62eeb92aa735577a44924a99b7ab546123fca199d4cdb6b62c6d3bf1e93cc9203611d8aceda38acb75b83e93c587b72e47df7edb75b9a9dec7eddf3dd62316ab912a85e028bab34d6a0542fbbccde8c12e275d6d6f76adce271d2988de07f92afc17fa03364a53ce6ad77c70a8e5e323a2b1cee65fbd3eacb5a8c757d023c81b98c0cccd7ee73d0a6775c74cb971d9c7b175913c12c46d1da7627754ad396ca972f51b600490921b9d7382063984435f6c8dbbaf082a2ecbdef5e8fbf86eef0f2a7a7a847a87b26b1d595fbfe2932b748ee5ad6db2b1bc290ff995ade569f8368a56995690a8bd7f2565715f0078a83c2b35f13819ed97d223ba11f87fd28f146b086d5e484065216d0deebc07415a064cbcd6ed828dc9d2a9564da41fcd775776898ff1e2a817b703df21966d49ca8ecccf0f817ad0580938e35a2f37f6d49fa0c899e82388e60093ad1b4bb89d3435cdb5e980c364c4ca4ac488986a288c57508427631aac9ccfa374cb35c6a39edb20420bcca23bf3545cb56bd0ce9baa1b6f0802305292bd84640d1d7a7726a9e17ddc6408fa8ff18ce13c8ee31189c76efece0edcc76ea9e446a6bcf48669545fb0c3b9d97d8e8b6e8819f1717caabe54877649f0ec93a18b983b07f3cdef23490740655d406fab666d8c44a3150dc94959adb6ee4c1d119432c53c73da71272ac3d84dac0349e05490e1c78e62853f0d888d91148cfdda45d4b001f31b53462cdb5d5079b8e0bb7b541039266c740ae5c4d459bb420abf935299c53efb9c7c7bcf03356993ba4daeed09195494981845b6ae53c6d2c4996d94756f7102b48c01b1b900b7f0d2c6cce760f1a7f65f3c303e09f4cea9851d25f0b22d18d702b6641298063c4ace4f5293e30f3fa3d6c9d0291746c1151997d5db14d5a68491f499ae01ca8cbe3c197b17fc662f92478c787e30c6c1aa153c23b09236806e0fd7882f9e9a31edeb81f380a6046ca92f6534849c846bd75d36b280dfa07a4d5ee36bb1eae7c1f069f8461206b5f7732b6c10f2208578d310d59ac82e635bfee0bca7c32d6b08d1d2e81c7d0962d9bacefea5129eaa55097351190efd1a79b3aa3796c5e571ce915d47246089a8926ede2f382011081222c5b77d581a8c6b19581a7bc01ac72bb7477a82ca369beb0374f784d882b6b511f17fba9504b51d7e1598459a06cee87a90c00633fabc8fbe7a61b9a896070fa0a6ec10b69835bd92aca3d849356426300da12dba94397fc815cd7509af2a2700baa904673484f906428b433931995d0fc687d19de32e307a4960d2787ec8d142cab30548433d2f89faafe37030efc718b7837573f86a9452dcf84071aa3c0db650dd907ec16c642cbc6c0803647bf9b39fd1b5710802b748e92de20ce46c5ae05826295275fe1f1b261cbe17b097c1c82d734255808523dc33f044632e25a127974a4d3fd71644fea588b388d7b096d8be362ed59c58dd0ab746b1146094af10b5a479239bc75ee97d20d53135ea40654cd8050db31a18c6f1ad3e00265f26f5299296e788830df03a6cdb48d7a05c37bb414abb35abb870f5e6e4f3d7a4c746925b65872afd154a2e77d905efe4c07afc8b72d629c46a6a18c45a611d941f7dabdf6f49fe7a70f8665271fcf07375a72f5acaaa959ce1f3b60954187504a11e17643d86a2e1f0ee0810ba2b312ab3b284241725becc38e1bed193af2d79c9c31a8d4435a2ce26432018b43125217fc812ca410c5964c4cca559db0d8f2bacab1f06675a95d7a72768f0305679276255eb74d9739b9cfa774de7c634aefc71de5fccdb74735e0fea4e9ac2cb5cb3d0904b84ef178b5ab40521a9d40df77bf2cb3bad1d2f24dad7722b2448612bdee0c2139f5e5b4547004e070609a3aa7b5cf867633a0fa39bd2bb3aaf1ea71b2ca110db2cb99e9b9be9e9ddb7a72af3264e037ccda3a2390e4e6934ceed149c0bda1af2672bcc77dc2db07655c10a08e777553201d83c7ce9337617ec0ca5acd45d864e76e862be2252c709243eabb6c2371931e2163ee3400937d9388c4b7e09ce986f226c5b532e84c2e90c5a3920b7aa2d7612ce1ab9d4768b8a4e25ade192b54b3decb8e0b5e8920e7db432c21fba6b9fa6d353ffd5be226aa96028f005a3123be6d8ff91a0d4ee7f017cfa1f7d7425b4b0aea6f2466f00125383abef1c3901c1f52c162a15da5c0f95b6a144be258d346e7ff2c88f1bb41800941293dbfaf3666d9cee67a6d96594accc82ab3fad0fa07ddf8514ec1ca068daa44f20e7684434a56e7ca67e04822ccb188c06bc13ff7be8cd20811bcd42ba90c3b88262e8e6834808f1ff80cb089d8ab80a72c6723ae182a5378727c2816cf26c0b62bf1aef2b32e11e0c7571ee0e6b67121301b4a55c66dddff0681fb9db2cfe94185c85391e9668bccfa69ecc822ce4c620f5f7a255e4e2a511380163a5de293c62c648011ba170ab9a52013336352681f3f697305f285e2b23a515875b3f99dd5c671f88a6c676b6f40db43aefb9d6864c04197cfd4b04d84e8228fdcff064206f25e141b801de0fa36bc903c255100fcd20ba862c2f1cd0a4b27661bf4a56394de925352a5f194985cd61a6dafa610027fc87c0c9fb9ab6988fb99d91d1127eb4cf5845c31c5cb21e77b79b673f2fa48c2d1811f719c38503d5f787f84ba2b42dc934a6a1f4230c11a97cc66ccef5bcd0d28c1dce6b8577e5b58155b7ad05ee65ce61dd0ee9b34fde991ee4ae8256c1f3322b6a76a52fbb7d7d95de1ecac6b6e9e92d1f13c51cabec7ab6285d68aacb86afe327f21643e52cb9de50861c5148c7132f617e8509a8eae44d11080720405008688c62242c8cd2e07ac1d8d31af3efdb64eee6166c26f20c2aedc7a26acc17c1ac9e321cea26ec3a0e41970402adeafd435786271ccff5e58baf942161d9812e1503a170813fd1b2c9041a774deeafda694fdf8bb108ba771e59f7682ddb0efe9092ff969069","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
