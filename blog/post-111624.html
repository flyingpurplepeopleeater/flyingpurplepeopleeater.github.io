<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="Cache-Control" content="max-age=0" />
        <meta http-equiv="Cache-Control" content="no-cache, no-store" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd131df683adc8dd8557048b2a7b4f3cecb7e232cbcb400f97f11eb6acf55be03ba7ecf9f58b1cba4a938c291b0f326f5837697220490ea63d7577e120ea07414bd937741e5d4c42bd34fee11c5edd05a760d02b09261125065575eb7e0f4bfee5773c60089d4253781dbf5b8efc14d60a15042f952bb71a79d364b57978275c090555e56b7e735262596c25478a7529a6aab529db03ecbb984201b8e962d96750d960208a94ab9b833ce445a6923d639852305c1ea0208ff16df0dd7c9bd5fe70a44aa15c8c35f990f074444da7bf698ad6d10eb43743fe24f61de6dd49c74030e9107d5da3d5120dde03d3c771fec771860e3430b17f150e4ffd55d9b135f05bea3cb262f66f2cba36feb9a1a8387edd3c5180284f68772cee8595d52730512bdfc18f986db837efd2868240a3bfb5fc35fe0303be11803623c68f15eaac76b17457053b83f992b1aaf0ede051f5b92d2ab45ed4be98c6ec23b4131ae561dad88c994f6f4ec8fba6a4b86fa9e54c446982f1e1fe8c2792aa2161b03f547785ce443154b7a445310edf18c9d8eed565a2ce68752b19f2ff49c36aa619731873555818535fb803160da5c6af3e504d5660a23b73db60826a2dbf3ab7dcd76c29f21d53f298dadc31d35676aa7ed20fc5ca43dd72604fc6cfad4a88898dd9a87f7719675be976ae72913ab0e6e2cfef1ecc0528b165c6813b17545936420247a11a8aa16df24e393efa212cb5bc24aeda0d44ed041dc8be2d47075e9fe5c00f97eccb99a61553aabf964be7ccc00040f6ca822291dd85a30c1dab95ec04699be2c00d1e566bbce97510922711a3b3433db29cd866f9d53c8f8fe47c8e1be00ae43c6865931c3b384ec7dbf7d73d95b62a80e34ae8e7c5a6f3dd384316715c696e9c4fc3bd4d9268d1c1824d22253fb1358a9f59e83aa46213f4fa91749da5a7b15a1ce1762af3d44c7f2f84988da2845c3ea2ce85d41c49b25dae32436b6f061131d72cde4f7138dd1080dbcd3b70c19828fecdeb901546630d08bda006d884a5ad719fb9d2841cadd3f179ff59f889d955a74b55da00393ffc9e27958e254b14b1cab6bb0c440e57c735bf62623e05085fdb6f4937478acc3c45d1f75a9c8b85c5ebd165c5131bf3a7be8f455db18a3b19c5cdbb47451ca074976c6ac9c526961090f0b13ba4fe2440ab70d716db60f7debb19c34a0ac33a2357bcf94f2cab17411938d82fbd0ab24031ebd298d8d1d81c8a0f0b613c5ee1b0c25403f45c41680e00c1ec57256af0222222d370a997bddf52b9ec929322be488ee984b67f88389866c0b552c6db6f61072be14255b0dc2de895ea9f38539a9e7a5c5bce2b0259193c1b97ef074dd451dfa435c67c806cb2234520a4aeb558200fe06340684797069f8b6fad1e94d3322d621f4ad7c14f89fc7aa307b62f05ffe86e0fe77cd2a54f243fc55142216d432c93b2c423c25db443d4ef00fecb256c27582953272fb5f685b069778d62ce7fe532dae20151ba075acb7f4b6e82b25598936680fb4f4cf87dc6b75cb3325513c6e3d76c2f2a248c62ceb69757edc45912c27cffbcfb4da1925da93351449622ed5829f87feec27932cbeb2ef1e314c77da6efff42781f819f854f0252ca363f52e2345bbebc16a0058eea5699dcbd54a403026148761d3662c9baefd806833b43358aa5f5a7a643930913c3f5c7086be08f87b25eea45a65dd36e39faf43bc7bacfce5f217da0edeeec006ecc9dedd34cc70556200e42e23e7b5687c56e23ebd239823e007353606dda35b3cb8d87d914a25b77113054a2b0b734cd7b40b8d799fcae00d62bd5bfa80a1ad03c72b4c1bc59a2ec42f8605c6cb57d8f0a9b5f5b3ffd4693a1cf4fdf3b96bd9e6cb54b1df27e991ab3fe3ee2237a81e2c3bdc86f0cb0c75cd656deee072334d8443b6f50680e6c130cd07d242a377670130ba4147e8fdf7a70af0fedefaa60b4c6f986117f330c2282d76f29fa29267e9ce4926259aa2cf85d64bcace60841157b5dba6b1cce665b662dedbdbed2f0edafe49b6353f2c35b240cd6018ad21459804d84484ab8a033544f0d384f9f467fde7f092713681bc96580bb1c1045f8477f1b9cf9218dc3a23f45e383f65e9a3b7d7298367bdc22711d8f48e16b520959d7dc23f98fcab16e8cba8e6bd45b960c98a862e4e9d22cc24069671c55d49e1e2e19a9e5e24d41b446bb3b2df2cb7b8a1a541d7d27fa940f935b566537d2439aea7cc2535273ffe8762794dc74d8ae0828ca77148bd7c26df77e1379135559e7ecf001a20cab3f42998729222652721fcb60989c6c674f1ca098328448e360a4e818c9f3828236902637294c8c06c54679e5a570865358252188aedabfdef0f1173bd8e7d58efed679ec86aca6915b7d4baca1433456535a64274c4ff01108ee4ca71025d817ff72cbe95032bfdb56ba7652c076392f70a5554c30b3328d918a5f6ec11ac340c1ed7b61c1c8fe5880a54c18e27d214d6903b3453ba78a336c8932b32ad5a2881c65b47c5012671108c79158a0fd9d6b13ce38d4252c03aec71467516fdab66ad27f24c97d6ad6b8bce8c3805d3e53b3d514d7e64fb74012c8d5acf4e05978249e9cb09f9cf3f19f657d5e937994822cdfa301d1d22c96ea54b51ab8cfa05a1b8cdbb6ce88d2a16ddfa3163548c3e1a54cbfa5649a63df3dd5f81cf9a573a9dc3fadeef6f35d6d21e9e0b91a2424811ef88b1d6ff32b1480a3f7703e7ed6ff96b260a5af2ae70cbb01f92c57497f28d5c11074c213b671dc1762e7efea192271cd666564947c203a4050179617f9e8773876c4ab88dc53515cc513bad893a42809e66a581aafd3e30590cb758ef17b734a85ea6a24b0e62d0b646a962e4dc01b1a8ade396bbdd65e3284239b80f71a67d86bbb8ba005eb965e062eefc2b8378f79569fe2b0f3cc84d17bcdece86d16a7f8ad3b87afea3eb4f9f8620b40fba8b20f8b0e0e14db4945cb9c6a9618db137410af45bb5a5f4bd0fc99e2e6a7c0eb4f4cc285a0eb27e05f4a34e202056d23015f37bbe9abf7a1b5757641f6bab4cea3e45b48201ea2cacf8933a0ba256210e662c555dd11d674de431fcad4f7a97e1f11f14cdb8de27d61b7a7d02c83aaabe0103eeb63abf0ce46bd18c766a439f4cc35ac50bab9ec9277fdbaf91eb43844a60d31169cdabc65998e4e11ff0bed477f122061c6734f60e7a4c6bf3c73eff1e5b6a4325c7d2b7823b9d3fc0574ea268602e20f128fecbfee7f11e7b2070b6260308ab21397d6c10f6bbb24e98740833cbe055236662b6422007ebea9fc1fcfe35794af755db7998725aed43de45e401820e8e3c2d1c538ec26a8275364efd1ad2f5e2470f3f7da8e008b74e67dcca77972b19f56a03b33ff716a383f3509703c562c62445f3e3dd64b238a3acc4cb4af9d3c415acbc95c7e8bcf18405f85a4f565105534050aef68a2693edb020a2bfa369a05761acbc5ada2ece607e05cfbf2f956a64101a081aaa601d7fba13c3b4ba0ce5fe54991a93c358de1846c6178dea88499b855b466b630ac2c6b8e98b94c2ccd8a7ec0820f36dae59a58259be2f39ce88f8e280e521b60c60def6b2b1ae87dd8c320914c9a93500a4c657b958666d87ed81b7ea0b519ac9f2ace75445d6fe954d3cdff1d22813376063e0e1a9c85f8066277dec6a5998617e17de4dbf37bb5972d7bcb8ec15ed215eda6149f4f77fad52bba05da937308f52880c955b7efed8ec47aa1eca42d4830d341ad428f9485e639f4f92df05fb010209066a29f7583c4c69a9650a60bdbd4530c39f7fc343f99ba0f77915b718bada4292b2042802b2516e294ca25053a444878b2df841fd688fd40c38c873099ca7a2340ad475ccbbb2583cb86c546a3d92193bab208833e8242af85a794c8c379333e015676ee3e0e257b37ca2b7d0bde8c0d302f59aa0cb9734f50bbb5eb7934c55fdf8266a5275bc3374bb88c44a6dea87e16c3273560047b7bad8cdc86c4c3cad07d1ea46ae7ca6f54ce1f9e5fd9ab4fc148c103a7214a9f340e6da65f9b08b109442ac951caa4027063fc2134872f1fcabc0008a6551b58da0dab7d501554573cfb2e5964bbb3c92c293bb2f65748afe52add7e18dec21946b06f9883bdd70cba47a05a547043a454104773f0d752810a9e4b476d0655fe1d5807f72c4ec8dbcd54d654a319d2ed7c784215d79157d78ddae3950153fdaad1f79fde96426d8ffacaff664a95803423da339e3e6c05662e187e52fae9b6ebb05c4b7f94951b472e40f854e7a184eb9596c69edf4e03ecbf8c86379b33547636a929992b56bed1101850a9569cb8310d3c198e9e3abdf0bd14bb5ed49d89a37b394764fa5468662ea80859c2b17bf32623b815429c3f41ea4d87d9628b18cd754ac7e7b0a49771634f7b9fbb1fd2049e00c16dadda13102726294d82e3cad205e5bd868110ecb55a6df6eeba72cba8b232fa5aec702fa7b401afcc99caf3813981a1df455100c8627a577e593a5907303d6772ea1f8ec8c3785814cfaf40862c9ccf88882802b23e37491608b247112327aad97a61eec70da9507693b36dc4bd3c8f477df489b694e508d30d530902f21b6f52aea0fd9db20f0d1ea63fa82d3be9fc01a67b4c889ae06679cd2333ddd39f3188a9d7a39840d3c19f8e3e29641d772be62b70c409fc5d29a9ee98edb5423e33b122a1be0412c5eb2c475142bc3bfadfc54b7f8aefeae571bed3e8de72fff4845c022d328f0f957cf58348ae96ed1943581e67e91593532a52e79b9ad54d60869ba85d63ed05ca59ced868630a86588b8cc31717ccadd2472bd43cd1787387a418a96d789ca54dc13f6aef0dcf862c4cecb6099df0d4036bb50a54ec081fb1f4277b1f3e65ab64247ae37d6d90a2901921a20bd4189cb39d212d1ddd7593b6f10253077a5dc855a431a1cb8346b19520541461652f74356447e482d975c460921da6c550f99e4fc7d650bc0248c000687dfc8338727ef896db84178e700bc4fd2e776ab19c70757a47e7e5edc34b7b687c15ada2bbc7a83c9ecda9f5b0a13f91919df14118351a3e2e98ff1e15475c329aa3bc1cc7303457a576c6221ea2005a37784e2435a26e3a5cadadaa99c77e0174b0c0d333c52b31a07c7da22983fcb832b1744275b8ae2fdf0605a1d85aeb66a3631be77e298972d8d4c668ea92b28bfb2d63888bba0b4a6023443e7e98c509c52feeab6f56917acb94d4ae939e1324c0acf88f62cded6e22645f46e0b9716c26bd280b1f0c9d489d4995888a0d74e84f0a23684a856d074999c26546aa7d9977c9279d737665dbc89420ee1278caff689f25f82dcec4f9f1fe3e802c002ba3eca4b107d1e2cf3238fb91f3dfee6ed52580ad1c8c62eb8f863da7f2bd242a7d1551fa8fe00dad51641aaecaec0ea7b4e5b3631439afa6c57844e6761820d6510c8ce992e06d11c85e61d8032c01f6dd7a98393ce1930cf929ae4c2207360a79976e316c0804e9248d104b76af85eac619966eb5ba9a8820f6d73c6e9d7770fe9c03dc32fce63b101285fbfa358b5a3a471861d1712f7cb481db3a24e4938fdb62ce0c583b62235ac634aca2c7bf199935e554b0dc0b9193fb96c01b336abd109650ad60a6fba1127df8130668910ca78c1216a3c6756400f6f09a78f22bd6dc8c8d151579b7a9949e3d200e0e40c180aee847d618b69e8ac6d0ad6d23bb44098e04307d070bcf6651090729f91cfb83e068eef38cb1494cbcc7eb369b723d878bdce2eca8a304d3756db6d350b55137df7c6cb4a802fc142402ca4e9afe85e0803c098c3cf23f48f87e74bb13a9716aa59200452354161b3c74a8a956aa914b5ddc427c1aae02a3880f22eae712486474e9304c6521e9965c4b1c5a7d55165f9e25b999d8dc47dd61b7d7217577289b439c19a20e3092d47254cd7b342e74df63e165449a54099005444a2c2c698e8eae40ce771a859565109139e1adfb7fee984d248a0fd0b9a395818189048278cb2131f106e24ebe1e40c09fc6121c32b7c036051f82a1cfe9b57a9c50d988cdc1e1e35e81169b72cde6183f00d5511a8e89c94692f116fe805283c2d7216941a332b93989d1d5f842c4c34872d8abf042d079bd617baaa4f17fa1bdfa30c7df284488b9185f186f2a57c96cc6022f6cb09a212839b24434c6d26d33d9e1b471442359f61f16c149a9fc4a0eff17bcb9bc3b6b00744da7400255fec57b1b43a2b9cbbfbff82f2a3484f51985a9fd6999ccf14f1edcffc5bf59077e3876837e806376efd6faff8ace1e9dfa1ca3d61ad7c3121c1221fad9dfa3aef91a87d69945977e27796f14fa133f27bd10e31594ab4dcb24f035b5f8a20fc2bfa42fbbd51f4d5ff92b6a0d5d0bca85ad9cec362f7d5ab3554507110d2d0227b23a31b92648f1e1f60003273e23561f58e533b4485d2917c6fad6f471b812ab867feb39c4b71c7f77f0bb6402ae7b4d8a36010a807a6483b4e40671aa5c7dca5dc9b9f696c422ac7da4e7b329c53dfbfa4dbc1207c81e62e3b6f1e2e0685f3a293fc3d6d82637016b42e4903a8aee2cc46588c8a8e80c560cd6877c962c382d7aaa6b5d08e85d750e625756718e475a4c5c5808bbe50e3510058bdc2ce64ab551461de27caa5d64671b4810f4d73be02190c58590be24e4eaf029113b04c614fbef9723c75e7b5d4051dcfa7d0d6d8656fffd4ec11535f5783b0ba4fcc7c6983753b311c4bbb3696a329878895bdac1ab1e555115701e2369ba78cf4f97c30b83aeb815912b644a1adc64e10a24a252f85f35fed1bd441d289836f22b4246f5dcc07015fa2216128924929d9747b846765918c04f234209166367a19fa6d3874508087b06a72c37aa908633e74e2ad22bfb88f7c05ec85091407b409979fdaafca50e1bbe5f4709e0ecd342f686afbd98b4208a4813cbdc576cf4c85c1bd5149884201246bca699732ab25ca5aea9d7a09d39e530f17c4f64fee8fc6ac2e40151c0151baa016e4ff5b7289129bdd187723cd41d0093cef496988501d723e6cae60239635582dfdf8c9852348c3b1b0f77e6b465f9e177cc124c53dd63c1225f7b13e2f3f58f41a3ca4e4ed98e887b04196ccffe16a1fbcdfea977c7e07ecb1468d3ae67600f619a9f2f31aa992bfff258b8e93db74ce88d03d493c871b167fab4785ee34a89d1dafeb6680452a724a63d7daa5eda73aba29f729982460e6382903e6a1343f67f99de158b7bd3723c0a46a2fbbd42bff9345c2634e5fa046956df700ddd8f131ad5dbe51df0eada5e595b0d7645c6162912c958e8accf2a8af5354340b6a55d936388b2e23a155d84e2e5a679e96df460c343bc8f92dfdc3285c00b298aa8052bc0b32811089cfe332d57c4784af6de64a4d7ecf3b50eefa251ab2d3df9be49b95979dda5122bd3743ebf19638e49cb93ca966d102f3000d59675ac539de0d76c535275bf9da8fff02cb258cbaffb6975695dca4b3394614216fd1b0171d1ae42efe5001be9abca039742a44f64d3e651c034d90adb173f7c866a46c27eb3696580fb972c767bbcd3a53a154dcce7c7eb46b8a502baf034a8bce54e227765fc9e20d11fb4de46caa67cb9113875c431ce640169eac4e0b1867f5e9fe31d122aae046bd9bec9d13804e298cbec9fcda8847baa2f3d19dfa9ee4db5c8d55e8b2b6fd7591b180c608124ad74e155efeacd348b5f00f8cb5b76766908d92cd51aacbddd4bd9b0273beafc4c288b1260bcb42ff3d98ff169b7df8dd2fb4e54d4b180b972b76d2df69300e13e730fa18a271077195207eb108a9c70397c2c1f5d7a00a9924d66082f4b89a50c0aec8d01b08fb0bc870f23f506e10a128f7d78ea911479d2ae336a6a2b3e7312364ac9ed1500d33184bf5bc79dbf080b0b4657361b97ab287c6cb1c4af010eace016599690a5d8ff14cd11a3f374fc2c75ceaff282b8ea10a0f63c8cf9412e1a5ef27745abc27637c6b9ca3ad7468ab9e031119d66a0a672c54c243aca7a0dfd3e41d6712efd575e809be5ed3dcced03a2a40ae503ab3d68d63edf4bcbbc4d57725d3b4ac70f3ca9f285fb99135540a55a94394e4a8179d4e1e424889b5af4f1408ae28bce4ee2c31711848ccbb12bd824d865ce9a014fd1b20131f2dc59c1332846bab942f3818778bf113c09da90ab6035069962f8b0fc9e70038fa658f8d7cf8a80dd66447e13c30d4282bbddfbd543d53c31af65ba0af5fde1672fb4f385f8a62c382ba7ad04d16ab7fdb3e6ce4a6073e3492033e70a09741edeb8dbf76b5b8d926b528f20467e4fab7c7a7ba9dbf94a7f1a5dcbf6ceca2ccda9dfdd33dd82be25ad3de8eba5122aea70c358cfb015e93e9fd87c319723eb1ce4295d37d596930fa4529fef841c3f19c61f9bc00cbfd34415b5f79a8e6d02011342733824d53858c38b10ac295de512fb6fb9e3e4b93e4d238c3389d134d6098e98a79a6b2b5a598738953cf5f869b22a1a171b263da7b9a3a6d45dc89fedd1365f14b3fa7b897c423c77d734dbffeb3b44d74f4591e17dadb05b9c955559903780eef3adef7d077b0279227108b05e8e71fee4cfc8a979c81f55cdef2a7af285323e38b1a0dd91011f087ad06592f656fa7385946242b508830210733c3e0c79ce09ac8f086f3b12193208f023913034e088ceb2a6ea1e87f15a32612d6f9898687ba612a2119729c5732621d507280a2fa6f75ba9d814eb64ea252d3f45787366603eef10e000045ea1226e22fa726fca3eec6489cb551edcc7a0807f1fa6e35c8b074e1cd7c6785e09ba29755751960984dddc5bd2ede3e1b3fd07992de3740aa8b301ae5cdd3b8286219b7ae3271b5a1ca71daea0fa59a65c0cb40f2220f173c5122679e8fc3771cdf60daf4b2acab9cad02c676a1fabb858196352960c7f4e06b1b073705d2ec244582c248c234c359459523cd1dc8312fc3255e2ec7c38eac5a181f01af6116d00661b07806acd6eb11d204807ad34641a1f5ec3832055671f10ccb771fd47e7fcecaa5dc124c5dc7e24d4284a43a82b6a6d0fd00752d05078f3a20d1a35adaa30df40a93cb9375e28c7d7e86fb760391d274589330db1cefde5c2b5b26dafbdbfb86b2751552fceac3103cc5ec11aa85a60b6f737fec1975e8bec765afe33aea695287cd97e8972282950ff83cffac33ba57a0a172a5a6c90845bd3ef6d9144b83cf5cd7ac15db9e6e078da6cfe63d91e8942973a86155aaf07385a68feea83804613cd759986ddde6e47e99531f99665aa95a6e5b0e99a7cbf49c32d71aa8e3dc5e6e2c61dbde76863644b698625989dab4615306136959078ffeaeabad1d9571d5e7b670ce6fc7e3d61042a0e3acb0746c0dcc58ff262356b9296a49f1105d5121557c0c56371e995bff91823133b83d0d790e3bf42970a3f25dbd8e00950d6c2889241a429f52b59dc717c89186da6a1d1fc2c335df7283367123a413a760fdf4f02e725bea3fce56d5b382a7a00f5355ff5bdb0225a8635a6337b043989aa1594ec701686869df80175175689fb39adc90fc86064387ceff02581a9f25075b405ae824dd51a2858837fe05dcaa91153ba826f02204b5be925f9cc8209cb8d223b679bbb8e49a89ee12941edbfbba097e916df09172b8a70a8df95eafc85cbf640d133b13e061f5c3836da176c57e71fdace8598a3446bf41437cd2194a835011b0ab273aec048ac43eaddcd33ed06af24cba1fe0142e394c1e16e63d40866a38f53cccf18fdd6656dce3e94f5e90e0fac73238a0db19efe8ab7b531f117417c1e95d6174bc336c7d14c4ead65b07fec45bf962b6f3016e757770063383f9f5f0199b5aa23adb5ac5ef156b5caa91b26ff296fe08a6cc4cccb9fb3be65a316a64cab7edbd91ba01e85fae8cac2c7e7c7b13fc12a38b037946f648f357b7d5eb93eaa91c4c5447a81eb9df9038ba13d6f37e363d6802200f4162ca2c0f91133a89eee9bbe057e181e49aeccf60ad601e9eaa8666912717751a870af2d8f7dc43c537e8bd5ac5b6f9477c8ddac09eae5f1aaa47973946283cd3530806e1255dbc0dae27ec94cc803219668ac92f3d06fff6ffc9bc3890381d5bc30bbe60e57544bbb0fdfc2e5bcc832da0b4498e97e25474259149266db674cb7b83e3332b7bf128a649c468fc15880d2c942bcc43604d1cbcbc0ecd35cea732ae9b77413adf01cfed6ac18a228a76882d42022f95b1b5d8ec4a44d0d3155dd71efb8090132f5b4fd7f79bfb796120a8d6e90e0272af88ed60b4ce405166abf7bd760b3c84a09444e692aefd64ef2393c986409c6e4cc3ec10a45e07502eea3e938d03f8bfa4eca3ee5eabe5df29dbd2e1c6756b6113ba306768acff3082cb9e9591301ea2d19d8f25123f2171aa1c4316b166d5903f72bdf49276f91a558092a70fa790b56a5bd80b8cee26d74f91f570259007d2808dc291d22c17cc2f035f9e4d14570304d316e047ed48950af233342aadf9953550fb983976cb6f93d7de037ae276c7644e3f9b6b917528c02e0f72eb5f0a4beacdf8e26d9deb7816c6cf3de03e5ac436048da28d28fdb87a2abe89fc3b7e255cb4c9d8add6da952fe2a81dcc355b03c0b208b4ef017d15d754d641b3163f450ec94761dc322e5e051f7de4554bbc22e3fb5f07d5395698bb1487fb82f5b8c31b1b137c4a9a4ce61ada1d003d8d24f466570bd2c14b9ce18c84b9ed0be7a8ceefb9f70a190b51a791788633a1c4c2b19436fdedcd94843efb7e18decbb1859a8e58037ec1722881f454f3252717b288d6e9bcdb026a0ac4823499edf866d559d216c00cca508817619b4ba7d20b81354f30ee4bea976ec256d3824042ec716fdd775322c4b6e877222e38d453d5a2b9d7e2868eaa33f8e550b159942f6249f9cadafa218ffbe264ebe34fce20ece10bba87d7a49855635dfaa8d944996fee000b5d9a5f2ff344bd4fcb265ac63bdd37518aff0f0e9187de43252cf34b9b26979d1f8faf19c135f7722e49766a68b417d8b8be62b07e8cde04f79790a0fb1c433e0d0a8019740c9b05fb0020ec50c907689beff3fcf19e7180fd7859ef8e34373995772806250697266493a1566dec08d6bd3fcda4bda1b61934010ce42a8093a8305929a432e791452ae4c2fac90341d8da4aca2cbbcaa2c703ed6a1c6ff756c2ac7bab5af71a53d7aae4afc297ea61a3c723bf95b3d37dc4082e235673269cbb876adfc935225bed578c35b452377fc6c6b89d32e21da25c5628727c42c5a253b17fa3ae00cb60df0da02356fba88c9cfafd5150eb56f0911b67f31c48321136d50cb58788a844f4023c7583cde992c9555ada2a75cf48d4af13c86302aca142db0b9652664704f49fe4e9ce6af0f1bda39b3f335f31eeb86750a71560366cbe9529e854763e68e0c77e6fd410d42af2177b4278069a5e7c5b7da02d10a9eb9319aacf4a65dd72ceacb9794ed56f08f350ed68ed1f4c0249d11ffd0eb79591b83b87a5cb4bf12be2e114c6ae08aa4a6e1bd9ca40867826368df9d64ca73b15e6fd2b54ea7ac358115c66efa0ec732bf5b34c91f508206cd78d6e1a2be0fde77e26477165fb60d133432100b7f75332a64e6ac451bf72fb303997ce9b323809497dc0d82da6f88ef84f4a55f22726412cf5a0269c26d1683cd11ade99b95210366e39430571a27ca2ea6ebc0664959649dc931ac3f1ed3c1e9178a0fc7614cc6d08db8253826b6a40ed6576878cc34f72f1f77d93db9321ca93102052d783cf237b53b7a4d5999928070a333936fe36dc8699226f8750460876f85979945d4361225c15f68e08e482ad57f6359c7bf26e478aa300d4e82d5a00fe33b3972ac18cba5bb1e6f6eccc97f90848951c43d26ec38bf89a602f15b3354fd5b176964d2c8f50f091c3868d15b564edde76232fdbee497a780e5518a4b126f5d8ea45d117e675e95680e109b9c54071894ecaf39fe1b9ba655608295a2bf55b9f35321430734778a6fe77bb29cdf2a4860260d5453","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
