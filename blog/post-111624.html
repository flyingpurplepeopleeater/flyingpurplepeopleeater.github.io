<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            /><br><br>
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23f2ba70a846bfc3cf460598f8ee16f7f3cba73227c209631d032dab33f5f89e45a27a32514c08994d6dd33278104d89356b1feea6e4ba9b5aeee4eb9cfac70f6b3b7335971f14b700dd033fa8d7652e9220b8ec203b2bc0402773c41dba48ef3dddf065a65b8509b0bb4f422575faab736808e9ea26a5956bad463b745b11d93c9e8b380a72ce6ff82ee839592002ddf4dde4ab04623e4c13fb288c2ec95e96c2a7ec91bab0d4192438f2923ff135009adbe53f9f79612ec56b1fae806303edfd362838b3feaa1b6ace0db91c7cdb22c21db8f38b7ef23f54c70011fc67e7cecc0f3df9e836900a8d4df774c2750363cfcb438ae507ca8ab386bea4259dd23962cbb409a41f657da247930ebb6a7a63898afa907b20eda5fdcc73b24c3c137b266bfec7f6ecf389ff75e4c6a323c99fb29486ed601d2c509479a8be41ea2f8c90782dda1fc70077df9bb901f69ff689162df94b42d5422d7ffb8688edb424b61ef8dc64585372d45b1ac6a21c7ea98450d754b4289632087dd48cf6269d1e430d6687eec29866069035f9ea3ddfa135905997239d4fc086715c7e85f57836d42c3c3d049f51e9b8669ad1f78d9398a668c53780494785d13f34674c68fd0fc46316169bec11865730cf04274c10f42da9be94c2fa89f23b40d1d929ab9d8fdfd6ad3b902375ccefc4a3e832ce355991f077dfcce3e432c6d606db7794981da2ba5ee79ec46bb3e116f3d94f916729b3f465a59ccdd17d0f39f7088972b9a466346118baeda60293a7a7ba2ba486ddb9521940273f52ad61a5f9ff4394f2a86cdddcad217df9bbf35a407dd04878cc55d542dd0fff32c24cba5bf3f2fc464395b3b4a265f9487f17b148421de75826781989884eaeb0f83d3719c67ddb5ba30f2c19d385e81d9b08f2e1b3e05c161ea00295fd23193c34ccba02da2b441b166b57a058323ae3f337c4b91c7278540822184bf84f295f9f741c249266b4b30d0da305ae52275ee9f047cac06011e722652e76a02d72e7b19a4663b3059c55b0e268835d31097225eaac166530ce75795869ffab796a9f789b1b8efde21e8716b8c4433c4d30b2de83fcc9384c7f69b2ec685804132273acc83f89d94c4fd65ffd069718606d6824fb7d08341fa0537536c4cc69c5cd371be7f7380926df9e030a43c62b339cfcd1ef1bb03104a7f47c34a1d3b2e3d96ac14464fec02004ba7cdabcbd894065d5fd92fdc242b2f16f7c580e4a1ce3d9613c26b5fb7d98ee8873c28b2291ab840c3d17a7b496665f2b5c427b377031549f190b8d2e30dfc30a3966942b13ff1d21277b3f9f979839c3e1d996f187c6031af49b2fc72447f4f3af1f1d744d2f57f03f6cd5f6340d48178f21c8a828eeeb1cf934400faf3da51e3b2cfb0bdcb91cd2886142dc6e6505f00a5cd81ff9d193a814e5f330d0d6dbbeb271da075eb4440a56605934cd8ad762684aff79ee159c4886216a09e94d5b36e4bf39892a74820ec63cb1fa708922c391b7879712ff1fc06a15236aabf04e989709c17adac3584ed3d44e1a4643144c01e396f0a8c5741f9670fcf264127bf972aa0139128d7b4f9bbfca2e79d41e881436cf9324ac5225208ff108d63bee7eac02209648fff3d2bc5ec359cfaf60ab74636b3875089056c3d0c16737c3e3a6e056cc8b409e57d83ae4518af356a6eb243833d170c20ffe49a451277de39fa16562580f70ffc632bf05885b473cf58571cabc4864024039a63de30d5cf9c2f63226016e7f5a6e83ad4f9f1de07a9a50e1c65731b53e041d89bd9f5917c3b66b47301b55748edc706f7642c159d44db922ea09e4a410a6a770351f7da5e0952f678aeaa0b7f15d638528ad806563f70dd1c2d11e8ccffb3bae5abec07aec61a707bbefbf8fbbe9ecb6c59e93238d90b50c842ba21cdeb95eaf7d969d11c5e261aa4f15ff150456568a99f2c14c0b56236b5a34b2a5c846db40fa8711cf95c1bdfbe3aff00faf62aa42886e2a065ead98d4aa72b375e462e47bb8fdcafc1bf1bb36bd2cca0bb78f1f8fa36c28586283d345af42dbfea7dfd4a0d003e701a0249004a1425af5305e8bc15f93872f4af9d9f4d6e2bf023637516498166cb93d4bfe947dad95f020e5edf1261bdf122696dac41f2686e5d3927a55b5ab3705c7a86c0e9ae8d4addd140785bdb3e34ebcff78f9bfdc12cfd6e25079e5aa93da2c41c61479f24f13ee0eea167046239875d784124ba85d7d4e9f3f15a51ce42ac948b3d81447d08fd44026b93210fe5f2ac90779bdde1c8d02e42f8652dd43c4e3f61165c8ca5aab81f498cc9674d1e77ab07c2b329ac3b23bd8c0385b57648d7e70238ca094503085991bfcb99a340309acd9a1e6bb78376732b3085f93776bfb19301c7a08c5d264beaf7539b467765faafd8ebd074c1065377f6dd421b46c4706238bd31aa4a7b54134f87eef70a4e3fc427a37f628c2033430b5695bddfa9631cab5bfd0510dac92dea85ef38595eb4c575ba6fd442b91f6d90cc38eaa6152fb189281eba4f50dade08bd910bf8f42ad7cb9b4d723dba52dc6916f3efacc7d8066180af8c11a1f26b314ddc1350e49c46a93e007a1c5596dd9297be57f8db3d7c2a9926844636895c33b27f923b5d4ee13db91e8d150f03336f127ac6bb6d21308608bbcfcfd4926094dfacdd5029d40172f3acd53380da32e5f5a3f9b35b17b8be8862ea06511fd92cc14ebfbd8f44885a6973463683e8470fc05a0e99fe314bcece7cb974b000524c58bec6be4cdf0fe991fa2a0a5f04b8137b7a46f16ed2e56fe5cadb04a64c30298b321a5c03c8d19be1a1f3d4a4434cf8d021e5d9850d718f6e508bad6a4b93d28f2e28f15a448b40d6ea688c4d448a5a18d2b33eb11fd2052c1d89328ad28a48b044c0362de433875f08a075b7c0fa6627e7bfb307667acab9fb4c0ac51bd94f20bbc443970f166faca733f762eccd1b64fa13a8b197ac92be6054bcf81c0fe851be33986c038106ac4fbf52dee0163b4b22890d82a962beaecf0f11c9cb43471051329c8783a78ecd3192c5883779e89c195041d34d31bb3fef9df35639850c52e429840812f174128b54ce6082dcbdd50affc5112ad58397287f83292957ae21daf792ea9a17546898c83010164c1e93ee9fafda4c089caf5a52231e5d3b4a3efeb7b32dc59f6c221c24071b453dec2bdf212acdf00ddd3fbb43fd49806dded1f1b7ce1e1cd120612c0a55b964bef2438592bf73a6be000f9df0e52b76829bdb1b97e8eda45adf3c95cc67228ad4fbe3f934a1bb17e35510770efcb4669d42f0f35c439eea502af576c71076f2d01917f9009c878d0910ba6ad0b14c1db73598cb9a10687b4878fc98d11b217f3f006091ab8933137cda35bbc42dbaf537c88f63fb15cdc796753e63d9c1c17d59245863ab0cb09c74c7f0d69a7eeaf4e70087aa361b914f9bc8cc0d38772c7ab5a07242897d7dcfe943221da06ec67e380d79dcd9e183f2af35c05e900287ca05bcc63ed66552a436690840bc1374063f71300ac7e5c2d71f31756543f96cdd4422eff15866d811fa24ad876149fbefd8f20131d4aaf96d5267ea8c1e8eb45f65212bfaa82627d46a6fbb951cd300c2092cdb926808ba49f4c07353ec9ad2aa66681858cfaf4812c360ded0a0cdbee3d8a224b3faf2272812457664d2167ec9c4e2e2fecdd63b7cf5541b46c5c1a0cb343e1ebe8d5a9afd8b72212fec6889c33c671f40e6abb5535cfc10f1f98cc67e334b4e7e4c477f5ca1ed09ec84c005979cdce53a9d2fdc1b2a88904d9dc3e0d320b11ad426c307645f4880bbf54f53274bce14a171ed8b3e6986b6318120267575a198f2e376d740096f166a3db71753f347fef37d80abe95f528d5666ce6790766f0755ece6b73929ead5d034eec5696df09b88747abca3e91b66ab6d6a6421922d821c984ba9cf8df45267ddd4c34c281e4a377451187a830f83b0ee8bf85d2b3b1bcfa1435ce0d30267315051aec0efecccd788bdc422eb1fdd7b9ffa64d893ed362620326cd6152c1501c6ad0aa9f034c4e117a9c05999218fc71c13f4185dea31a6ed2f257157aeadd411dab8fa7b0969e20556f5da9e42b74a9a14ac74103d3cfe69c746c1d92035a5e0cd9f178c049ca3bd9fbe4e86b66d955bdc49af200a4176a07fad64f79c02452b817ab6207740337a1e21d73b95aa13338c852925299bfc22f19c61b8a9484828b4fb8bfc839eed88f9c536173fbe9059638610a1f34c7916a914d1ba2983ff01f71f44b4ae893041266e74250051c858060215821295ca3e6063708c56419278195b6b60064d797683b2476e8167e46bda5f25f255ba0b1712c95cafef75dd063f2dc8659bfb17da622be58b9fff714548aad862def6efc18f0ca9c09c0b99daeaa8cf097e8027606f8f57666ea1d0f1481c9c5e509baad2d4bc9fea705e42b99c49bc5525bf940799f6b1435327c7c3ccc2c3c95e4be78ed81bd242bbc8825b04b32098ac2844aa2d6f5a36bde3fab8af61156bdb4ecb43aa94a0688c857da04aad4474c05addf099a46ec4fe1d421161a253455383bd9d0e0c7582a36c9f1b5be4b8280863e027678f3297d9f7e6a8a39d6c784e6c73b387b5e47884db38158e84e8b629958a29383546fc27bb5856d8d981db9723d015000908776d779454019871aadd6d4792e75969e80c5c779d8cffcbd8f74d40129d3c4c6c6dfa761c0bbd1d9e9a0e0116b41164c4773704a5218af30fdac4dee0556c393d64f395746f3998a6fb35d8be6570fb5a52a271db6d5d47b59f5652966afe73eac49219d7749727e9c2f750c4ca1194acb7385ec12b58641f8752aa3c2eb043b523a5fe7d111d5207bac0c83f2accd601f80f639f259b76c4cdcd4b4413dd35eb99d9c95249756f42e6dac2e693f5d0b32a17cafc2675f65273eee274a3155a9a43e1f925d32117c7d64d3427b82ec5ac972fb69b17adb67660e22b08890de8fa5556c251d0c85b83700ca18374e6253b2ccc7ccf76dfa710454c9073083741c210d885acb5f346292a78c0f70ea0bee054e4a6b5c0eed963da05e5ba8743e72f44334e8cbb4de0dfe123a91ee3675014d4c205bdd5e7f42f5cf8ef03c746ace5c1ad37082e59d87f2d67f786c33d106ba66829899fec51ac5de14b2d57fc703388ffebdaaf62195e6672b68335ef62e7eb97bddb39f5cc65849afc80d9f0c2e54a849813022b1e5a8f85eaf412697afde805529c99a5afdb4d689620b509a6ef8c29231b10d73336a09ff57a98462decaaf3ac9a433419d161e331c8390b0f0d2780b9c1f793018f394e2abb7bc5c4911871249e803b3b4c4306585d3d37ae1c8809653c291dff395f0f2cb2a9443c8581c338ecd75e7c59df047e44775ef12f0f200c9c455033c7969330a344ba98f18eeb7077cadbbc2e44cbab48909595b5b1dd588af5f436e0b3cf523fd29e6fb27efe437e0a36bc94e815ee0edd58722162d04df5bb92d3f0eff0ad03a5cc1ad9f878416dbc4f7335a759971798c2706d847b2d4a2539164a367b29bb542924ba1018e68ed7e1a5cf41d3282da009ddc173223464746b0fbd8498ff6262bf3e8316770aa6a0e3fb4ecbfbe9e8c6c2873e17574bbe85f26bbe88fcb8ef6cd23d6733f84f736bb5a4c0b5a8d48300294bfbdc097fbfe80d1bdf7cb5f6451ec6072d0c4f4951fcde821670ca42029955ce7d902bb89d878bdb87dd1a84807a4a9a83c341598d62e826455e942040e0603715d2f4b29dc5350961d3d4e2d6c2c01025de1e6677156dfb3a8d03c938091fcf8946dbf7d96d161766134a322928a0c2559bf9797420b3ad912d7a107d25255a0275ebcb33f2cb9d1234126ea6e52bf7a74ddf96d61f2b8d253f6b0f9576383a21af1263350f8429eeca2511af58cda7cde695ced63dfac9e19ab9562abc02dee4a6f58bd4fbe4f07c0739155c7adb23b2031c3a047d1ca55a370ec02c496be43c8ca33ea963d9eb7341f0a1b83daff2f7b503f2e824a299058d4b095d4f8b25af35ce4c749384883db434e45fd5fad10276b5a34f1fa72703b888b35fa24e8ef25d4d497ed22b8686b09f415c06ae77d0539d141be590d6cbdcad5ecca82835ba641f698cd21c1c729242b1f0c6a52351ae440e32bf372c58f33c3f07290814978c74021f22fffeac525c23c300f797a6fc0b149064d68a6a5661998afc3dbb078d47e77362155042d342c165485a76dd000a1f3d90bf2135cae5af3f24dbfa5de00c51c2bedda8cb1b66d9774e022c6753fdbf215f8c3f9271850849fa3b2bd490bacc158c820a31cdc27c0eb7d0f782686ec5657b464aa7f1229d06b55e290a7a6389d0928e7a9e3570d1e8b4f92ab9783d74dbfee4bb30f05a63e9900e1b3d2c87a2f19b68d54f2118d7622b2c15e8c0652e66501af57f2cf6ff31b052954c0a320d791b355c9b30ec8c9fcd9bcaff6a46e35a1fde2bdc7a74a9de200b20e473e733baee43d02b68c8baff6dedb0b29e58a6309642ecf9a7a844d4c7b4f1609f188c44952703f3f0376dc281e5e0a46669279b9ddb25e3b71329c0458a285a88544364f9f771f9e66191273bb2123b8e9925450ca30f3beccdf0d7db3d4bbf5f2f98d40d632826bb134c8f3c96fe3ea51ed65f8006ca070c24a6969a433df6ab201f2047203c1c1f888b8cb6979d19392d60c25d1a5185d434ba42dd081fd9020e3629f329e5775e77f9161b6987804b9a33c9365294ad10b9d2e60025f0128690e19795e6be3dc2f912ffc601e402bb1081cbbc449e5ed51dda67ffe61c4fdde2d183ec8c6ab7228206f0d5e0f761f514a52b08397fd27ee1a2a087ea9afaacf2107aba2611bd2a3563fd72cabe6b2553d7d8ed763f444e5ccb3351b57ff6051963cad00ec5a185601524994acaaaea57bcebc065a42de76bb85e5d85606bef8cd82ebaf8787706b9851279fcc893f0b47587be37d1cb3bff0c99db9b871acadbcdb3d0d0cafd59078956a1086fa2c9f971febd3abb6f237af90e9ba1f918c7fc2d4de07c5934acd70a4aa9335edc4ac5f488811e8dc7d241d3257ad3c1b811e61b3a702130c5c663871e416274102dd90a045e5416b7e41a60d80ccd94267a792f53b5b3d6a1f09a479c677c60afeb18b10899ebdb7e5a2cac8f5619b55fc6aa6a00cb72986bd090a0fd4dc0ad64cda0f3a4a49592c05a3c7270e0a1135208b1607912a6b5cd13073da3b00086b91ddaac692591218c60bd43665d815491fbb82e0c091ef204e785f1acaac0a758d0751976986774042f5653c37d0547195922551f00ad0527c25d0a3592f53cb71bfcdd51b3e195d0245d93cfe7fabb42e87a3fb881cd52fbc586c69de855197f7896961acc78f1d8e0d9a8da77ff0b1188db4228123f5caf8c7cc5ae49014c7dccb2abf1467a745996a3717c96584c7713e028fb636cdc1bf2539c037f156c40b603e32dbd2623db1138e334097cd0f533c3a6f5c3250c0b65e5b1c03435a22afaf86b48127e1bbe1988d1540c7eb03ba2c663312019b81f803982b860fa6cfeee9a6f2b8a07fdfa84f688e143ce9a82bdff6d0ed6cf30ca1aa82ed950ff4585979a043354bfd745cd7e42c9c29454d4a71bf391f9fccb2606c492248f958fddbec2ac50f97cba35751c9103972f0e02f9a071167ab8065c22b2ed3846be57c5328a72d38b384eb16b05c29189663b3c4ab6d213f03eb289c8fe2b4626abbf79e62a779fdc9b8ebaf4ee26b41d76e7055753804f9e7bd17e53e434915928f3916d166faa7100c41fc89c3fa1eddf818f8e758735e13b341b8864d86d155507652b4f6644815b31d1b5dcd2dcc0ee89d643c97fe9f007c204bc708b6be33d1c1ef321d512d8f6ae3ed054312f5475a49967fc369f94039a77c01a758c02d07b7fbf74b1d2b879e27abf29a7a97428eaeedb0a0a0687238b8c396998eb6a3f91f8123252021d9ef74d80d239554bb942df013492ada0ef6aa0cbea54a7b3a485ab5e1fcd5b790eea0653e0df88172d8ab8b9ad065201a5ece2660e9e0d437f199f15704b71aef31593c8a50ced2642be83be58ec7da297449e06698bdf34c13f7698beae3d232a284213eb29586821e33292dce6013a74801cd6f0b18e3e589bf466e2bb1c39ef0ccb4abacaa65c2c35ad4b79ded0b22b2bd7fa3bae58514ca2393ff76841f1242e927389ea2915dccd7f90376fbf58d2bb6431f4664573b804c9d8fdff5a02accce9fe1be6fc34cd58236b10112ecf0fc854e6052de9e285a13758fc1bb2169ee2c447ef4d3296e959ec835f8bb179efd44b30754a5426751c94647619bc0521753a6a7c6b3509b393fef76576e421c475eac799f14c265afcc30c0aba83debde7f3a161233e31a307ea8746e99527fdd713935f22078bfe90ef1a60db0f0021ca51cb48d7210ecbf143ccc44003227b5462ee768df46114b70c75f3ab9edde52a2b47a545d321763a4537d0865c7e5fab51e5109bf072e5d0866c2db01ea1896c4a67d893224d0614814d871879a1dc67bcbf0f865380f96b83e453ba885efe4eff86366f8b8d6b9d688d056af0bbef0a1703bae23e5b16ca095e7769169e49a42b5625ea5505b826b50a2dc96395227d1be8686b6ed968dec267c687e125f66687babe995d82e67cd731cb44e96ea2db784166e7862477225f7dddb5bb39391ce8404e1559193f01e0cae7c16623c63bf43007b5217a837d529d55cc3162747d39dddc13e49aee11c09f0266c246fdc69b1128170055613b75b70d5bb1782aa08078a5696a2143b9c9b456818e299d3881433bf3b841ea6a920729a34f50fbc070efec60b89a24348fa6a77450b49ff82d7ea1c1bf798c1231cfb270efebd569686f6af8af1c88f3593ef1e9418ef79cdcf912d23f36a8823d987ecfacd9f572340b03c4604505311fcebbc8b014026ab046cf31b1701a7ecede62977581a51965679f93d547036b02af066fb2b443ae16038947b12aa8a0f9fdf6dd1ff6606f180dfa80d1e76df6e0f4b8136feb083bbd634e4a278ec9e715c25a6ec85850c31c16f1ba72748cad64ad54c00c6c339132d1e5d539f330de374891718157496e9076aa908fb388d5e0b6589a450397932f500d14ca9257fb6960bbaa28342b2a32fb499fff5c0b156fa9099874fc88bc2db28595e624d3ae68a5a9a897310f1bb4dd9c0502b0f0b7297c64c72a2dc45e30b5d2daca8f709942b006dbe2036e5a33c1572244e7fe2a8f538f25cc474319090ad9946ab625c283a7b1ac955ab94ed0f89f30953b351f77a466334f0fb40933aa57371afaacdc95a11373b0248bb4816b7dad000ffb2b679dfb42fe71bea8eb9a487792fe7251d545033d7fe973e91d2f7b4d37bbffafa33613df79c63c411e0671f5b9494d0ffa62ba4e2e251ac9dc868b04943c36195ebbc703fd6a226ba6cd5e2533df4c2863819241b77c8b138c6ff8732278f266f206c541c39491402fbb828c4a7859070c035cd45675bb01203018d229938f25c6d0d2b553e89a117bad23bd65cad53af5377ea076fe47bd66095bc101da80726c1a5673a8be57dfbbf73f2f7d9d1294679ddc229c95489b2ff741150270c8a412df944f3fa78541e6d96559648f8c7b9fbc9f0c637ae8e23f1c3b453d8531cb21c2092276258651a003022bcd478dc93790104531a7bf85b33de6de6c1a9edcc87219db9e5e11cd7e4854b63e9f1ce8d04459eb5bb64fc84e2ba75d58d83cac59aabac1bd2ae4a45a096c2e5a7770eab20f23a49d1b4c73be7f2c345acf649fce0a898cd9b0de6a1703e9bbaa6e03ab68554caf8d4fa8b7c9acada50b286be607514e8ce634eda9a219310dfe455055c8a44908849fd8cde7812b202fc0e6bdf62e3170fa237bd5f989bf6641f910292a7dc9143b3838875df897d9485b81ad256f6eb7559ea03a1e2b0781234ece92afe4a6ce782c55e83b1907fddb551fc4405e94bbfe0604a96c94e858719f7f823be52c1024471a08eaec0c1b8c16547506c6eb04ee12af6d8add562b4aa6a1c5461c6f368b74ea5d5f022913e0da0d1b1445a2845fdb6160324f5c68ba43b69810d870245306048122d9c0323466903d319e3458d70cc224eb781e4ef8a9a26feb82adddeb5f74b95c86c1f76787669af8823615dff6d12df20d0cb0fab814abedcecff380622e328ea09340bd7b8f814a17f8e2bc9850d9d46eb9799c5c0d107fb951e0d119d6bd7a2aa22add57b1841b0a846fb03f43757f7f3c282b0805aa35d7b05909d640be2b950933345358449303ab60e1852f6f49ac9afd7099b92719d768577efe90db64ae9b42d5acee1d0a2513c899b108b0e92e87372febe837eebed785030a8c60ae079dcb32339514181a4f0a58b572330ff6807789658eb8ed07ba5e180eba671a7d67f95f419c163eeda6e4b0a915dc136be119a1e6d154ebbf712fc91ac07e861ff306ad22c2e64e1fdfac0f01104b6c7b67a6860acb07ba0ca9d8a294274c59e17e6d97749c85d550d62af16cb5f69358ac67fdba30f0d5e048b1d86211ee5f969051f223db5a88531d2fc1c153d7c771e4453fb5e6c7fa2f13f9809bab67ec26c8bf46134a30f1642aa5f91665c21102c314f69efbb046d6bdb4a9c9b9e33a6e3f5068a20c925bbf95f01e82d89b8eb88fb07ff0d42e1f53ec9bb797cbd6700640bab20f31627a8416f699e5a97b35d04784e8408723c6700ff198bdd90fc56ae8afd119b77d5c2273df1d380d41aa5c29afe0a0a8759cf5610414e506361e8ceed98744a5ba81380ca4a88ce90082b396528093bd07665718186a6c35b51d4ad56c1414b4c5c91b5121553d9d437ef31b05c95eeb4fc3de542e4cefaf8b0bb411d61cfc73f22827925483ffbc95c9864e9e8921999e2bf6722cede5bc01e10a609b2fa8d7232ac4f902d295f7ae3b129f0daf00c128622f0fb1a4f2b558fe1f5372347d26879e67fce4531fda4fef2a2ed0676ad16ec283353baf526c4e9a22361e89619fc4a5e41522ab925cd806a54624b05673dc53659cf0e61f02d125f1f6a20e5bbde1e8315e20376f14a7d592ecbbe61d008599173f1b32c4011dc166753b85459f31d9453f0cfe2a3d19976b8f081e5013a8856c64eba50c8be931829e0e66c4a821e201b0265089e8a032b2b54f6793b79c0a8f08990c692730dee97a4416602014586b72ed5680ef26358c13754d511e1b183c0591cdfbbf463816ad789ea9e4d368df08312a6bebfc7e38fd645b44cd677f5a9763ff7ceaadb40c33fe473a379f735ca2cea5b8b2aaf21d9a13aa03fa31351f9ddc85a03dd225cc45fb8bbeb3adb9c010b58a8c45d8b044aac0123bee989d4225e87305ad9d7b412eb5cb06bff7036cd13995ee98706389688ae1290826774cfb589f3600a689060c710215fbffa3464cc2875bb2d4bab20283778dd00ad67f726d0f812eaec0ef1dff92d853be750b20262158a6c775345d92481b19e52c45961dd507b4cb9517646a14c2cb75d3a629c4d5a0463baefe089532e814a6b2667f6ed57c1edbd9b25047b5c5d5a7138bfdf61f1978a0148e178e797a7b00cd32837afa634ee319611c461ccab1291b2952f42968fe02970981ac9c1894a3813bf5f88be9a0cc538d9a8b87439f6440ebbab794bd4954c038c36ace87dda510c976295c6176753914c5d4b7395e2caf46e08e7e099d28205640b9294d5e472a279d0e08e226cdb173ee6fe11d5712ef84bbada975eaf641597bb8a22bff07121bd26e40bad1e56dab052327c108b8418b66b282e488249fd2bb3b584c2d472f623d0","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
