<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4258f6a2fc3eb36ede1afa652a9be3e6d34702c670e947f102785563f0238983055e6b9b7e9a07a3a608898b0f92260d1bf081bcc315317c277286cfc2145b3893f5e9eff114cb18fda7bad1ccc17a33a4a8809015705e6fe644f6eaf4a4c20f96e225716fbf8a178e00c4b08e66e84225ce689d47c2424628fbebcc9e197e0bd53b2d1c6e2785f246100a33f86b36aab16e38b7f74d853ec0269958248fc6330fe799039478578f13fad024f7c971d6e90a9789d7f31529c25ae372b5527668eb25df75db9a55cc798a0d0e2ff0eafe6434c1abd8fb1b2ce53626e1cd16efc48fb8814e90a3fccf9b917d820d91bfcf395e76f25737c4f8b8c262ca02da42fbae71989bfe40de723fb35c097afd0b80ad73d2d20ec66578cd0df2576212fd97a6f002aa2d1ea975f967be3f28c954bc71c00eab04952d3141b111e2f28ab28eae3f3516c2845c6ef0cb48ffa78c52ba1d9bf388aee9e3202ea1d9147537353caf79a5d42cba692fd8f50540f4bf2774d0483f5c0a37a340b633f24fd1e57083ded70e6bc1546d3e9ef6c9a70796b3218de14bd6032169727d55d69cecfc0028c42fd70c146893be69dfeb7f4326f81f3068580263d8d7b79f320711d6bbd964eefdf8295e98e892bf08cf2e8157864845696f8455c7a569804a8ec124db72b6ac64c60f98e163804a3be00da228f285fc83d49023b3c9b184fac80968fd879b7a5e3bf26b9746e4afb97ceabcdf7fe442697f78d0851e8235b54f681b6bebcdcb41d3c700ae5e03e70066a834532e82976e81a0f73181ab8027b802cfe7c37bd5304ae65e3c0eabfed5a91616d5d30a54d9804149b6918054a6195b73dfcfbe8df4938c916d8cdd6bf7fd17104fffe39b4bd0a52f9fbde2d88f0666de1405af65f73282fddc40087ac3f57cb246dd5e0cbdc901c2c1f221c5315ab185655a4f08c01f48e4edfb88caac1403aff28af18abd729d073c5f7b2cb7972a64dd0bb0cc159d702fc1ebffd3bee029425f830b39bf010441050dbb3dee8f553bbe315932ba85f38135b696062141d1aa36f77800be3b20fadcb1e0b4d44e6f72e450f5891488f8b84c74931a1ace83ac9ee751adbb191acf30fe7d2e5463b3ca78834e664492e4f4bfba87c25c8183cc62a88830f153545bf9e8629a51238b85f1ce3cddfa826959d3a002ecaf73b6be248b7df5561c55afad4b9dfae6f47a428b092e477edc83368c7bc798935df778a9dfa3fd926593e993a2388ad4dce792127187ec24474960bfd3447cf26eef2adf673d3357563595c191b346ecdd8f499baf234c73ce963931f9f3a795d04bea358bc36c25af891c336ccf9f27e870ce54a59dbe996a99c361a05cb4a1f26cbdcbd951dfca270b2191a60c38b2577b91d1f439d9f0486f1ad9b08138e2e0ed5b776d93a9e4c092e822175b51a1f054ea95b63e7260bafb767bd61f91c53ec3bc6d4be31758a6b8a489afd05741d3640c58fd71dc0eb856f0851f7390e78a40b80b7b2dcbe700b92e6c233cf1f93a9e872e50daa97dd19e5b53276e2fb981f4cee4ca89906222d049f34c6abe5185723a0119a4a09fdd6037dffc5533025b2cd7631804e66bc946a68fd1c03c26f5c93a8ed0b0fc78f8fd6b1f25aba2cb9ac3c6eee5c66b2c1a8522f8cc8ee7ea0b0349a8db90f4725b68661819de3c8ab474299ea22b6db10ebef691e40e7b4e1ec3bda8f182c579ffef503f97168def337616020210a55f3dc14825c87ab6939ec72a95b82b80efbe1513572a530ae0e413ea65cd0e9544670251c7f369223a5f24a9e3791031539eec32f2fe87ecabd7b87a8d1c6ed76940fd730812b6d2d4fdcc1f62e7d553406f2520589cb595d04842aecd0054bd4f94bcf2f297397c6e1ab7d981c4e5dcc34b0032bdfa0b103e0f4a7967cb3d8fdbe12eb602f7d9063bff3b590797cd3925e42d4483fe619192d705052ede2921acd0c4c2141bf2e3a0ddcf08f6323e02ebc8cb7e1195cffb63ed4388d8bbf6872891967ed679e57764c31258cb5455eda413757440b69c34de2a7b64ec89d7bb0a293e02b9c02f4aecbb5a3879d5327c31dd433c1fffb4d67eff842e720c035a8485764cff8f371216be69d6b8f46691e91062e95f2a6fd2ea6d853598724548c112bee59ed0bbc5635edb06336c9d74bd051a280cb5e13a7533689679ea80fed7a242066d5d747a69202edc28f806ae59fa86d7ffa2bc0465759e6775b3fec55c8f299e7f758c93dd606a5077829879d5f836eb9e7e2ca24b486eac4ed1d18b1c9c7b7b955fefec578a42ab2c7180fce88ff54115f2f99d4d4a578e7249cc347894d26ec7d8e50b4b77bce3bee78295e49b8ff7797e6d947b0a9858d35702d10accfb6408139787193f15f478bb1cb90c76dbafe334be9e2722f66b598901ee2275c8fe35faf6f15d77f04c2a899c515320ba349667a53bd322a38aae052782dba909d0d780397fb012532d4d8304bd308b8da0328c954267c1ce0f4f8ffad8f75b9004bb73a4bcb621fd9491a4c77f73b02a2e6b7af7a3d53e9a29ac49c6e7d5623cf0206a176b7d38dcfa9b32df9692b97d3f878313d2b00baebd6ad10d911878103fa2490dce71290a493d0c9cc315160c54c7459f09bdc62127fdd366b46db751540a7c1496e065df27aeccd2798b3bc4926d25219957e124c0290597bbb6015c3fc2a375b6f91aaa8391da74c4a967d875c99a38cc00b14f83083ed021f1e0079d736ef09a13f26f50248d24ec754eb433d2cdff127009f5e2f836376d6fcf825adde7fbfa784bdb400315e4591d98991fa4d8c00a68648d1c84b6ba2d715493ff0befb0f668c524beb5dbd22f21de775d475ac44e80bf71a772957e176bbff4e4282c7e99bb26f846d928fd477c6a0b38a736c99b8a83c84a71fadc8ea359cbe38f22f3e49798f67ffbda6ac554df9139aee4fab64522dcfbeaecc0096b227802611245289125a2579d4c2b0d29f1133a06815bc333965ca3722c5800b37a9fefb5c0f4cbc7c1a80c9ef8e7c33e1973a459a4a7fc23d2cedb68103ebf6406575028896a06a665650b44e9ed915e1369553f02b2ab3b0b8b290e6ecacbd9de720060ccc588c23134318b1acca477c1a3c692a56a758744a3d9df17106a3447ec59357f9e4171b806faa05cae57fa9e686fcdb517836ea06f3467ecb59c307abf03334fdf57013b08cdf61a5143204e6ce2aa2ea1ace95e0b676a0955f4d63964fb102bcd32fe7da141af58a8be480f3685dbe26c3ca2c2ec2359d74cd17d8a8b47f0debb4ca81e809e91c4bf663640db244341ad7cf9f6e21e6f8db6ea1eb51df6ee3d8ed67915009d8ebfdf64116b0f77b4569b3b8c8ef873ea688149e266c807a96f040c0bc819f944d037856a169ea434d38ffe8ad516b0066e693d49b9f1b476acf6ff8a996baadbf40fc2da36168af80025adb5aae6c3dde8f36e055ee3bc54971de21c53eee74993af4d8364b479b57aae040cec7a3d8b324a8bdfbb8bc199a890a24232eeddf16a5d3cf15b46408a10be35e46ee2bbc89b4cb819a107a38e2104f64be16e382b63c9832915b3af1132495c0b72f1e191d4dc10422c38f7fae40de98a596899256dbdc7fa03b13a7ca736c7d2d5fc8db1cba373ec1baca4859e109dce0c97da964a5f9ae2d926e25472df738471440bdfdf0704c2f1a5c7ae3d4f5f52423e961ced6f69df25609d61935a32867b395afbf61f90f12cb84a70a220921cc98a1eb6a7112a5e253fbd9d1890f03c8f7a311a89aff4d8e0fbf2ab4771910d38042ad143914f45199941acb970fe114682e71a8954802ec855609450c7232ebdd2944ecfd51a55695165db4b6195b957a01fe4e0c4df12228650ba6c4fd855e6bb6cf2263530affbd8eb50294e9b81b24bed175c754977b4a07548810ff473ea34d9afc87110f9eb416addf1ead0d770b4472ca94ef28fe5cf851e86a167bc6417e5b63a8333adc2d41ae0000d80571b4c499031a16159302ef6d35dcc1cc1a27f8af56d74fcac01652a2a9fea675ee29209fe212f97058705dc55e6daa83f16e94c1fca7a119efde0434a91ce05dac921093617cae8a5c13ee51cb655b7aa5fdc7b9cc5feda1192e599fe8927aa347fccd74d845e7b3f8708cd25e7f777aeedc7daf5a33c2103ba87d8a90823708e0ac33415da3e70468959b7ea076c7fe1a191e85348c7ede25478b7f127ddfde9b9dc8feabb5c083bd3dcc0f75c2ffbd3c7154d0c62260e188ab29f11ca952a339bc0922557b24626254c22451c4d93094aa5609d5dcc281c93ccb5b2da5d90a869f059c60048d47183705643d9c77c27ba0e9f341996e7f4713489499cf12be26f0af6d2b996bc334bdb061127871d9e8638901e6c9196bac1c13da093495266b6b217483b86c2d54a41222e92e9f6902f73cf8106e3950419c566f4aa2f2c303e5536a4cb230d7fd4c9b7f1957077d705f614c3f42c592d37c83f5eb9685d56c74800f8bb11fd580aa10d5afe4670e999436888261aab1959ede8cc9db99466775f76ed33c0ea721acc90f28a3646233dbc277b641d8bf6a19cb2d100cf32aef662defbec5e7a17b476b0a18938b323cd3830f4d311c7ad06ddc43712b2b5ce9945c2819074630be603b9db937d502a6dc737cd5d0d4c4f570febc67cd3787cb788a2f90be70de6d84694e9172c52be254d083fcbaa7003585977da22509d10bfca33faaffc7bacae6af61af6ab1bee8aadd886ede130a0e9672313da78b2816180b81b0cc82db88ac869088e191017bb14c38bd30630d6f73c644bc79bbc40d98176c2efbc666a95bf4bf3b4556530ab98877e4160b87c84725df594bb215657d3b790e7fc5ab55adb489464c246b15a35eab23cfded2b2ba378d98aeb687fc49adab8633a2000bd8b9b75361dd0f1018fb4a53c3d59e06c112e0c21dda4bfd423ca166747613163cecc84920c3dfb9be41d26659d5e81226d242deca09719a05d20bdba0c4cad81127ee7cbfff98d1f5da5f9cdc35155f17d6e2304b4028c4edc7aa92ee4d60e3b3674180cf2c31b5905242a3a72a2135a3f2631a5342139fbcfd05aadb4b65b5c992516b032ae5409fd0f6ec066a4d6746336b4f6e4c2ae3def8964c02c0eb9c11245cbbe8573be5e3862a716be921bc56619d78d4d6fe1a0009e601a2fd245b320a7f657cbdb21596ba6e99982cbbe445bf74ac3ac422b41261201566a1aad57acece44f3f5a69be01be4c6caddf8a47430e59c383c9b6bc4a78fa7ba93289de97b56a68da8a91244581618325a9d183975d5c4cb8fffe1416d70321f835f413a8affc4d4b87acae96c82c5170029e865b8e3902bc38eea51f460d40620ffc8aa26f7e38b4dcbed4ebd7ea457994455bb776690b8e01dafa1933d4896900a92f1a4073eddfc6aa825f96f883920c379f6707b64a79a1289b34a4fc79f50333d8b88e60d106144deeb846bfd5452f98f4dc2936c99030b1319a5335208f1bdb18eac6b15fb23d7a9acefa9bf8902812ee85b7a90666cc987ef7402eed4df6e2001c76efb55cba848093df3d36f3b0b0b2da478a6ecd0663067c3e54aff2e29200d45134212b899e75b385bd2585db78098abb005cb01db637902cf9a5554a912ae59faa930abfc894a2a80667dd50ff94fc4a77f655e6ab78bcefc1522816cde6cbe474f614f1461c724fe2cbf2d4779e86f5b2b9b4d4562f6e12729084b7bb6fe1001d56fdd653b610c73ea519f0203ada3de76d60c361879c66841a6b3de621f9b954ac023175b8b0e900834321fa522ebc54007dcd8b766577295e2ffb07624fb6942688fa888ad913bd87c156b407d81d99d61321688366fe2476116a8d5883acf592c2b735d0f54251f7e6f41f39455c09ef61308981a584ca7de2abf24dc86c044bda466652235d8b9e4cb5c5587db2eee2b4ead02d466f8c389a7d9c4243acc1b23dd557f3ef960e492363eb9e537fd2dd9ca88dc07aef48081fc6895372be6a2aba44387123fa98ce40b002a8a141b96b426c96f4f2e509d44dc58cbdf19ba7a182799a187dbf21671b45bc38bbb1b5626940b7c2df60a882671259c8d5741c9a77de3e52ac1b7402e2fb4bfc7099842fe8b77fb80cf1a99a692a947a9b412104c78480126b31965a56d7c6ecfcfb35a6df9bef2e1cc0622b942a29b968fb089651d36ff68d0e3eff734ab4721aba767ff56a7f36d60ff1b1784e4cecfb9537f992ca6d0e09a7c2527c1ee460634e6a46b3b8b63be8b1c612c9051430df603894aab5a1aec2c4dac65b915c0da371c937c011a88747cf26e6de81e735f3c2dd94500fd5e3543d5435735e57cb62ee86862507855adb50fe496ca41276e3b22746ce48e97ea39d0155570bbd805a621b05361db0ea6f6710f4835a2524140625bc860f46adabaf5b81934fd3513d30bccf456b5983c20ba5d516c6977b2c4a1bb7592b69d62ca6f18916c947b8cbdd3cada96e00efbfbba6a4f8b27d5d29c04d15f08ea8e532993368a8d792c5f115720517b6e0f83ca1988a4d103c65f769bd3443149f0c9e22449297abdc719bf65251ca51fbeaa6a2bbebf5c2fe91fbb23d73785d3345d9c2d11d7af1203999d5fc019403c0af41cc11a6a923c728f2d638a311b5f6b9718251fc56d70c58148d003eaf8a05b7b10ff0159fd418412b840210426222880cfc949164991c71c2e1611023bd3b0031c10c3d4ab235ace2e3a0cda03ec8df46c701f4fc048d9720d36c659a0558b8f5b958c5c1f0ebf762d7204a586046262b68096910467b587d993a1c4369d5bde77f33d4182baaba50a10d39d53bec3a31906ff35f3dd096bdff8ec97bf963ecbcfdb35d339396ce935f036006b9b833428aee8e25daa226a0ea0654dd3b02d46f45e8a06d030c8ca892af63ec08ea547f74be80355be04da97c9e2dc20cf5184dce2d8b2df46ab08c81a52218ce3dde3c748b7f9db036937482a71a7a894fe935469cc1e842d5ca4f7e8a0fc328e862941f04631145414e32c81b6bbfdbbe993dfd72e6fecb757bde0799efaa2f2e985ebabb8f2ad4cf43d4667c7ff5fd1c5256b5057348599d71e01eadb2c6c37042503593f00d408547a909885262fb66afa8ad127720cf1de6d348cfa95578a4f36af9e124d52e098928716d489070d5e71fb4f5231847c06e233285e5689d571d0bbf3f2dc38e07a3d2e4ed518941380844d10986cf5068c6660cdf2818caf45e90af3dd62e0845c0f2a44a9b5b7eab349fc060041507fafb56a02e0ef33baab595ebde5f4df8c0d260df1c114040f00c8bf17b4256e729218abdb63ffc109da1c17b616635ca427215418b672c9b4d4dff6ef367ef5c84e6cbfb4121f1e0916b559b404a666a2f0f6c8f203e4e69665ef9ba3dd646d1649d1848b9e289703effc2831c1d629b6999af934edbb98e34ac058d258a3639d5bb5208d15d0912d5127b7976be57d30bbe8fe6c6eadfb93061748dd665af672acfee4b3433c0ddef06fb6ad27412019308779005734c016c1a0e230bfa7c4f82f95c973f2193977fd4b80cf51b611d282340c4970690b358882caf3be3857b8c8df43c7545d7e371fbe3dd46203ea1af5e214db2476c765560298bacacaf7698fa2050371b9ebcb4fa5160f6b8f90b2c705adbb46a7d254016325be1f0631122bf80e99cc0076d272ce0f7444b332d9917a0b97f872e324855faad95f29dc9cb27cba6f8cd055bce16023e2672ca33123850be6bdd2a683c602593debc5db81c5aebabea15302a2169dae3ef467c93721fd6145fb347037b35020307b963055cf285d998fd914edb6993a2619c913db7e3ff0756de55842493c1d37e28737f2959d6654ba1f64a3658fa67befd9dee3a88cc0c145919110aa07373641e1d21258eedbdee29bfa1a88833fede1836f9873ec553e4cb2aec6e530d07f181ed30a9f9fc4a481359ad17194868934011527066c7f359c96b504fc815918d32aa3433a71a28329bb6b9163e0438e67d68cc2f6260b9f0e8dd65e78382667a37355b5c384c891a6893c0d882f7876189da72eb53ba92e2832cf316140daf597f0a72d7d30ba4c28e193b4829afda2b5e4d25a46ace240ffae29f6004f92dfbd1639ba9060096cef1da30787acbc37ea5812528f3be18aac8add02d1b034a84708f91f98f4b98b1b8880de3fe124a6e76e84328ac451d863f2a8978de801697bd27cbd668793a40d5aa8f3982c6c76bc6e69e11b225bbbec8e2329f385f090e86c63c54429c9a422ce46106191a2b7b4f40b96bcb71953225f0ac30ad764cb0c06335c869d594b579ccdb1b443ac068ba8a67e3e38e9d11376fca8ebc568e6f023e1e70ad3c15df7d273706f8617388d2a5dfe1457a7f7eab7af338961fb7ade5a43915c2501d3ff8fb20c5cc72e5cf8abc4b9f83134d1f57c25aaadd59beb96db9f4159136afd71c51bcad82c48312a82e194fbd418aca09445d53506541ffb9ed800e68cc1b655296f5c058831332074f412f718bc6be2f23713138a5ed289abb1a63854dd7e193bee1028b9ff7fdc9fb467fb32f70cc4ef8aaf6b16d648d34f47517edba7d9c56eca6ad9c22c6a39e7cda7ecbba889e7f7d5c5b426de02935d971778d10c3e574e3461b1fec4b3c8315728b6bc52e84df3217f612eb98ff09f7b2b0b6b7ef056d0d87dbbd477719bccf6d8a4e96db8b13aad10311a90b53dd7fbf4842922f3f5ba219a836184794eee707ddea6420a3f25cc865475a6260209faee4fc09f43deb2abd6c8c7263b895d10e10e4cdb424207002938f06ddc6d39504a36bc8f4955834d6685d55cf92c146271be99406290f64cac123e6d69c3984b045ac854e9119d24f4e5dd0bd0984b13ae015546e2a13518d2090fdcd7904fef3a36959c217cf7e34debb638ede74999e54b7bdef5c6f890ca4910a3ae5ed1ca4df8bed328105dd9924c5d54a23923e8df124fc10f219a020fd7eef65fd041f777eacaf044729d4ad298350874ecf0801e6049d23c187be0f02fcc2b93fcfbe05c210ff9a30ecbac23d41c627b313a6e06752605871e58625b724168323e3baef4d133b634f641a79952a661c41ddbb370ae87efb24154d40fd793f012153b3cff1c12da24fdebec5d075d57593a839cae029a515d45dbb2f90eb1f785a6a0f510e646e284499706b2eb090a56a2aaf8703b13b6665469a8a0f46c6e41e60b5e2761cdd9b7b7fc6e45c5333f43170ffa3897d0085b0fd4d755497523c85f3ee46023c78d5ef52cefd4d0fe182421c6a75dc9489377622f280fda363fc08590a3cf9e0e218cac942d65d3b9b4327162ad09c83c6eed048d6508336ae00045ebbd5d992bfdfe96fa6da01cbc7a895a9978db9b5439d9e2212d01d052e8a1ed01ea1b3e3101499e636e8c069dcd4b8b150063233fc478cced37436830f64778aabb7556812b0f8e6d613d98053958f7593b48d5278179c5d7f613d6ef76f6733ae4319025080f82b238259eb920f85a7fb700e76a8967db53275a56297fa4bd8ca7a54f8017414b48447939f775d7755e8ea4955cff8d69f83cd1cb0b067d009237383b5e8b492142cd2cb0e0567c7da2acb1c0ec31a2e4cd927ff63fe1c2dd259355c9c09e6bf8de08067032a63f85c4aef61aac0de62937a2a96204027741684705786d60431dfddf89ef695d9387be8d430f182beedf0edb91eedb64508663dfa691b5e54fe2c0b049e2a421cd852aac6f4a71c52799ad2731274a5785e5c86999295dd57b8a59bc786255c24bccf5cc95997bedd7655077c72479c91ecde14f708bbfeb407c40484280e6b5e9bcdb562813d0320434935bd4b4f6c89ada8711b20424049ba6119abcc2da632ba99d891bb4edc22de409e9336c467c96c487b87b2fac1b0ef2efcb97d34daf79087826fe0e723300a8aefe31860add8392297be25a0668134489cd94bf1c0c0bee48afb4bba81c69f5f3ec610fae88fe46e02d91a8a12d4d134a67d5ad5f991025363d51386e0b05dc612671b6bcc5a745e9c94f76bf7f03497aae6f1f5ee7b8a454ac111490e691885179ae62c22784e523cc8c122754bf7b2750484b7d68f244f744f7268144243ba7cf3418018fa87e356211c950c8d2f891d67a8ebd89f95fc0027261b844f266578115d0cf492efbc32feb2e131d9be0a4a4d9fb4069091ac77720963b723c6f92c5d791d662c826cf4f240dc31bbe56e449036c3fad2044528057acbadb05963ed9d4d0ece9b0c65eb9efa0fd09cffa06211fbd553c237396ce468ae27c21b99b15f51703804acaf37256e9fa975c00bba2b738434a35ef381b5662fac65b4961ada03f06ec06865772d3a6817240f9d3c19801a1e5a78eabc2a05e9e942aa5f3ca79b037a22756197b18a135d18d0cfbbc16458c7bc0549ab37f8d83f17aa65564852fd9d5cd877d269342931cfc45e42e95ea1d2daa0948e91f8be663cf4f5d7aed161a5e86da84986da309990ee0544de19baf8f19e04b85f5aceb61d4c9e9734b0ff250a92794b91e7c4da611e7e78c4f9b974211bf77f525648107532ed0601354934ff3b168b1542aae3fed9d299db4677375158bb771795252da1830426bf8f326b03c55f0c11a1a95eb7d17b87b866b0ba1562dac45dd3e9b6f91ad7f8235d19c39e7f8d1c2684a1693db2c8c81fcc6783d495c25b7e6067bee056f24b293ee36aef484e5c67dd2a09bdb42f75153f8124bd26b5f0d522ed26ad3eaa1cba8035d6632218b7d79dfb00a193648207baad82671b54dc48d135aed30f752747df80725ab7c8fb4decbb5f017ba9e60f1ab8940764920dc5e844fd8f007988f3c3c5812d6578622ba837c1f4178cda5c1019803844f6111457a4eafa4dcdd71601695397088278f9111da0cabb06a85e498280422d94aa5312f9148b3ed038221ff274b64041c038dcbc0f9cc82a71989d357681a3e6459ff14ab65a178c47e36113456ee3b4a5c23f16127cf5ce27624333d00af57751dcf04a3a3aa2da75f5db071298f18b12ed2944677d8835fa26e7b60046393d96930b3ecf3386e495d4e856dc2722df881b935da134c4e9331376a303cad29c4199ab3ee4597d077ab8b1833eadbe32ec58de8f16710215b630b851462a890f24f608a5ab53d1b836e295e239da4298c50de05df09595725a677d02884405e044f865269f513f927ae05dbb2053710df84d83a97f2e31a05d7bf40b0ccb0c2e07721f3d5b53069cabaed004c78e346e9adfa0711e796aa604f74a245e3d22fae9f9f49e5c0e5e7ca92f606868dd3f69e43f795a4f889fba2147fc11ec5a46f85283ff19f6ece0abf3fdb3e436864732e8d4f01e750ba150faf995481ab0d8af9c35ab2607cd3514b8dd7cb58c9cf40cfce114991c63b40cf06b13b26ab00246b1d24549555a3906bff96cd00dcb14fb5f654385e5486ce9c281138d008dfeb641756b7f0563f5277c7391ac329368e5816d08fb0c53a1be8c0c9c958f7b987b109e141b8ea0321afeb11e7148041f976defd4ad121b923499a33274df31250eb6518d16ae5b2c375419473dedc4aaa0700944c51313ac35dcea568f5ee7c138866e4d8e6f44fb05e8a09348a4445ec440222812fa0a3094fc3febec67a2650b0820e62aa6b8c3af307d8f175823f43f5d80c3574f8d5f649f9ea9eee0352a335fdea063e78e2f5fdd53777f611011d4551d9f865277fef511003db1ba0695fe58385f5f8e7dd29da343266cc75ba51a2bceae9e783ee460621ec7305f86c82671037717a7089c10b437e7cc99ff9d1dd5b4adb7963e716fe1666538fd813e9ef193119dd98f0a2075d6a9fd8b324f9a4a0ea9b027ee970dfde074bac0ad13fb609afc73a7c640b9e7b8a7dfd478c5bb1e8778de72372f8303e1ece326dc728c78bcf9b62d0c8961ae3bdd307aeb03fb811017025898289075ee0bb4e2ab4b74624db46f0bd702731f82ca57e83bb89e5b7d0a8e390deb838b295921ddaa8a87d72f270bbb8e9c52a361323428f1015389ca78eadde365a2cb7bf9a09aad9ad7d6fcfbc88ffbd36733790704883beca37e503740aee07528ac31a2a11bd97923d0b344b5e6e02e23e0ea64a83be6da510ed196b9285c9ff85ed72fe2442bd655bf791545f03cc1813bba9b4eaa78395ff7775d84d0490aa91b6570a7f892d50c86f99babb27a1414c33262950a2e9ea1b385973c1558e194d3f192cc7bc033447408642671154c9cef93406d01b2a230a08a74da8ca0ea200f81520548480e0ed3a3f0eeb9487504b89772e1303efbadf39525fb8ac1f11fc8b7033ddfb2fcc2ca8612996df2e265123ef4c34ad142524277d683c241a02e9bb50aa5ea0ac0b09143909d0cce9bcbc240760a737d7cfde755b212400819698a49cfe0f69134d54b6feedc0ac0ffbf644f1e501f54f473260947b3839a6e1040687792092400246169a7a477ce97f16f98835f9df9d22ebbd69e9cc9a40d5ba796b9cec383715b07","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
