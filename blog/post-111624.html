<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c1e48b154fb88e50e8d7eaa1745726326d9d5092f04d87f2ecd4945a61a4e38ed112a379cbf5a39e00e372a8eae94698f977c6c21d3efaf4d48cf902cf7ca723a6512397c817ecfe794081d1236bdaa08380c2ee6c2f64e45c3f27f868728c3e4817de6820868d07513d55b31bb6cf740590e2f814b683129a102ce1014c2f2b002616730cfab9d1b5d07e333a6c67eb90e368cafbb4f5bbddbf7a7361682cf44ce1c534542f7ffc432f48365af4dad708cc215a1fdebe5fa7e8a0e48d96a4b086438ac3ef1f933fd2235af03cbaf61f834edfcec5c44ec87eb31aa571d8a084331a4792945bbb0446fc10610121f7bc4ed2e9afa9e996ddbb48929d276d3c962f51e975aaee0d910ea37539016efb923949de72bfb3a376947e7aa4bfea345038f3b7b02e67a167a1b1df8837431b3eedc41e2ae004b8373abea3b57ef27fdff3e520051eb26d0c2f4513c56eddc820ef0b19b2b6e5ad8e55ddd82d5fe74891d32a73297f7fef45e5cac01dbad71f77fe18cd76583aba90c33b10731fdb4269ff5760e5789be79c5764db676d9f1680b4597e097414dd325363a4f9b24e9fa69948e2147422bceb78b4b868f255daba7e4353ba1143d7c4ac8bf929141378dfd265ec09f6c5ea52c6c16fab039c24d1f99baa48d747ff7287b22e66a2cf096d3c090527369842db665e0e4a489c64f3c7b9b24100f099b3661cd4ab1be81de2f0ceed621d3902fc461b98845cde290403348f3cc360aef0dc19547bdaf259396d48e8c47e411ae6b4d3d28f080845d154c624f08b04dffa033deef9103cf581c8cbb501b9c78330ee7931e43d7877b54f4f675bfaf37dcb2a85e01ed75c7dd963ff7a70d59463cbe07c36e92ac2352edf077fe39159248be70500e95ae611de002983e9eab23df14bb3dc0387ce6da4f40b7645b0f3471df84406625aee4053414302d5a39feb8e0fd361f2ea4004b58efc9a5a6399e3c2f138a6c4b15eecd972dad89211b4732ca9a55374d42cb91354ae97101d858ddb488c454e3dc4b39fedce524dab8420e12d59de759582c45b24535e789b994caf6ed6f96618798e18c6375c8c9a4d701295cecc2d4b18ccbaa68a199a49cea0be06a5c05ed9bedfcabddfd4089dd525781ef0ddfdc94877c37f79c020536fa055805a86c7b144760396852c10da4f0e5cf07ea725f0b16dd3082e49e7d8052df7bcebcb1421683fcf28ded8dcf1b734bce5ee5538ebbab4a432d4e7a02ebd6b16deb60dadcc5d12fb624f256b9637d135b3725e74dc33398d8e2fe2e58e52e27618b41235bce72cf51a2d8191c2a3850018516fcff8af2fe0cd57c8396f887381f412143f1c35991a957bc54663735e517602b148afa96874730d25a276229ea92e1f6425efdd8a92f192ed9bd420fdbb0f2dea2f1b4a31eefa7fe9e597207f33f1a1cf4fe865b3bbe45ea09502a98e2249c8737ebad7fdcf69b0e52a2073b01ef5c7761fdc4083c3966cbe8f8c3009f0e26391e507ee8d160d9b8f0c7b178753e0d09a3b559b5714b22982862446fa13aa41ecc2b773e8eed2b0b5eebcdefcfd3263e91d93f07ed567d8127e045b98de5cee02bfbddb261c4b5b9a8d13857fda245142436c44a29a5fdc760c8a16ea319846e1be5d1de28f108fef8f1835db438fd4fab8a2a9ad944d3b7a7cff1557c06f0e8c2a3a48dfb4dbb8381074d602f43b78ee4af45e7cb57aab5800a5de8b8134de18c3529edfbf6442c64c2d54a279f5e1fb58f1eb206f8d1e4c1d113b8798f569764d9e76c4ff6e092bf88b28f0760db755c9f813993c0ff22454551bb15e45c5ad843387a44f7d6d29d038ac9eda2ad88449f7f76ad22f074306eadaf9724624e8759598137d2d778e8d8043be3412c11bb143781b06b78ac23fccf747b9f324ee59958c97f5b8aedbcf30e67f3c0a5a81251ceb64a24e3d6523a2c90f837f8118975debdf7a8878cb036664ce94e610917ea13e3413b94877496d3cc6c34133ba8ac794f704681657414675b7460feeac82bb6d9bafe7d884299f6fc4f27aec785e7bdd87592f8a94322dc173a33e70f7798d9ee871be7e762220212f3ef94f1d475f89cabaa1b175e912380fe785b4518365a5a502b0dc194b274eadab26560fe9026eaa46db4a0a5a3561737af8ac537ffa9678c58d5db4dd867dcac1298ae040c7df08053da961debc3ab0116dc9b7b7e2db8fa73dae143f9fb23b4ed209f4c2e299d61fff16910c18335920c1038871dfefc6b4fe1983cad22f45244462ef69d6aa65b9666d4e258368894e34ce1d1c31a2791c893968e17d2e50a3eef299295d3ca520652df7b34bb4309b7825edbc699d2b46c5dd427772322a49f43447796c1ba18946462e4f24886119b67451eb3ecc6af487f59c9a86668f93eaecb623d0f44374c4d207031d16ed17cdb549a7b883d0f7bc36fbe37c403d15ce4178099d6054f69f89096b9666dbf6a5a6160e5c060c98753a37248fa0c311cfb84a59eb43c5dfb660b43aafbc321d2cc7b472cb196bf6965757b24607277420bfa5ab9bd7978a139285cb03aa9bcdd17672e4e9bbbeb61c58d51a9d534449e276aa525b276c86cdbbe9784a1127db10f78608eb80f13de30f32ba65ebb549f0b9153989ef3b3458810afd61aeabebed7b31d544fc24dc1d9a461ab7c3d8a1f549f290d08972c666ef2ce80d6f43f26d24b87c3bc36f81f555af9fae08eea5b3624fa0b8df3e475b41beef5ee3f8c98e77895cbd4c50148a26a5b029f491d1ca1bfd3355b6ad12a10550e14ab0bf7b1bf7a210b47df91e0e854ffb8dfc489c5fd8bfc1c882f9bead91317ec3dad9d225b99fd620c9b0df1addba26e14957832f12e99ef443fd4d3acc231196e9ed0fe22fe8f682b9d2720ddfdb039c4246515c8e7fa68819e818b356027a0bcc7730a221f9703d5b282b7a712e07ce66e9494a64c61a023932680ea069ecc104ef3127cf415eb336f0134506ad123dc29a39ee6421d3bb939976a9f313db33d3177e64465e77e2b22db34aff148d824345e7fe0009485d45f79382622c03d6f0379e7ee6253eeb490ae56057ce43e5d9a7f8b4d2bd4717196c3294c63849fb1b4388126df65d8b3869507b69c9e80e37199a74ba2e7f240e7d3bb817463fe98ac90f14727d24e82329bfb3679bb3119e98ff0fe1377a49f01aef3aca66551a618c0d7b07dceff2e58e4daec15a305487a0ed652f0897164d6a4da98400cc97327af4ec7f4ce0c7b569a4b3f41f8bcf2e1977a08023e3e120d023bbfb7b40d103eb34c709d89bf4f13f25688f59cea05c7def1581a4a0ab983ba4ea910f110fc1f35a2ec1a78737c2fd08d13312ce5667e3c48f5fce5986787915e33d28c6700813191e2c48c75f6544100770a19c7ba1e6b9fa31449c923cc2b62e669d5cac30fe2ed13f3de4723a827801e773d2825189dcf922f1466efc85997ceabaf2561a47c5c8ae659c7ca3fdf3d0166f86aa2b530e3b6c10c3de89fc6b95241426bfc52f744242ac8aa2a4a97f29157d4d8953aff766b3872f2671af172dacc310c4b1cdc38a8125ff06c4e7d07ac8e537305eaacfb92761f41555e1886211162fa0717cddfe43d6e632ddc87637467e20455e130e452a4158aa3114fe894b3caa53076f33560b95c641101aedc159b0bf1ca2491ac79b8c0fcdd9007e98c9f12e875dffbcdf3a8fa00942bb87b0cf43337d526e8ee45d0fed9d0c87ec5eb8bd34a4a56b26c83737a998958852a9e84ed5ab352754f20abfef2d2700a38ab6b8785b263fe0a8337a6b64587b6139d8a30ba8cd1b5bb2e3b50ca91f588dbb07c124d4fbcedbc68aeb61d39881e621abe50c211ed86046d88bd9a131c17053a835f441f59eed72045b5c6ab39b901908e1c1ca393d900b7e6ab4c48e1b56efa76605eb5c9b088897eae244e9b1a644fe868e3ade5a9f79b5d3d5815b9e8526a13e8ff2f2a12500a7a9022bc0e8c37f4583a9ffc414c28a8e27308cbc38f858b5bfff86c0345f47261c1d93626c7abd917a4caefc9e7d7fe7cc15b898d62d89fc0e7ed50a7d85188ece81a38938296f52ee65d79655540daf1f21d3e439bab96fea4122ea19e7c9bc38f760dc328049bb94a8a5bf8dbbaeadd35c19aa80a2cd880e547bf46970c3b8c5a1e613670ef78f10dc59f96c37d2a6c3e43f49270102dcaaf08e60f9adddd00967d4b16752931be226aa8d4bc4f2884707e15e30972f03dd281cabfb79cae67fa5fff79290d68ea9a4903c15ccf33c8751d46d3da8829ec9c87e5c11c72271a2a6c06de660bd65e3d2352c47e0664e19ae3a23a8ad7cebf652ae4ffff47613ce46d4a1d2d9d00e521d75764f834b11aa0497f8808699eecbce3f90be498d2029a6869f0b10bda55035d3448359cc9e0f21474840434961f5587bf130ef387752a55bf8629e68060ac058a6831c81dd8d9eedf44bd9655d9f2fe3c4d607659305cea0fd3fea52b615601002f6da0c0037a86976656d634de3ead0fd281f0df1d14ca3014913bd14e6a4f1d59d34a43db3ec7db7e32d2f78768937b85c37e4cfd652ddb8aa9410acc156f9f7199eddd366343363cdcaba94a469a3bc87ea7df1d6269ba9aa2b65a8b867bd1e12848a36eedfa62f3b8e1e0ed41e599be1847e3668685e64b9a0a0ffc226f7cd90c7905a1834db68ab54336ad3e9be65f54980cc77678115794b9c88f08c47f5fee2976e1cfd783de65fc59a056ee709e088fba1e8cb746bcf919acf6e94f08acdfb9884fedc62a2932ea129ed108bb3648c82c94ef2b3e233273eb36d8147c0fb31aefee753243472c591bc823851979ebc8ff88195905164814c84231fb47f43f77943b91fd9b1a7288fc07d4820b603b55d052f92e6f78bc3b8e37d81622bccbaea3531ea7e0253f193f0bace9765e2f5ffd2dad1642598f3b5dffeaaaa617bd8864a0f507e8ca554ef8ed9008cca8f9abec7cfc326d9ab97c1b4214f9963715986c7879a76d60345461d2ec39184a7fefe723d30b5ad48b24dd1350f3f833221d437c83e2c8514dca20d23a7e149f39409734dae4c321d8edb8052565e323b31c4c785421a8911246a3cf1018dc681c285c0e2ba57dbc70dee7e0fd163212b894597da0d21c750bfde7e2694bf6589b7a046e1ee2c74d920ce1737e88f7eb5b8c317bd97f694a3daf5a212dd41fb727266ea545ab3867045f5e19a15807aec6c4d236efed2ac1c685fe2985abc8e82865ffc19c9cb1e458269c3e878cc7c12a3d9f6ae7a2eb6ba617b59cc0771ed4c8a8ffc280e16f09e038067299dd99368f427f79465501d8005ee96fe035a8865a0518e0ffe835ca327ae429c8a4c5597b83f3c655f2e7091293a32c770ce3f367b87d7480d7a6b02e0278ac64c51ac0bcc200b971bcd09712ab37546563bab7ce74628eccbdc0f518c40069428c2341c5432b6bf0af233e3d0d0c913a6cce6495f2e30926df2e02dd98d350e06e4dd203f198d73e701cdda7084a44ca7b1772ff4138c8df5a5b52e713f22c64217f99eb364c19153c3cfff3a002eacad8fc5a88f66643fdec9553efad2ebfe8de1df7f0c3cf7cfb5c1f7d1233de4b59bc0be9777bd06e4cfa3f4b764fc3fdd5f7532985e4624d978ab3b55827e2500bfb3504228bcccfb9affc68f3dc343a99d09ce3d0c6489208d06d6bab4837e36c83d47206b17628c7762a7af8c1c59aafab2d2577a2313cce09aa5ccf08e36e7759883a9003e37867e36c1bf60498130de9a98614206e7752c7711eb8e01285fce87046e5605a6378dbd7ea53650ba696f9b938f58af0f32fe0af6152a4d1070d547df476643b50bbc0c8971e1914abd6c9abf635444e2899983807dc2dbdc7ec063a6fb742c9b19a1af9e2447e7d00b044ea9f31080f08f155dd22817b74d62d9c2816465874b5ceff6f8ac3b2a342edb8465a92856e67b1d4b5e2a5fecf79305e79b88da73c01beb11d22e1ea51fa8f4e4b8746f47efa2ea736af8232fed9499f96d3ae24173b30fd6775b788a558983408ae2f505ee0267cb14074dcedf6a8633a4c4e83ce17f34a08b50842f8bb81827159eb65aebfc529c02742c087e2c1bae791c6e775447efd152decc1f5e9574e1bc6e6974124cea742e49c3093c1292a96f19ad6494e1b612ff0aea33d8dc63685cb0017792b46bf01439720a53d00e7235792613a8ad33a57b08e7875e8187b70d863a545b1a334d049f778a3723d8aa14df68a6ae7d9aff4998ce74ff72b14cd5670641b4f1a13b491830cd266e36b7efd0c2396df3ae888affb788f6dce42f389717313e7fc7655b8b00d574f648839ddb5d4d45b863ffacffda9e1652361ff0afa5fe6617ffc38bf3049a623e08e0086aea35dd6717df92d2e1ccd2fbd35c79f42512f0e0e360db3f2513141f7d4aaa26bd0dc4ef6d8b8189f89ef381930045d8ae8a2404f33fe284b547e055d742a4823d39174f6f78fe1016c2fb7f6fc45c3d7d936f0450b8298e3a83850b10251ae68fe754fddd968638aa5088381ce125d1b4f88c24fceef71986c7032335206f376e5dd04aacf98194fc81491797fc4c15a151807b948e67a195070d5d8d46d503dbb1a46f712272b848f0cda0d56609e0013a75f5892b1a1bf72dcc4a1676795ae651fcc4db7eb4906a93778de511318e303fb2eb37e5352fbcaf7f772b2236e538693444e4a7daf3b850c263632fc5b511f29937d2845f65501b0c8538ef39a5e6fe0042f4b239c00f084fe7fa18ba39239a07df67f7e8a63205557cbfcac25b9a1189f06e9f72b9ed69296782dfd2566a6a4233e588e5c2913526817be763d25f006de6556433290633332767e159c9d8f73bc297d832fb599d25aa9b4e3832732dd769455fc9cf0b26cd7d03d037cd07948c5b819abadc410756edc0c3471e0c1240f5c10eb40897c5056019491c84365f671d586712a5b2a1370d870183344f58bec28e1ec0c2587afcdc7b83f22696a314690b62d2335b56a79d1d6250e4b74ae1d414b5e8b714a6ee4710b92ada5f6bb65f30ee2e750596bca71156406156a022eada9970c9b47fabd54b680af3c4341085bf9f368a50b8bf2efc3afb699fe2cbf92cb9f1b2a26ba949d3e135d136babd03f4e5e6fd114cfae53e8559252cdf1a19cbf7d241face83c49efac06590508c159d63aedb04b8519a2898ac47f727ffc89b9d7de5a4415bcadd642865799a997a4d508aca0ada48a87a9569c7b03a29cd18eba9d00b6cf9cc0ae227d1f7190f2367c8a2f6e968da46cc07725dadf78d030f5fd2dd518804458503a52b0685ef7c837d8ae9666c24d99f20fef55a0e0a92413bef3cde38f75f9d279608a31e94685f6eeaa216f7cd7700048e28ea0d68ada58ef18512987b31f7804bbb5b4a583d67ccc7271bcf71c83f130137739ea2cc3de8f04612c93db1107ab762a2762b01c6a47bc37bae82d9239ca16f65c40b487d2f8948ccd2c4e72b6eb5a255d50576d8bca7aeda170d40d89a93f979c8d708ed2896ee5468500a7ce9aca32de23fc7ad8d6ce59401d8e9aa5e827fdb45986c7dfb5755451b3c9eb72f725fc80c445b795e8944eaec9cebb4fd95f44387b32cce00bab46507e7bdd6740f70963aefe710709c1c7d22875072ae110b9e8d00b2342a2c98f8d7ef30e370db685028e81a45368dddb17c10c6bc0d54f25995999b32fc002ef102827bacfc62748ae987563d0f2796395376a5eeed6d43682b1e41100f29ef091dd3c666348c4c8304f458e81f58274f991ecda4459f3390aafe169b5a2fc30a9abde56c5a94b44e2c7968a194e858202017e600a33ab0f228c0283ae99b0553f92fad0316e0ab3e5aa5557491007d0f5dcb4421bc69fe90a75a55df405a7fd46a0cda897e2d9ef231949d525b36528eee2e39abd4cd46cd431b02b5b4b2accc7941a1ef4456a0716ce515f6b680605fc84f11b45f7a9471db3d096cf26a6c28615d30c2a6f3b732a77d8916d1e1f3b1ba8b6e1ff3b43588d436724db85fbabf57aaebed7bf91704a88f7bdccf81ed7eb6e93f2e797f5e9a6269db180beb895f3c877751b72a6d797ee762fb15857044bc3b9d7301fbf2fb132ff3467312c07519ecdfbd842119b0ada6fbf5cec745176a2efbe65a157d18968460ec0ebc037e55cd097e373c17653b75f6c72ecf012d103251137ef3b62a6e7407cda333cc072baa6b023af454af308d182c95ca8990231d0beb9fd3f960cc26ff6c8fefb5b3d10bdca5e63689059bc3ab8bf8f1813213b0579ad89e793a2f42a945a13bbff6fff0e557ac842c5e58a3c574880ee6624dcaa7bc78f121f131940056b1e8342864195d2768fba5ce7e6f6b05502292ba10242c8557d7d3d6d67a42168e77b8233dac6e7148af7c1ccd920fcca33c2f2d1a63aeadc54626cd668173b6ec88e00fb6b878ce8a341b07911b9c83e2ec9b1764c20dd15322cf2e57ffb295b782462a90e55901c37a56badfabbb333f94598e5b4c7a0949c751f178c13fd2fcba96f3b271064a8d3531b9138cd2f1d62341dcc91dff66b43ac4e9c0a16806805ab7a33f4b7bd89fc664aa3535d9f06a9195e9bfd449fa3e2ef153e815df23a97583148a23c853fed309d64bf99a8b4c9216bbaf5a64232cbf6175bb1e637fcee8a72ce4e8ee9587af41520b25bf3250bae5667f78cd9b321d45b791a57275fe4e40c2ba70da9f85c8dadc396ad617f11970c625c4dce8feaccbb15614e2692562d5e70418f23340a249744a23fffd11067ed69f56e8ce2895ee857fa604fdf15105117a67a639d1fa8092f269302b7bc012a4000a6e3953284d060d4ee6e3c4c217081eba8c8a391ac5f12cbb5d00e4f36660744ac840bce506fe1b0e453ba74956fc7a3a8252defcea18a0a9529533c4267e325e91426c310097ec60ad5bc3040b6cc254bbe86d936d057785de6198a6ef7acc1ec22621ce1f232ca41c07d75093c81414a1f25f59e0c2838b0d2b54190bccdf68a40839529f78fa556ddbd3f3a1de1aa5aa02d6c0c37524074438bc7c565632cc98303f5dc2f0d2f24d46b2e7f798753e56ad9961b678c4caa5c307ac42b36a9e17e3155bac3d2fced55dcadeb51966db878b187a39092eae2ca05e1596b08bec98253b9b1dc76dad92191b17d5265cd373659f8d65c775f074e0967d4c4cb924a7bd1117889f9ad4cfd1a8057497a0b41674e5abc9b95339e4ef7b38d3094679db4bedba2ba8b1e6b6bf8e51c6facd59670d3326e387dcca2ed3e3323e85a66222dc39c4ae69e673e619bcd816b57405d19b1b725fa058eb559901d44f42aa0c94abc425eb913f8fd47c6543b5de996520fea0510d52f779758b909db24f5275b2d3a82926a7c58014e0610936a428fb9e136cebc80c9233711baa9409e323262be830d43839092f8e76558f9940cff34f5eaf36d2653fda9a47236965137ffa81668ee5f9afb0c585c7e992c876e1e379fc38674065811e6fe77e0f4994279a988b4854bfa4dc43741ee6a199b9c04a725f0cb75cb55701d213d12235cfc17f10a8e386fd151bb947d020a25f14e98c631d77054f71ce175fdc67b52298a0bae620b48efff28439bc7ad6c84d2786aaa2dad504be52492c8700ad65d5029b915e49f127185accb255df04a84cf5a948320ae4e9ec66cffeb7591fc9cdcddc8e917451c8c48bd13963c7dd523f996cf0f8b8649be6cd21643f23a96724a06f1bdec7de080e3eca7f2e401890b5204a9c02be4d8667f4510a538880111ab0e7f3617d9f720818d2608d736872b1b66d094991a40475a66a0e7a3b47a04673e6fc923b94d89cd71c90f0c170741d501496bad5a1fd46a2be57dc50e65ab0e1d8b2ad25921a5ac13db72aeb4b1102e8a343e0913040346106b6693b2b930a205c46dea65c6b29456a0aad2c75851e5d55741b2fabf1ab0faa196139c442d138589ae3583ab9028ec7e544650e5bac2eff320b0ca709f87ce0cfc7af260960fa9d9a0e31059c8cc0440c59932e3b45761f212e1db7dd86669b82a4c5e81aa2cf345b61b29b3fefbc4fbbdd3150dec68a4ff2081594bb40733132d15e0445623e2493f739e5cc2e8a97d1b84dbc7e5e29a6506d8d74917dd0b0ed48364fc3447cefc70344849c0afe088ac1eae213f5c093f471f6c63d3ddaee25bfab39b040cad5deca9a1087f32d2d98e58fa5f3d6bbf21ad2219e0517d243727a1a1c45d56cb53b87c63d1380dff3538062bb89662367f6890a022d6e47277fd7c96c06c6c8262602666ae5228f76032d4c3d913c1c7b0f67eac596c952be0312dd619e6a139640a60804088594395b0bc79a5d57c64e84f40f5eb72e06459b5446c7463c89539e70ce41bd54c95a7d598349cf552e193812abd2bd2900ddec298609388905ae3f267f12394d032de4636a13066149f6134c8a6a0c742b2c865b2dbeb5330b3bbfdb8831da29e8aa7cf06c6b00d0fa7d65eef613bd7d61460739f13d15a3f1a594085a3da5b8d31bd316320533b09883520e85a9ba5a98477f4a97ed9d9d9eed15125847299b2e1f35f80757327a64849d68deae718e9ad3c30c69a3ca62fb4d6b2467373326d83722dee13f312bf4c1c740f75594005ff518940e9dfa1e931a68db6e5371b0bd55c95bf0c1d0d3bcb5c3b5a6f236d1c685aa78a100f165fd04503717da11e2caa195737aeae3b6fb5346d1d583b4b2fe1516661d1c529cf266afa00c20f6c70e285f4873e7c07b6e6dfbf63d2f786f81b60f30aee9bd6f8faf84aebd9c2fb71a5f7ac1a4e8b113b79fb6ffb60507d8410805d254cf55cad2cabb1c5e112c8db03989cf5cde74790a2ad1b78b4405b52090617646a9b896f9b6fdf0f1cd55444697d47694af032c7275411080c53c518d1f94c97c4b92635c8cb41ca325ea52a7cdaaf905bb8c6f84b7922252904641d1094e70673468ec12a47e76510aa1ef2502d24c3d62fc68c3e23c6db3a0381835a5340ebe8820806ca5bd1c3e02d1e56ac7951d965e48bb7d939512f08112a7857d782af16d21bb4e7444a21b479b574b72e9f2a2b58fad8b950a9ebcea1f7260bbf6f814e532fc2acc9d65167dfcd5d38b13e9e96d8f56f9943528040aeeba5b1fdab4efb76ccab1e471a60948eb0a0fe762dfba32b83df2974f5c5452323b9acd826e6530ee560bb0d6c55df6dc1db2cec7e2b10cda997cc2fe6257255b7564b1499c92c805350842295912c8567e1278bbcb8c429992e14bcc88b6dcef1715350bc843da7f2ac19c44bbe69ad326c1d965fa19374bf0c6e31c0fe599b5c1f6759150b0ac214de7aa11cc851dfa7ee34006becb99acef15b18ba186ffd4ff97fd76afcc9d8542089246d557c5faa11e31078676bd194f665cdb5105d85873e52687ce4550064c82fa92071da511e00850824164f42b2e7a0f4aa6d26d93b007103f291ae5540ce526492c7f9316b9dc9e27f830e27e879e0fd0d54b645e9e255be197fdf01849607bbbd8f92256ca6d9840d1f4225dbc485f718d813cbbe548bbb6a8893e9e91bf1893d608b3bb8636317cd01d9a1f4569320d68a03f3df6c43f8a908605c1af134aeec389fda3382db1f31e808dcd28d096515540c60b08eb9aa473edd202ffc966e1b9d078b5b94e3e52728b139b1732d6a5d5d081a10a52256a2e1bb8d2c4033aa5835f255028c3e69447dcbc4af2a06019f7c39118717d7006cff9c85cfa7db0f826f258562f06bcb46e4723ca1ff08e98b9910671623ff944bb700965d175c09b218c7ef3a0d936f687071673806f208528f83e13c9cf98423ca1f003d0b8bbf520cf2252afc1b44139a436631c111efc78d838cef3699ef02cec8f1800c364995d60f9e41786a049136c0eaae93651a5125839e516af5a60de41304a8f07253ed9f2ccecfb0a5133497ddde9767485440659fab1380352c77ee54dd1a712084fe2aa55b210f67675ba01e6020977135060d3d7763dbd61fec03736ad55368d5f6135c50929971bef9be22a07f793d00fc9e807465101e38894483ba02d0c26581d6054eee9d7bcc8cf479f800923b7366f38961fb3ba79a4bff65c7d878bdf92e5bfea557e9dde18cdbca9796833a10ef66c7c700a547736f7d06fb87d87ff34582a0527c83e344c5f15f18d4b50962a71c4d5a0f98b473e9bc4e826ab31d6a61b11e1a6af53aef3dcb57f7030cf24c8906fc60d24d761ad186b6e9f86dbee4c4d6c6d484e84c5ae2e056f07b440380ee19abeba55be68d13afe3f69f6ba4c6b7a875cccfd394b96b39b994d010b8ea19173b11c7854987a97246b82e998877c065fc6dd7eb20a4e28ee46cb65c239d8e4dcbac84c802c0e2b1b42748b2b1a50eca41cc8e30c383b9ea1d3e5dc82d39fcf8836e6286c472b48a40b0ab92d41ecdac333c1acab661062b5aabc9b37c8894b5dad53df5879710f54e66d8aa2cbfd0c5cfd095b681c615fe9abc2bd6dd87e7c4c29c647bfb0310a611ea70836fe86ea93a229755ad0891098a80c40d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
