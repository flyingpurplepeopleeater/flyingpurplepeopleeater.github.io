<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"931b8ebfc69dd91e086ba60867e6cb113f960680b8ea9bc29e236b33805e837edf5e4a8a57d6f6b9a439bcec29625fdd897410c7ebf8531d7d007758378f35a6e4339ae6822009c68b1c1922f4cec586604830d7334959ae2fcfe05707cfcea129ba505946333bad816e9e7a67adf1b3d4c7eefd1e565798a5b56e89f166e6e1660b966c2ed1a5b1cd8da876987f48a5238e072dd053906d867a99cb68baec54a97852eedbc3e6ddeddd2c17079d356321cf8fc592aa9b1945a9490739a2375d5a82ce53d746bf093023b6700ae6a2103d21dfd97f182b2c82dbfb4830a284a568ca573c0dd5a6456b59c41e769915eb267292efc97bd25d5c1a0795f5202456a10779e4725062e329b1cbc46556605cd57639dc63dfe9901cc7617c3a1e16f1d929b0a16f6e8d73deef5bf5e6ebfdd97964d8e23f1db94c12531293c3531ff4d5a2b88e97b15fa44b0dc62ff1d0e63e6eea04b8b0dcaeae3d7431ccd2803cac4257b44184232ccf0f42463b10ebcb4b221ad889ce239eab72158a751675f4f9d0b663989c601468a862c26ee546bfbf03cec8437719bc93a80913af446b640cdcb78ddc5a376f8b04a87ef78374860415214576149cdb7585c2e867929b83229f3f14a015077af30d65010f46b10c9d07fcab0229cbcb6eebf71b11cefb90cad38f1ebd18d4688f11c08dc3ea8ac6d83b829976897239bd239dae21db996736025231d8138cd88380a8a11239135a103b428b66fe09a3f653b349ac4b85717641dee2aa8c724e2624c71975c74762e260bfb9ddb9e845969f5bbc3c512e9cd5a05d25f11a8a2b72172b8f6a41663b718f4034ad1f0b082a1cd2ec6dd5f57cab66a3657bca717f28dd183de33c4ca0f91e37ceac2af8520f50b8f294c04294950bcc55cbdd75b7aa57f3024789346c2706adc62952c6bfb474a9a7b8d77e1463fb73e99182d85e3375fdc143d09f6202a7a188dc34f0ff0bbfc84ac8c0f91ccb76072e3d99459f6d48f23771b3617fa2735b212ddc4e054d67dbd4ae36db258254c7368eb0f20a55fd5e0070593ac82f54d6d3619480220a6bf2e9a7da719cfe4d0d479d575e38db83083f90e26dfe731ab37de42449363042f9243b928873eee4c70468362d8caab856851e48685e8b4eaf62735f454de520f5c42c8cc9f9178faf21663a7531d7747c8db793d1473207d392dc61fb828c283b177c1eee0726c4db8fb5783b490108f56ea1eb8f642b8cf086513645d3395a72ca8993a9235643b489e97ab4dfce47ac27341b5402861e52f1594f57be7d7893ccf0f8567ff38e6192f06f43c24c5b7c8e580c73f348b8888b741c1862113e0a591d14e5ed3fd47d3fe4d312eb95c7d68758146c9267500bb7cf1329b1427195f2f9276e5f2d54824dd1620d5515e7cacb9988c23837fa1d2716520c5e21a4de5bf09b0edd33e82befe6bed99e1f6a79dcccf5f4a3a266599f3fcbb967f97a5e799a1e0b70f7ad0bfcad77fe0be34de7da62e70a21a96113dbf895cf81ebe0adf077198482c85d28bbd6f46c2cb0c7273c0126ee768501d22c56336221177842c8e14fe8233d1c5af4848708b6a7f23ddcaf7e2e1d7014fe433bd55b7a23610318373fda92918651b1e890bbc09127bfaa69d26f3d8426fc66ffa255fbb7d7a6b213d4c9e51ac74c36b7c4505873c1df7d567d059282ff90e8f95bd5a23ce96ec4fd1dd35d6743bef2a3b0bcfd4dc1deabb0014de795acca569bc3f4cd9e60971d76fa7e765023945058f6b12c94bc344f7baf70545a6946f15b6c3850eeec4a97acfc04294a91a65ebb3da94ba392962f01be4b36a55e7be0916f4e0b2d2c27bd1b78f7cad847e2b1ff0a696aba177714a77287b88521193558a244fb4f2836cd4e3ff11b92ff378d3e33da538ffed4051bdc57e04678472c6ec90d8c2a8a3830f3536c055de2a3c7711fba86552c1d7ceedc1c8f173a5d029ceec13382db3923d19e2c50c6ace099b05849731d254446c013439bd9dbad63590219ecc7db6090bb33367747cbb7a7aab4288fb58bc03f2b02a10a57952ce076b27a50ef58c0630913a83fd249b924af1818c5039e7c217ca1e22439b6e9eb229ff9f9b8e1592519283b7a23097a049356cb36d97d88c0a51736a755bb1eb736598700912ef4c6f8ee9753d0f8f3f12bb11d864dbac03881be68179185a45e8c20debe0aa93f91d8c3a30086f639c4b5ee834b2b339380925d1c4f772d44fec96ab3a202296135fb1432782fa6d77652b534bdb69e6b1a09f049720aae93a01fdff567dd78d659f8bd7589249baecf74e23550e4e4aa7b66d3ce6f36875b285b1c96466345c5b59013412152ba43c2d82b95eb9ceeed04f9525b29544bc2c5686b7a943f6a9ce1604b42ba0b84d05a3169ac09425980d3079d86f718ba3da0f7c651a587b01b72458e96bb90d5e67861be7eca7f1c2dad3f54a4e9d0b009561ef0835db99f5978f0f7b214bf592bc2a57ceffd158d3b5679b5f8e670dc18efb77de8cc5c72d48e3dde637ab0ddb96f541b7cca03d199a6438c6211370c06437090181a55613f582b48c3034e4f6b1b4d7ff054821076d163c158810e56c33ee02bd4e3f31f5cad64ce70985569c0dc3314fdbbc651387f03862185300e5826ff160a7b09a0fa1177d0a52786bab62b1270b0835c58392fc23ae35e32336e06d2f3f17b728c207fec1bf1ca30ab307b6996ba47acb5df55f714682e1d481e58346ed2fc46b2ec90edffa56088b4b24a91cc64e9c6cebb227735439efdf9775f1c0804d20b5736a827083ac641d0ef78162b7f5a42f17fc07a7d6baf99175ffd7d4ead9e5eb922752869e7acac76d10800bd5d81c76602f2b114d882535efb437a742f81e92ba04d55fd32af85babea732d8a81f565e6f813923e4ba3ecc2edb32b1d4c13aa3b4769ad259d5ea01ba82b3317144d2fb0a0a94ea60b17c2c8ef838311d4982ec64a5e8d4f078b927c5b2cc822f132c3f5fb340eb7fa287a162d13e016d03ea6209561e0589f993db7bce9ed7a742a1bc026e7241cc8857f2e0cffa499d1904386258bb3ec7fa98149d7a656b9db6cbfdbb9c56dd14cefe41d4f1b54aa3aa12fbdce90a489c0273cd3a6434443897b17567a2ff832ced873def4ce8873a2024df15630545847b201b1d8aff3a253cccb6334ff316ab43f08ef70dcd129e388644cab46f1dab1bd6312c7ac0708756515ba1a010d2242f5cca15395cb74156b8678d439a4bbfa4ded6e6ac09be9965739cfcd1e1e3ee2b762ac334e4b3eb249b7fe7b89b0220de60f030368cb1f62179fdf152edb2841ae20326d01e296ccfca2b6b61b8691f9fa714e8d0600c6b412c8ddeb52c90bea454fa71caa1171863375aa99886be52c9ab3a03f35ca7054e45b173ff92c9a39e984b8922ede1606fbb06ba4eb34646f4af7396f46f79c61cb45f0423d384080ddf684a53f5db5feccba8b114a3329ba18be60bbe292248a762bef9423d94fb93a15c0db86f8cfdc5e882e59dc178af03e0d50a45404fa6014c092d26c5bdc4adaf337c28b43160a341c3c08a4419a6fd52aff0490dcafcf51bda4d26d8d6b48a6bf952eb841d444944fdf50dcbfe8dff2de68003a60f7fa6d61c142e59898a3484d088ffa1d7c57aa4e480f34096db3696d61b3aa9cb2d6e6b18b847a532640ddfcd605d1eb098cbcdd61d1004cb3ce816abcad7e14da600d37418d41dd4c27f96b7e5a5dd056f66ee04e7dd8ec58d9494b8c58cd4d1957ae44b232606937f793b5f4fae0cb4af15548978ab310cffa986a5e0469e785e840383072007220a9336c237bb07d33d9c218c73a18b4da12773344561d0add8e96eb19635d8b58b701b74c1485a08583611629c47852634da60378d25187baaf89e92e9727833adf015a08272a4a46d858be2b645446fd8ab7a6ff4fe3245030167d7ffabd675a9abb61c5909b253e7648e797ed5d7c52c3e17211428b1acfd485aca1a708d369b735c18be75a5a0ce774011af51c7b90c4375cfaf7a9934ca23cc5a666fee5a0854946680848b7aff6e773cbb96a500530211ca14af9f3c8b40a515dd062026ba6ff485993d16b42b508b2c6f2f6da625880b44b458a93ef0a72975c66647a23ce5c2db818f0c553fa2e30f91f0819734aa71cf0fc847538d53a6b935dfefb21fd5f7ad09e5fd6f71bee4552509f3bc570db94c5c0be1b04b6a0ba16873e04e3de13ae024ba7c13204a830e52b39f6122f1cd21d8497ea074b90056eec1386f854c063718b570e7d45b9575209792517edfff4d3188b008404e57176cf6f883c38cc43a8742519ac020da48ecd082c7d22ca151ace88f02ea74ac0e335db289b1af129760e918dbbbdb515b9c9237afe88d68764457a84750b76ff9df2f3da23c22d30ab9497909ab553c170ee44eaac16a1c0034d8c35f516fdf17b0aea2d40f35cb451f7e2ec26d168bd46657cd9ee33815f845cc631dc0d9b4a19d671d5205e530a1f9a3595b5a99b208564ee874fe1f4a2c1a68a4dd37f1fb9d7e4906441210ada7f273a7239774648161afbe9735b658988d8b39768e4f312a57825bf1bd7571decf30886c9c144ee2e28be7964b1ee6aeea90915b1848056000a8284001e7d79a55dc51ba5d8001a90cc8e942b7f6d1306ed211f31b65829ce71d38ea3025afe4f12f1a28cdca5a054451f36ea9368dcf01f9c35368a53d7352e727958ab462a50a7a68a736c6a1dcc75cf2cf3a7ff30617610760c25d175ca96719d3c3213b95464edfadfe82cf5db51c3d3a82c718bad94a1eb020f92e54ba33e210f1d5f1a716897366e4d2324130f4c1d19142ab8037f323186c337a244ee88306660b3560a7c8467ece26b4cb556fcad661e3820887f3a4d139af4baa9527c536184b9912388e00e754054f1fbcf41186e6762d8767e2ed9cdec723270ff66f9e65d94cd73b3e6fc633b00b462b6a80642bf769d3dd4c23d3376901876a1886cd85fc18d91b28af839a0bfe437784822b258fcd8ddc2a61ca95c61b0a9c0d0014c2a8c028cf7597d2775c39f7d851d464dad71dd3600110aa6eb47d0c3b0c1ba1ecc6360f44410b06d09430f4b89f8234f07e74816d9d3c830ca3aa7e8b55586fd5ee0bedb88023fddb698081678f764e04aaad3d0e4e0ceb205335b7380767aab1d87acc81bf8f3708171e10b698b4299a9e5aa4fcae348ba830abbdfe3bef68a9e1d565d547866b73af3cf1189f5387315f9204f24e071e2e964ac488ef6c6bed6d2b17e86c2c44894085040981f6a727b7a18574b7646a7d142dca0d1b79caac8df5246f5742e9abe5f211e04b539f8b6904e43abf322d534461d60221ffb325e29001da5fc8fc547e4a348d9abf7968a16d430c66ca330e3a2f211f23e6287e35785dcec575b0953379c5ab248d879016cfa79b8cabfdee79c5f5ee8b05ca59fa4db7486810e2f4df837088e66984f3e03d4e212d314c0d364198decbb158dca1284e63e3ef5cd54715b89b02029e905eb642324e1b84e19e80ac7dafd6cf042feda38a8ab3f6529d04c532028d43c2fa74569b8d425d719b26f2ce7cfceaf4caef797ec2e655272262bb43f674983a2e81ca3a8bd39a63e1d1a89ea3187832b5d773ba30765ff9318d83b79b6cd48edcbe65e7ccc2240526933de4009217effc0e1549f55bff1e8c3d1a0bb72cd5b2c9b5ae75c696c769ff6f53f74ae29ce90c6feff5e33ffa55bc67346fb6cdad72a4efd8c5962eb30ca0208eccfa79dee95e715404ea792333f3462b5629c07e8a5a871d912a23d6734febfe57e221ed07182a64e32ad47b4dcf72940b944eb98e5be76bf87f1eea5be754d5976d4cdb2e8dc0317edb55e9d6c2d7f5126679ebc2846b69ab7e02c9cd640b06179c3ecb2d8b0158b771a63df0eb20ede7e09c1be8ba252b4e36596708c5cc2dae640e1ad9701fde7c17f45e0a0de57abfa04b9cc1d94ee8fba70431a743b6d4c05d7080bb2c51a68a39c87e9be68df6d7898aa6a309768adab969e6a1316b2e9ee485028eef1b731df599fbd73766f6695f54927ad7686ed1e5efdb0773c47b707c627fa6987a917aeab478ea4f1c0eace6ab243f36527ff9febf5b3b3dfa00aba70cd66a6b7846982a9c19b25bfe5f5e5d7f1db4719f561a6162539510cb50e1c22bbbcf43a22fc8ef77794ed05c596af390fc41af3e6de7d367822a5aeaeb528f6a7d1e5a738bc6dbec4a3c05a9a67b71237d5fe01915c2a8704b7c0c7b891072fd22a81e4e06516e5112de64048ccec03d57091807dc1e4cf0de68a8b2c9fc1fc3fd49bdf848c74a25006dfdd7046d1f2f3cf3b4e7b38115d9f4355cf1e284602c03a63d92bea6e588596e543b55a12df4e9f05cbf4bac9f5edfe9db52533020cfb55af3551774c5047f774b2a21305e92d65a68b633a82b998ec22d21949b6581249cc0e9ce65707cdc76fa06e9380e24a6ace63d1433319722a3e65566becac2d91e82db8c354deb45a0120d8ca200915fe22a72de09556ce3403ecd552c09242044475aaedf58c564e7efe393d28e9111790381974b488a38f42fd73b6a5dbbfe4b517d4a11261561c37f440b39c2605828a56ad00742c64028475a0e23bb389bf4ebfe18389633e7769b7879679051c1f9615c2713467c05bac0fbb5d7118ac6dc357dcb8c55a8c6101efc038eb46c349e8a2471ee357bc95976c95de4917d3e650054ab7d4a2f575df002e50eebd3af383c953c6e70852a32e484b1d05b84cd1e074ccda07a210e12455454c7948d3de3916709abb134ea826079a5880b5d7477c252c3fd37bf1bad34d465a8902205eaaff5790437042b2e664973daaf590a7e282c222b31a44714b76f508bda0d14f1716fa3e85ae089de2df0388a80bfbda78d1c76111e032d51de4b58cafc551d7c2689375dfb40c47c65bb4eb1b2cbda5de1ed96db48021ed6f33e60e62ca454195c7089f58b0a839b4a18b47e92f4588363b9d0d6c242c7072ff777f82c4d3c652ec3e4048a28185d8d802246dbd8473616f499764283c43857835826884d953c658d095b60d068487c27c9a84bc279216d806aaaa4044d160abbb87999fc98fe0f80c85f110d981972e3b15ec20ebba8c3365b32e5f99bf9ef8dec0c06f0838c3a0a94f01388f4aefa53929a4e77c9549a9d2a3fa804b1972b0574453cdcbb7d382b9ea2d0c3c4c1f1f8cc06ecdf3accbdd754966871a54107572f3e3826e60a30f5170c42ad2a923837d7a21fcbebf43521498ba6a9f5cff4b24c89dffcbd5b34251f3924f46cd27341b31d3587536474fff9156c4e2c1395a3c03f590b8a18acb9c64ac822534a120e8e0c14feb82eae35048ecdf182c01735a4fe99fc03a2d6b6d8d2068dc520985307610951f1879bff634c8fedabf71d57ae5ce8b23264de2da1113d45d3c12fc5de05f69f8ec01151c725d5f260f3e404b172f79858cd10c9bc26b4c54395501a305775c3f0a0097939f57ae1bb7079d991014846f758baac7d3e9ee36bd6f26d6993a368cba8b0d804db9429c6e5da5295ad61c86df43679b68a69bc67f2e1df313921e9421de65ad3f1911b301295ec425a1693e3c74946839f4c38aa69ab73b278246e3bdb6e7560629d21d24f96c22d392563f4729ccac7ea33387e40fe18c12b2c04a90ad822efc1dc4c3ce40f20763faf97a72e6ecf011f0971f78f3f48f298f720c1e8bb6147d3cf45daf3cec6352f2acd14afa811fcc5a2fef3f01c79ec4da7fbf1ecbf163936624e478f5f410531ad5756aed6cb2fe1f8dfa67eca9f30b0aaa3435623a0eb8e976b00c7c3fc9b83aa59acd83714235a826275a6d29b95dbe98881d7fb6d91962791896ee760e046c485d464746d730070482d6917e6c0631f1b38348a6e7abba9f12628a3fa12739dd663a003ded1d08ed257a21b21aa32edb85795c1e0c2167dcd3af2bda1520edc90a64d11d62ca388673044be59687ded9351003cc8854573823b2e8be61a0bc68b3c93341fd443372a2c448d75b212ae3a9d5535fd3bf176c4813f2206450c0481617da808cc32cd60c8f73d42b62947a4d075c97d6623f1342565d06f356d429972a7bff2088cee2ca4627731c7c92c19db98f28ae861972c8cdaf5104333ab09df713d979867d8d21974a5de561641445d22b26885bb9122e716cb1dcf35242e7d5dc63d5c432ea89a1a6a45c619f5ea7dc3f47807072de0011ea106b9b59471b7685c4c74184734505ba26af3560d6c4fc7286719027c4e7a92b8beb710071d9517c64738dfe6ab022748d1b1697ec409796a3d05f509a6afc3403f9a48f8e97c3dd368ba28e3890df0eb196bcc465ae9175aeb9a4bc4f5dcac6fde79b019de0dd545d1e0886f3f7196f10b607c00ab94cb72c758312eb7c053a7b6b03608adf6b9d0225c25f5b8de0f5669a25fc5e8b9cb28472e8f79cb546f6853cea3bcd3306c422e1ccab5d0531915b1c28d32593f8d862f8373b93cc1def4da17636be0340aa596c0355d32bf2be1fffc3dcb039314be706e0cf8bceac578b83a99b205ea42c07e893b47bc86ccc327daa452d3eb13c09e28f82badb5a3705388723fad0d12b1cca14f3bc73e763091b764445d3b6db9faaa98793e39fc036fd64026d4bc3b8114a3cab9ec07df61152d8007e86b43816366712f294bc91ec3ee6691d54b335099600e669fdf8a2a9b6f4106716f5d0dabe801bd7ad319d2303257828b42d6cc9b5d7ab231cac2d34eed518e324392f0227cb56c29cc6c5eb19a94c0aa24893f5e2cd3a94dc954a70649def1121c862442239c7b9a08ca3b25a9049d44d3d33a219b554a02ae8b90514af835e1484d79a8dc865f5ae6f1b5d32082b6cb504ead613e5eda294362695349dfd2751a4d5e50136b067db3fef551198d8ce10c2fd5612b37720ef099a7a563be9235a4425324d698616e0f5e6844ae7c521f4777b582022b4751c0770d5f9d71b930c5bdbf4c5df22e630cd4f584ed05342c69c1751628e4abddb8c394a177ffbc3876c91f556633980ff15cdb1604bc278a62950951aa46ae1ebb78b1797ae1d57e3a48282d68307f3c9cad291ee2a53a18dafe4b8b2e03e393a6668db407d4ff706062a7dd3a2fe38fa87ffa88584418a98788e8cf560a1b345520c848af20ab048234ed894519f98bd724ce38fe94c96b482fe14bcf070ca9e0c766f6c2de31b0f89517c3b3512d6b25ca69fe53b58bf72dde7a7133e77324c4bcddec8b8523cb8997bab4cec92e583989b0b46b74ecb16fa807d80c8f6b50a7689fb43cc46c74c31d9be2b7782ad8ff3ff682e80c9f980b25a592f97bb891d9185f0ed432461b1bafc98feca9f9d434f255d155e95deaf637efaa0f1bf5b92137c44c12d8825610ec7e33ff7b08846bd7930c9debf12f5ab4634f954eb974b3b43cf3736cf7cfdbcc634b0687af52e832284461414dd97d1047cb1dee21dccf976b21d96fda0b0c1edf640a84ba906ad124e49708ea2c9cb0e74610790c660b4ea65319f2e37ca37a9bd194b542c77172ffe8ada3c64732c6c0d4b55a03dcff378ee6c7da545aae00598debb575a1c479ea18eb7bc5479b762780ca09a105bf0572249bbfe4493e286fe2f01f5555eab6853e6bf72c0d55f58185963f4799b88e27c8f84de3cf9a3368bee48b9281512c09c437e7fcfcd166b350ae8ca65159b02fa9d0657f096a15707dffafae52a28391c24d1f51868bec57b88b9eea9d58055effa52d13daab99c3f336cbfc1e75459a229f3485b0c516eda66df6dc87e6546306f8ce4a6835d3d5733ca6639a9256fa0dfb4a889be0b5a2e1912f6239493c6758203c3d105ee8688d366cf75e0d94bf4971f20e52541b36955832946204f30c9311e3dd75695027898d9d28e2866727213b33abff678783f605d73adae0308c904c44e964b8abd0a43db93f6e23f26dbb26ec1236fa6970858c56a5676220112591fd1c14ca1370c00bb0bd952c7c6902174003d22c7b146dad6452874f7ea4bac88eca69d0149e790ab07a84e54b8a6641a581da451f7ad8513953d388a2fb2b6a7e5ffe0d9c2d8eb0d2cb4e26bc5e4d6d921cddc4dca573405a05d9402144b2a1b2866913f7b9e8dd0c872c6dcc3e617a132ae1238b2277295208cb6e8bfaa2ac437b188efbea6e89bc91528aff5b22974a054126cf8e4a60bab15bd0dd34c4a02ae0c2837bffc3a9597c5555d641dac1843029f6adadc15a1147d29e8a960e8baefb7f5593b7098280035cd2ca899c3af8129a883ef8ca4ee94cf2bd9189dc7987eceef7f33dc900f8e684e9dfd04ba371ba712ed810c553b75a05175178bb80dc3ff313bec84e3a0fd679532452cd730b7b534520e10325107cc0518964f156be0e58c3542b5652faeb736b87e12fd6f9ccaff4b8b0fa6daaf9fdb35e6a9b3141d197968d88a0f019ec73f82d2af637bd4eaa865d73407294e2de697789f7b79ed49992b86dfbea59270a9a4ed6c35aec04e9cb35a864f9ac0ecc535ecd195d4dbab10b9917a04fbbaf609af0255747bd4627ed615c13d615154d9c2021214ef1723c238ef135a024a89837f8bfb91645ddf5710294eda9311520dc0cc4cefe8648f7488a5044d103c0ae87e64f3f7cbcafd8074f1c5479d00a6534fa89b448327c805015d9181e9dfb906a1e9df5bc2ca53c7e7b52eaef1cea6d6f8a1ed567b33cce2184556428f879ae7ec73a356f485903cbc0d8ac26d686fcb2604c8bf1dcaee9e3dd3ac2928b59fa850d0c5bd8973f83fa966e3a3b3686481fa00ae6d934da9e423c22efe271938de32693c95c415b6e0bd42bd15656b94c2b337d7457c4c626eb6d23de6aaddd9ab51a5c50100065255d9c5c27388f62699057fd09caa919e5742f5a1b8eafebac9dd1e93c32e4ffd9a18847a148adcd9dfe2cf51c909dfff790121ccfbbc2a786fe699893e26b9c4cd9f62d77a4a4340d9955cf2d97e3ad0dcf4fd2892dfef0c2bd023985a14a68f491aea5ec34390f24263ec7d4b7ff71feb9602c965588d16eaaa7ea1fbabf7388178630a9ab5f86318674570324d466cf144d60aaf674e3a02664f5a8e3be288fee383a9d89ab64a90808049ea9a1254eb949087f3c353fec6674c8db376fe9e11383ec10d7ded1259d7c19b6a6841e13563a988f10a27d650a207ed276ec81544e421fd519e22d66804c6d7036226d8e276f84be424f46ea343862159befacb51d20e6fb11266b4f65ee4348cdef907eeb502b7465a47ed2b81e389b886af7009c937ccda233348a716fdc4ebc7641813993472414fdfbf79623745006c78db42f5360ebf57c0e0c5562e215a78c25def607450d6e1e5df981663a4ce63e14f23c1c8db156a2e7289e2ae6fdfa433b8651f24a7132feba0c6f9ff40ab9f1347eacc0923aaa0c1b3fa71460e74642fc2e8d326392d1b0b10304dfae9cc06753c74df9ad17ba2984fc9285ac74de9bf8cd979668a77ae1999b5ef508f0399bb3d374593b8ceafc11abdce3de2d684de560e17723e73cf6309a71390ec4e2c7c7b08d07e9626909e243abc0ca1a5b4ec3f76bb78e2c4cd5eb4e20137a343d4ea4cc31840ed7f9bc8cff5e24e5994b83f6f7806628cea62403754adc563cd3d38cf29ea23a0ecabec48f1331b0834c7ee25cf53bed8f52dfb5131ab612c674df889972e72ed1ea4ec87ed5cd0105a345137a4bcc30391ae5995897121c7481b2c25d91a35280b63cfaa904524368bdac7c0ded2b4df95d290a54d5a92bf6ffa46c204c303e5d00906f2acd394dfbdc46bb40029850751e644216e7391e0ae0917dedd4eebaea0e24a99cd9e093805e54d6fc03a3bc4073c001231dec927a8a52c01e2366425fc348a3d4fcd8cdf3cd1128ebe42dcbdaa3731f3dccead985e9d98a7df4cb08e7819691b07e2a05e5548c56e3241cb157e419a8d03aee7b5d86602fb6e2bbb7c972865fe9aa3555ab626f7ec71f3e78b177ed566089b021cf42f3a86f9a91d9975fd5ef28ead0d2044373d463c924f14f4e13a1d8aafe14b4ab7d2e4c345bb8b3906b9d7ad9b0d723b150cd57fa185055b4c9a31d5f9727b5126b5f6417779ffbe7c80d356da07d629c34edf9c2d0a473e9cf4a99ebcc23828a2f33c803dc6181b3aab0608538fd06eacad64071657289b453df7f1c2063eba9bcafdbf5ea999b07ac69a07b1a64d558834afd9d276ecd5acf0a94dcc1b8ed2f53dc649e681ec9c9477159d7faef22b6cba28eb0d7cb9761304db40c2f486ce82acb5afda40150381c418d7b1884e32d2e81356cf34ddedc4bc8838f563fb668332e5816836b217738784b2e580b3a2d4ca78929e8c3fd1f3936d2eeb468ea1209b7f218c4c19876606893eb847cdc15a49fe7bf13d599be58bb0402b377e3334e37c25bbd63ad042db168c786198395d2f5c86cedb6422437ea9b12b24a2e6595ee504e043fae4d1ab07481725136bf4205e8ce1c2245bac7d1d94efdf88a4772e299e08791d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
