<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache, no-store" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" class="hidden" type="checkbox" name="remember" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd57a0ee3cee1451d50706701bdea2c75a2ea118a01a9a23f56301b6e30389299c25bc3b7d76b069c70e8d73561f0ad848cdf614a3a7a0fccaae9a5591ec4f98213973158af49e01b6124f83c55b00a29eb7aa4835fc19e7f4467175a3d658c68bb341dba1b1f85bc53ac3193f1aec027fea85e278a43f21dcf014cb04295f66ecf60e8cfe578d3b79bee957dc30868adedf82d344f85a920ef3a7dde488e7144ba96117a9f1aa32bfe0b3d7add9beb6a78dfeb9ad28c8250bb3d0e17a7e8c982d7d8f84692f98b86e79529912f3f14048f70bc51af8539fcae83b9559e6faa1cd4a1ebbcc859d8c4657b31b825f55f9e12a8cc405d8edca284acf33e263c87407c453a97d503a4214af37f7e654dbe4abecd53c8b76253e4b5099328bc96ae0e6f7d443958c51b00637550ee70ea678c9f3a6a1e8b47c1f9e4baa95eaf410575823b5d5ada7b313856281dbef4d76050a124f24f607c044414c094eca822e8cf2585a90817e21595d16a4b8f7f0f349d32b493e449988e7b5c4e0ff02dcbec65271d4f3b5417fc9b97d946406c06beb4866d167af52b491750b8e0a1b6ff7f29170c461dffef4a763922e5a1f97d4ac30b6ba9cb7794f594c645a1a0ed23ffbb5c2d2d06f70c4a298785747a7523f5716c202969ede1c08240ab746dad45baee15ec1e413012e63aa8c97348fefee48aa063ed8da146a275bd421e56169179b59ee997ce67d2c1a69c05fdf543ec4d360b0d165717fb5a7c7d71b3097df87181602cb268b163a65d184aceca991773949bab0493cb8a854137ec9066dca5822fd409aaf6a2ac597a46405380b3634f06bee469748d6b1019d6f2ccdbfe0ca8543f183a0c6b183e42378760111df77c800f36989a2dcdcf52b40268508b569f4cd0f1a5849419b0884d4d39484cffc4f1b8c02d9f6ae7e3ac84b7f5883dc6b40cf53bfaf5acddc2db02bce1800df24406a84ed81a142b6b063c6578f2bba3c66b19c49d0a74bc4c1cf66e1029ee55c1db634b1d11a0bbf8f42b2abfecb762865acff041bcdc3703e8875f9f353f432053df0e8df5805664fae4acf84622cd103af32f73e558c6253f90f84b6b9fab106d582b1da7b8d60a472b2d7ccb1bff14b4b533dad8b0bda31a7e027cf6c8d653a968610d7a7074d0b171ea1bae7a45c464a7e86d23fe14efbf32fc97a6bf96ca322e6c06fd759ce85eb8d742fc10348c36045bbaf08f450f87cf2338036a42f29b6e194d6ecd99edf94163e13cda39f3732fc4db8fcff05aa03916a5c0ab9542eaccb81e70361f59267162fae80341f04a4a7bcd4af7c455e3e41d1ad632e75a1d9adf52094bf0570d472cf7137fb69a9ecfd111b91c61467150e1362982f1266c162011479fd567f0a46fcb5e3286ea62beadf3d50df3fed22539a2b004a8b4ba00e337b692b62a689770b79e46f640577fa78851248dcd8b64ee501d4cfeec0b91e54f90beb7c62017acfccf8e4e6ebf088a248b7ff5e713395e628364943fcbec5fa2a50deb0a51a3dea44d99df8c3abeed65763959eef2664b60a674bf864326823e4d55e13307b592bc0758badd7458e32a15c4e328925dd5e06a2140fe60319b7cf64898ee362b24b7fa011f92125d20dedd71c1b1a71af88bc3c2d6749e9b181dd11463c8c6cade8089daa1c09f769b651beffe3522fded8b8d5ba6a326a25ec7252ce8c3bd21216e525e36e5a4cab664720a188de2261978e4c931c295dc8de4784ef32bb70a719db1378fbcca365ec924e358e67cf97f63891fc4a9d9bd719b6b6a118d06377284f95fbfd33dd5e5faf9e139deebc26c86cde812b7afe4cc834b5523a9a8c5942bab18324fa68cb3be360dfaedf18197692efd62fb590eaaefd0bc249ae460f0e0b05c76f7b1da0c1122e0c8dff4fadfb97c7c3fbf52353e95f070fbdc8a065020725178e63b8eeba87297f08c0e3629e4b07002476140227f7b40b7d59a72700a15ad4b0accc6425d72800f9aa2d4a6dee7cebd18adeacdff2aaf9f06cd440a87cd5d39257df63c0c151cdae9b86496a934947ed2d52434b65d1319518dfdcdf547bf35626379cb98d3db3c24b643191fb9c337b5b463968389d780f89edeb0030642bacbf21d2fa2d20767a0ac39ac445c4d052455635f874723835ead3dbc1dedf6482f951fa2086d7fd57f49deb1abefa9ce85520a46878d0556203d87d67d14002e195acd2cf0dd57d1bc7374354a64bfe25642283b86fce6f28f6dd930e8ccf4a8e2482e27ba1543b520687c570ce4669139d2208bcf252f5aa4326d81950fbb68904bb1a62271fff674f6186870d99e8c2cbc9274945d0541a2ee5db2f60f92e4df0af0f633254bc79cbb7e82a5780743d22055891170ef5530d91541f33be22555f7cf0c620666a89707956a1aa6e248c91260e8b4b35fb365010374662ef934b5b9a4cfb9894f5aa3b80b20d6d4cfbd12943cb8a738f1c4984cd710c6658478303f9ecdab2bf9d89e725e5e8d1e764366913a63beffa6c376a02e3dbfc50b4288bd87657ca8235e11a9edf0b8f461a33a5bc919eccbb204ef0f17d8ee6be86d1ae82d01d86f01fba222e98d0a76e8e967d1ac0de4a4f89d3d356d3d969560456fb3eff28461a5e6a6793eba83a80ad09fb2d01602201ec8e2fc8b442b46c98afd8fbabf408982d66a3ea29e52cfd50f1df2aeaa7c6af84f263f2143fef0cf9b9f7e321f1b5e0efba6ab7c6d77c86b4c4da09d5e2c4f6ae9eefb2bf4f07954e6921914a32f17cf206a29e5c865c3fab66c98afbd4402b18a5d61159ed17d5e308c2551f6e65312a9e1b02ef7a6d015021b43398982285c39206d4bfa6bb9bfda5ab858a54a37e77cd63da3c97cf318dd5ee776a8577e82075b49142a7c69f6c99dfb46c5670c07c45fa359f6ee03d891acffd30e0a0445d1d5cc5ffa64a8a5e81a3037c6c18e7b1a0c1ca8ca8d37be89334b35793d995c333ace8e6329ba43107ef285e964dffc387ca43c4a0478afa23e16df9b2549223719625db798908226b49d8f0ac816bf5883be943e6a18fc8bef6e1104390d5b78395c52911a106c5867d64e5b384c5794f17b6b5fa19293946a4cb385faadd73fdd8bce4d07def24f280143363dbe932041c9112d3a6d677d5d3e05d784b0e3b3bc8a2c1a4a27ddebc7e19f65c06093aab4bb5686af1482c6869ad13bb3043bb1ba33b9f13fc7b8139d5ff72cca8b6e716f990331fa052e0d34a53dfe86659e6240355a2d37187fff51e62186ef397f3bc6bf4457c6e78508e5b8dcc5a94299b47ed1d0e8b89915f4aa2d81a9dab5068eb521048e5cb9590d4d7c00abc94105ce81a1911548de4dc7a494d9f64a3ca4aab78ca04f4aea95a3cc63d148c1875fd6349844582d866863abba54354057af5902d02dc5e00c36c9f2dada640a4aaa9cb60e889383013683c02f415790617768c25d54dee90d04c6aae61ad9d6b5c8805a0b21d71f0120a58eadc6c8ebdbe86ad3a9e181b5e45cd755936d6197b9fa88c0318ae827c3915769ad2aef2517870646a32e2eecbf146c6b5cb60aeedbab85e3c11aa1cba1d300da9678b8df06391eb8ec4e5d35c2d4fcbcf55ec5251a5320f9d7390f7f0db0e5e6aa617de147824dc39d382259111ec8bbc27572c8f38940d7f88a7f3e762ef0d0aad30e5f93f26b218c801549568c98227fe49ca0569890bcead820b907bff0a3e5320c15ea1c9814a5a1195152cfe1e6c841f7aa22783c380ba01a69ea89febb9bb687978aef926261d5b7034b2ca5c9d8fbbce80afc69fc92763ea55cca9d28ce02695f6bb7f66b269572c4281f02587211a86f0b8d209aca49f8799524caa7d71802594a1da20d6abef514f5053dca6b790aabff4d57671644b4eb065c9166cd929f03c9ddac6e0db73118e027c76ec935d97764886bad8a43f7449ca10b4b27943bd60830c67b827d75a27159d41bbe433acf06b7ae966063cd2bed69d7d5645fc1ea56b0d8a1b9783429666cc9cf50dc7e6c801e0fd00c6858e7fad78db8cb4316914373110a2c6f00f1633ad0e69c8109d8b2401d77b717e33d9ddd078771f1fb0bbf09993ffe997e5744011b1f59d5c952673a0b721434c4e7717de01d122c54c7199aa0cecbe5bf8b8f19263e9aa591b9e7ce0c06a089f3d733cebb4c26bbfe3a034b1412d4d32261b8bcc4814eb13b03362bd8fdb4497fae438548c882ecdb0f36dea2946712c20484f93eb3c8dace99625c16fb2afc817d459c4a1c97ec50b0897e6fe0984792078d05777754f501f3cc10d3c0239e9ac657bb19723df8a70a4fcea1cbe7b895d75a7d43720dce7d7d1a4a8c3c9dd420a83b4bf8e345ac8105140ae44a0bc5bab315906ea95aaa87c837a86bec459ee757c0e0a9ac02d5c9a8bd4a1f8e04c99916744a666812abd5a33fcd4cd1f74acfded81b9258bc3b0e7f30ae79ee5bd95eb2c533a557aa2e0e81b52e9beb76cfba44e7e7c91d998da92afdf77354662a14d9b83b21d01f7387e57025ff2b21b481fc854f0a35d92a12aba8f9fec8e2012e711c1b640a026de1882aedbb790d3e5f99bef0e04cdbb99b807fa38799bba383d5918a02322836f87b1307309a3fa388c1aacc18f41868910654aeddf69e6f385dc835bc3e05c6928facae22722cb124d349925bc7172f8b3aaf8c4cecb57148df03a1fbbd44709ac0b65f1a46d880e94e758d02d539b6c8a6829db38145af53e8791db3b6451a18d8027dfc31c1558a8bd79412d5e309c2d5d3bcbc8c792220df2772efda160ee13eee991d17be4dfa0ce71a3288f424ade211a755147df4759f5811b3c1a566fccb479ff6e559a8453f83fa7900c6527bdcadaf052f11c216689cd1c2bad9dd01ba765faa08d41dabcd749768f7fc10e0d44541d01a29012a45df2925e5e555c8bd9384dd998f5b015318acedcbf8410b5bb38c254a4f243a744894a52d4996aca7b017e3bd74fbb098821d6da51e833bc2dc4c473db1e6f0da0f366d3fab8bd323cc6237bd1e599aac5237662df5de3a829d1373f8a90ea9ce465228521ed183b5624f91cac50297f82c96d68e6a4a28b692540ea799f3d4bd873aa9615386fd0da98848774fa7b4dad9328c585717b3468dc94e91f8d7463597e38fd8337b1a99873b7c97f2b896c93c4f76fff13fbbf57d7f01192bb678d3b67aa9af4f2209a13003dc5ff1d39d392dee7eb6ff0c6617fdaa1d2f2ce17122310b5d459586b6b9c705f7a68ccc6cc77fb83a54947fcc226e465be62b83e8528b465ad35638f1039d7612e56bb8f76994bb990f36ae48174df0d146479c3953bf8ee2179736cba0a252069feb4091894b70c168065916778682412574a758e28107b56b1953b103b226c09080d046252b8a9d992bc12f162767ab0ddbceb43bc64a693e2c6598b9ff3755421b5ee15a17bf6add719d6de760a60660dcc77fde8a7349799f84eaa4a737163f1c7534ef6b972e8b26f1b531fa0d2de5d6c88d807bd0902da3acb2c56b669cef94c6bd1131a2637c4d0d60eeb4fe3779a1251a087ec699cac92be177b299339c13597c72dec2025e5e34d0542f455427a59731e127f41cd737c8eabaa18ceb5791be762f2c172b8333d25612130ff7a166904810d33e9a2e96b9d97894c4f1f9e29b7e2e93fc1449a0d0504cd1291362b386ce8dec4bab1d2145491d9de9099bf6ee151dfe79a6d46091cdeb499f956e75e43384018533dcca5fded5b4cbcde23b6c2692a5977ac3d601fd865f0398c7835e18b9d4fa52ce0ab80ad7038b1ac311b8ee963c3d852b0b4765d7d355393e671deb7053dcbeca167499beb1680704cdd829c8f76dd6ff10d1454fe5c733d2d3352863ed8e1804271eec6426b499e278f89f4d57895c5b17c9e6c480a19edbb01458cc7da4c2c88fce279b64eeea7de6bdad183add000bcdb22d5566bf0e0d2e6fcc4f9019c09d958fb684fd79dc5f872c2f88587765a0191e201f0c94a471adabb5a367cd4ab810f3ae660f5c1c86be4ec4ccbcd4a49dd92b32461a4f9d2de5be6f8e7c922e7a88070ba6b1dd502bf309520d0dfaabdeed09c1106976f879a8a9e767050a999996c368639ba21ac0dee3e7f111b94bea261e047f5528bf6eedf71218055a54d884d854ea3a1ccdf0c4360ffbdb13558f33a807fedd1dde0116f6f295c791818969bf0c9a27dfe3eddc131b6c893033bd579555bee958ab04ac4ed76881a1ce760c554b87a808929daa95f42a2bff9b1093d0a2d2181f43d870db153241db5fd2f59308eff7c055fb6800472fc257a9a2aabdaa6208d2397e56a71a270423f50b765b45f9c6e1430971aa82371b29c2851ae0c9f042cf9b780d48c578ca60832fbb104fdb74612bacd5b3e5088f7cb612b85d55aeffeb3a966158a32c49cb7474b5d0c24e967f484e8fb4732a01800999bb5e14013ebfde3482929695808f4edd98b95e32e5ede91819f2732a187bf590f8e72409607dab39346f99dabe2352f9c54c65c4aa8dd0baba998b46252085a9f67c40db498adfeddf441a3a5b1cb1e42ff1a4234202e7e2f563a1589bc2e6c5e078466d9af63cddae2daeb30b4476e63387df74f7181733f8b6fe5de9894b9d8d7a010e75a7502dfa10c3f61a2f2c5c3d7ba3c256a1623e958184962374561f0e590b43527c7c242cb3f1895213ad539bfb24f2387d31581997a50d4ec1a8b9cc150272e0bbd3c10fe62fc33bee23bf77317c8c034aaeef39e0755f01f42b7f0664ad481ffe7cd6346eacecccb4fc596b08a2b0a4666512e811c4f7ae815f335c4066e00d50deea9add6e79aed538f58d3dc72180431b37a52b4f5ffb4e7f76d8c133e1a5aa85b413f562196ddbe29c9f9c2ad2ce4f0b81b39a4940f0f529d0a7bee944f46cd14fde697cbc4af2b3e6fb3c7cd98effbd3c56c3fe385a4dbbf8a9d75e1e05a6200d15b8f365e65e80914919860ac5449602c6dd3c3f87686b7ccc27853d2c6b1754d684c6623c008668c12a2cf2d5197b411c593c071d82ee71f4b1079302ebe743c0444f4b6dfafe8b299e8dc29333bd3b217c159f61828e83daf780c17b0e215123038e0506c8e5ba25c93cf79494f9955174bbf1fad0b880afc073c2b4312cc9a865c844c13fef79d8afed8b3b9da67db519593595873dcc55db651b95a83aa062b6458591ff95a29c219f052b84dff85146324200c81e84387138add722a0af466e0b7d8747fa01dd0f254463b5ce32e7ba823f6daa9e77439c3f10717c27565554eed4cf571481dd916d470c25a14c26f25892bdfea70c62fc551a390e6e4396b9d4854f6d25c83863d23adfcba722d81d2571fc6b67fd30ec3ed0ef0398e25a0988239e644272401b90fe4e8e2a1e9cc11b2deba7ef326f5fdb83bbb647d8948ab65593d6abcb73ffb3be48aca0553af34cae13c0b24d0e027e0f2d6b09574c2459c75b736d7dc532e71c918c92b38d142c6e048c5ceee486348d71a07623679544efc2d0dd6db1f6d856d760aaa0f4a9699ab1208cdf9620c2a93e3d7eef3cfe28700d787a49995c4d25a55bd840fffd93a795b563f28ae005b058c35aa088294d91fa79998738dda00bbe9c470130f546c6e72799394e80fb37b8abcf8a609e1ab7492c5ccf87e0c5e17221c8624c5b24ce67e28fdcf70914a92459c3102d5f54d1d2c7b208df5001f1353b7003e9bdceb5f8e1a1883756881abd38b9bac953829a0ee197f3f4e5e96be61d1dd098268260e7aff350f231f9f887008cf82cc52f3891faab7376225a266024b7c3f9cfb76a86bed4cf98949dd913e540409c34f5295944df5e015cc763743a15d6efedc5cb4521ac4278ea24976323d4c0c7cd0bb74c348df3cd4867f684d14e1a1d79a69af1021db59512193d39ed1ade2ffd7713dd733b138b94d5b70a029f48d21c513bbd0851828ea3376a5f508d00562aa77b1ebb7c1e459d20e9f33c656aba9793d461f537afa20b401b8c9e0df7324e02a3b48c8b82ebb48855debfe31ae97155b5c33f3f3ace92e966d28ea1a3060eb82b9a523c11f263cc2a2b9c0333220a0577700a935ee6f654674fbf160ff0e4c14d8b79779e26f885e61a6aa095773cb14f3450812e604695f5f655702fd255d639e0275a35dbc239c61c83fac71094934e32bcf97f4c1bf9e4d7b9ea9ccbdbd291ca01b289136220c4c21b41c2aee51c1ad8d5dbf2ec2412586e1351e6233bdac90e7009d948f8bf5c08e12d107563668b2b733e66cac6ccf6ed2a75a017b223261388e811297b29c87168b61ce5d09b3b6ddf545d44912d5a8c1529d5a10079643da5f6d1b6603cee10d74c3234c006e8d4210ebde756787422bcb9de1dea1ea7c0d4440b4550151e3fba4b0fa2b62e9b31a4fc89c50fe8506b44b150823eb165063f50f6fa0bd6ec156ce4a669669e4cb460272d3e46970eb8ffa658164fd83bea3d786579e87b82699c903e8afb95add1a2001c851226083f453303f8a9c76a46ee333421cc4f7e8f4d7b87c66ba095c66f9215a6cb81988e47d18f938ffcced02d686f3546562149a5f86a3e0c1fe0937a64fa4280b02f6f430295ecfdda728c8c9e43dc91c148da8069924d35b5d359ea5432e785a885434b965aacd1a91ddd5190dbdd8baba71d68fa1fbd3e7378e32590b7919cd14bd18d7e5394be7cb6892e42ab4b7261a1283be6bec16181928e3319d37fcf753ef950c949e81d67f873004a59bb3efe67abd275035e9825c55a405888cd825491dfa4e03a8bec73b629e1b099dc3dc82218126525fa16f973b5934de51be848e6531dd783993832d6e820d716dcde4028d1fc121865dab5747acbf71279877065fa3bde95e26c91f8eb0e29cb0ab608845209c1afaf48a19530d84de6b994e253ab30974cfdec480a5e88f0c6531ef15d793216a2dbcee5aef8b6ba688581318f9ded7928907b4140792a506a6c78fca8e3638ccb18efb6a2bd95b92f18dcb8b8837147fd33f3fbabab4d4cba34b3146fc3ddb321641eb8359f02447b5b12606eb3e98c1d52536517c2887b11bf77ed2cd0075158d43b612d3888ada6a5c9de8a91f6269eed88d3fda60b7b039aaea5c224966a0faedcaba16fbd9143ddde1a9c9755712e70fd011efa8cf9f85ad967957b7fa0a87b0534ee8dec9606f2b0d5c34eb8c1ad789f1104ac29e929c3882cda1af8f1384960b7425aa590cb58bd569c22666b5df5a6748c1a853d147dcb52fb5256b6cfa45b792618f22b0310d896d07464c158ef5b069826ba4de4deddcf0a13704987a82ef747db9ccaca7a679c9de83b131e919084c612c6fc4095f42de3bdb9dede404b98ee2636bc4b61860cdbcbd92b89a390c4b8d0ca6fa54abffb2640e42ee075e93cebf5fd4decb19b4cba6f4d523b19272a6569d4bde9fb7384be5d906dc6c435584809fefba641d757f13e946a7691ad3cb6aa2fb04814311da135e4d7c5a9f9d955be0bf4af81bc3f8d4f01ef33401b04914f4a8e9bc1582860a245867b752a4a2c4b06c160f1bee4822176a8f3b92f808561fb02ae3dfa84b6d8d5d0f57e85843e70b5b3284fecc2af66760c67b537395f814eadd01501fd8aa1d831e962f13a279c90a64328f53d73ed5831e249c9159267d7f5614710d95593da796328c5f409504c880c29783528dbacb1dead8e7ce2e67f5224fc242e81f6b0b81910f37d4140d9b8147f9bbd583dc8517ac23727879d859c5517bc4b8bc1e68d50751de8928ed28cb254a9a7b05a80659055bca4ea59d1dc2c114c698ac8a8de81b87a35c1a641e22e3e91a90a442c81b5aee5c82060bdf70c01ea3b5bf5f821b08f4338b7a4dd22fc4938c96f35560e6b78fcc3e74ab83668ef3b732331a189dcab22239bb7e06091a9ded2440a45efce34e8719f7863e8c793608f36d65b6b9fcf7910a78a82f446eab97930362a794a28853850323df79672817a3c13cc05c514062815bf3393a64a6d7fe9139f035a2f71524b45d93c24d4ec778c7f062b93d1ba14357be985b01f8681af51ff0eece7098f63f7b9a92db253e635af2c39d5f2397582b0cfad33ffc9f5c098067cfaeb688ab1b7f58f355646702a49bd4f32890203fcc75150fea985b8d43ab6e6f8cd4353af21ed8f4771d68b11f8942eecac03244367c83d0f9a5c04a6d76492db9dc2d9af04e4fe5197a9963ea55b3d1f86913b8a240a46e5e6d7eb8804a0467998c97e1b681f39a017b18b57538ee2e444a11c1bd03242ce772708d2b7c569d60e582d9ebc93b35bbd15cf9e80dd95c49de2eb7acc155f72f1894ac539e41c284cadeaa8ada60428877074f756f9829efeec0a96076d42ddc21db6172a645a93ecd838dc3b2f0d466dc86301873f3b41fff284e13b6eaf7f11b469b7c95ff99c77f92d199ad27bc03b1cf6823e093a4b2a5a41fbaa356f9cd2f6aae31019948a142db20364200a197ce5083517692d2ba19ea7a512e21ed231d82dca225d1848b65c37fcd3dde5d863510d2c7bd8999b1891d609b0bdbd1508a12dd28564a75b6808864e251fb7a43105acc7e74ee2ecee04dbb64e269152a561ee219178d00a093067b0f426f8bb0a50e1d829836b20620f5422813b5ba4aa49c66f9714a548b330a5f7019089a9d631194daa1484bfff8c996f98dc72aec217f33627406643f2b58b453f33f90e16a36ad1e24d4e34362f2dc7707a5509e956bf818fd1d40e49caddc49c53b209c0b561978532309ad63000b9cd1272bc5ac7b53596237bcbdb3b8c00d7d0e907088b83db9738f84b062748090ccfa290554a4daf61986c2f4825cf6c806423b2911059aeb7a738a86217b8e46ff6198c7fda4deb5d50e0827cc2ddc59e62f86bfcac0b34bb2e9bbb1b744b8abf274ff6d1fc7d851a893b14d5757078d7a13a6e4dee2b631fc4649c74a8a8f98069060b59d79073edb45db9ac7fdc15eb591a94cabceb4936979e7e0a9fa8136dea88c4740959280e58bb11d44a0b71cd530383f325668e24b0072dab1f69de8876367ed4a2633d8115a5808ad360c9ce12c9a16d1afa029dada0e7386a01ac1f67d6f8155dec78b21021cbca1278604a7200df5988ed579ca5f0e7f703516efa2082bbbef3de310f036c3b3343e44a30b363a233642640da338c87a996b54f50340d561e3f6ae64a10c464688ca032237589ca723b2a86e5cfcd3783d451378c201ab7f75a60faab74d28392ac9bd36d05f74ff4fb0396720166c75f49a870bca7fbf3d2997587aa254eae96e6898f0766242468edd0805516727a41ec4bec0f3940dc603cc753f0f78f8e83b467d7bb9c90eeb4bf4c2a61b68c689dcca7e34319338b349da19c96bd93554b952a1100efea701cf41031c910c4b7e5a257e112dc2a57ca0be22b49c8010bffa2e617f781e907588f5145f466e581be529b4c7b019319b9c3a7b35fa293228750de360aa141234e254d89c0d15726232f0193157748b54749b9502a506b90c60393c67115c987584a2de120714bf963436680e48a6db61a5df2682c0301d19d3fc3ff8353dc49001df8e3b20764c88eb1d38850e87509702a87ad36b73f0cfcdcc7b96a522d86b6b3b489c9bbf53f5f4727db1cdd32fbb9487bb7bca4deb8240d0c0fcaea6d6471af54e969ea26a4689dc951fbafb60ec40ac43a110c7b80afdad4f37b17f2812bd75176a3defbe869d01bbecb02b905c97ef57ee9cf7eea672a544c886bf4ca6adf79937031ff850b4980d5c9d8bb927","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
