<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            /><br><br>
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"502af6835faee6c9dde628b43d5342603be2fa5dfd56fef2e2e475d0503c39b3163ac2139b3765ebc4cd21efe0dbf64bf0d365b1e555bc92712bff41911b40d2e6eb36c36b794e650994ecefa71af34eb7a1f8f0982b1ea6dc42c94a1a771b257abdb997545b13add58967a87f89613baa5810511401b9485a6ba88b9ca6b145a8a89bf7ede6e9a2b347bd05e73c2934f4ac699d508e2d820239b12e4680e91c7c41fac6e68b0a7012498d959564148c3180cf07f466bdffe706706d4b90631ef083cf65da339391d5843ea202707fc57b0deb8e250cf1f88b1269c46a2f57bec2833e1fb1736a73e4c3432cb5e0710a13307b65f96f3224e0ea1aa3f0858f38fd8d6945963c7d67ee4f97a5644a263ba3b6a5eb2527d6bacb645831539cfe2a35a7e2c7db9ac19da33ca976f6e143b7bf0f008789b919a182ccad0e10901827f160f8a805397852abfb8fc6ce1fb21830fb12c31fca937f52a293e8c6c5dfc1441d4041c4c44335f27334ffed2d9fdac42f914e30aa4fe5aeb5d7da9f1afe78ab3a33461e7e3971d5a1c8c5bb1c36d441c53fb20110be66d2f937b79bdd3993800902be4b3e7c49dd368fbf05298ef17ba50b93fc453b59e49c4da281b141303f4d955710ea8d49b14296e3bce9afabda3b464b021926abf3f243b2bc4a663d8aeefa9067cec9e31bb63cfe0652320217712f661e7fe15678afa681ab2572f96a580ae2e632f12ae7117b8e0749157c51996cd6c75c0a694b78211c0576229cf909c9c521d3c2987ce604889f388810be7cff3b9d09800589ace8745c4699abbf3a6e056b7bb6299a0fbf2e1e65d54d594672b88d9538664fec867fcf0505304519ab5b78466d8999c05deb2efbd102439a3ffb3786409172bc31300cce5954d02bae6a57da25c3554a5bbbb08633eff49f91637e3e88de7d606138056159adea86bb6fd811cac2f5975271e64a13c9bbffa3417c364f82d6a0dc4ce447755a6e774088c96006409b36143d3838cd5fb45a03a28341dd8309b188b818df7c95ba7b95dd04f043b2cdeb9c839c780caa69c3b8d4b04e0fcdcc9fb2c50b77cfa19830c325cc7e2af735ecd3ebd9b0631b1e6647b7c529e4fcb45a77ff11bfcf11a099455e69aa2de3b8ead23438db35b5bdf86d3d3494b72122abe52b3d350696312a8776c6753e18c23bcdcc98c95d912e5f65a86772ea5d15a409518d411ae5f56ddd85de9a2df46cafb00c5e7c3b0a58ab2325f760df091c66060c5ccd88ce045fb306a2316b277fd54ff9f898a5b05b424003c34600d9ae130930c15c70b3920cb7d04fa155cb685fe6b662b150076f956285600360b2bd7fa346c67aa23f50f8ce8ec6551c96f5ed3effea7ed12c97f52c7359c93130ccda4532b912dac897e2269a2fadcbb489a1e1a4b9765dca369b40c63ec0af13f50a09c39a98229119e56ec8acc45c5577cc1ecb760aa660997cd3406c78638b5fc91cd616a2b815392787a94a5f79289d875cd1c9670a3b33b4685cbdddc66ce467d3db68832d833222a27223becaab1666189784964479a5f78a8e9aee67414f94821d19943868badf0ef2b7775d93a5a363af13a9e9d35e62f0a80f99bb5085ba786570b875fbe76a69b53423c4f217306de12f9f3110471cf59b97b285f5b6b438d7ecf12972994bf209070ce1d5dc38583431aa6c5ea27ca8e8cbb892e819c26af2e7b6b17efb4aefc5da12e883377149948491a472bf2efd8b6bab274d66c5db1935985200979297e1a9790cb82690add597160e349651b4fc9799b37e943a867f4b2033f82f873d3e5c51fec9f6ed9bec248c0d608e14b3b3cdfa27514c7967f477e44b34f021553caef0b8722c1c8fbd55374ff8c15fa33fca12fc3a0ec5937c37707b61cf5faa2fe5a15965f174af621f8d768a1796c86bc15c3b8fdea032cfb0618b101949c141e38ed5720c6ad53b9f64974d3ee96048702e6f3ad5b8f4814222c0c55f980cad8faf5211cbfaa151ad05ee02b91c67fe8d1ba5d7973f1d9c19154681e8b9bcbd223a5917d589b9de4c94cb19e3bfdbed315775e9c3e98bb1fb928e692487a105b7ca691983c1325268e61ee1699c9e901206a5260a1bf0a9b70d5a34a48fe1941f25092c28a51587204459ff12e88d4be17c9c2c87d7ea6fb975b985b77a95931278b498e1fabf0c380455202290dc25dfa938512f06e703af42b8d4907e68f62696bc8f0b92f221f532f60fcd8746ea32a1eb688fb146d24ce28039468ebae7863322351fd140a23c0da41fe6ff0072daf0ffefbb715cce14ae529b6877c893bc83f4fe5bb09523f2a82bf7beee2b69b1ed2b21dde5ce8e7a80cef002f7bfe69a10fc680b108f1ab45a9a982397a6ef2a00e4b61c7d49b3e9570ad961e5964703b3b6e460dd1ad90762a9de63d4091bcaa10f7b244a86d66bfbeb64b040fe2855af520b40255de191b1df794d3a3e7418aaa8bafa3a44afc15613f953c0e0bca7acf950fec78ca2ab7c8475308e94b959d78f34a053935e4e09fb728f31a1a701d8a0da8759e5efb5d8afff8c70c820e9e7cd0bf1f1c9f2e899f13a6fecc1c5b8fc1e4544c51ba40255cb991726977b01e220b754a828f0604ccd058084f7f05d5fa84998abd0f6b9a54c71dd3290aea50263075a4618e066a4302b28242c849ca523770966a57d67c7f3cef5b0284e7534c5769c7ba3b238041c5ae57e08648fdf04247bb8d58c2ae2ff2eab995c3aca16a389c520a9c7db980309a941d49e8e4f4c7d7d39af23270b189c86ea57fe29bfbad3f2edd8e20381abd56eac2c5c98a1513bb60f6756c0b1750038ac8111745017402b97bdd3ab18ac7f4aa3a6fee9df3aea91347601a73f8ff6d396035c13465291780c0864877c70050d6d7378602c9d71cba6779519154e76b52ce7c93ca728280ac404821611dbec1100e7a68d8156b719d703332c5be3add23645537510f05f45f3b3e6ca77a2a210d8e496d6e4f8ce916a94c8812c2fea83353ccb01822f28c97364b8dceffaaa180cd9d31e04924db67251be0573b892fd14a50582e4f43d3cf1c4fe91ff4e4aa485504b7183eb237ada3b10a84ab2ab988e10dcdd6481ca6010787aa238e62c51585d4ca62ec574cd6d98d78c2a429d707259a0ce4a9aafd7ced70bfd3e15217bb03d524546d4164963fc1332021e1fe6ab9c1039ee8f503f5c124c06d493d943f8fcc63150936ef1bfe72db2da0e977d5163b978f4e3ce7b4bb7fbb13a573b2ab6f67da0f04c1ff44ced0906d14b04f88246168a04f1c45514309aaab64a172d4c53e1c09eda94c25dbe426f20a04e67f74bcd568cef8c34b7deb7bac973270dc815b6d6a535c14d47d8146c2ae5f1700fee3f9951867cb0c6300500c0fe05b0cb885a135a80b57ccfb9d5339a14b3808fa01a6c1634b1d84101ac822a4b83908a0acf16a622fb02fa2f598a8fdfbd14c7942c19d21392d7839f164d928dffe00cbbca3637c57d9a3d078fd2c6d0e8f0f7d259e6d492d8f43906ba9fd3346695c9eb77617b1bd1ed98d242b090f2e8e7dd55e9206d8895691b50ff206b65f0d557964bd1ce76671127981a214c5cef893758c09a680d3017ad71567bc9e1db928aa8251585d4bdcdc03414ff1fbe25b055acf055ea84870709215d076cff4e5f10ab8cbea6185dd6c06b6f1bc6ea217cfcd050b40c01fb6aa638c4aa0ac6be90dfa39c4e16231853cea7440fa017ba5f482c180bbe76a5e81f6056acca118048b23ef34744a433227587c06b412314d70a81eb38108cd8a21f111af32faaab56e76d7f10174a8dcf99878b85fc146e1045cd6e47c41a198b5e654c6dc955764dc508cebc074f5ec678ea31fe9fd231765bdb80c492d5a07bed1a401edeb97f653523ec491e952d5443709a773a0e1d82a45c81f0f1dcaa1c35e6ae242040dd586bec088c15e2f976a94889e65a14a799adf2b7ecb52bd6988f268680dcf87e12b8d6e2b1db7d600ce71a2a24ce83a5f01f174c0d88a0e6471a920792e951712c2875df5287fccdfa2a461afe25ad53deb4fbc136ab1743f6418c42918ca956b1705868beb2fa27a350865080529272c75e6d78ec6671236ec6b96b14e33762c3a20e75cc41fca3034ca763763215e07fdefd871068c1214728783b1c71cbd737e47a66c0d1e1341d2ac7c3f115e6e65f4c7c7434cb90a7c917a9522e75bbe93b19a0a687eedccc1692981237256ce41d7f23a9793bce1fc48e92a621e49a61b6ad557e8662f75aeadcd0eb6102858718303f7bb4cfe5307299f9c955dd630e580a69cc724a8a90a19f0615d5618b99f050597a2214be9120b0f92e42568d2c0f4341eb3681e2aab782dfa3355fa4517041590441c6903826f2abfbe0d9ce0bd7c97aec4936bdfe3bbf16d354d1dba41b73490eecc91aa095f76a5b5720c31ae0e597e15bf3a16f91a746fb18e25c95cb648768845dd142eb742fbd9d152d6a5e063fcbbd395158d2c05cbd46e1c8e73fa7a22178294007e234201644f3eaef674b73c814f2bf0139ae5c949159410e575cf5ec8e2a636b2c16fd3da871ac377598f8a078c5a71d502d9519f84cf12f9674c40840cac3b12fe0bdecc5e2c49684960aadf076308c9f0ac4a33bad8e9be40b31bb28bee09cf03c7764a5bbf573eb511a8350edcd622780513ed694995adedb5812f63e22e42ff4243c95672abe4191a29463e501de727f823bac88d5292e51318b6c85ba9d1271f3e9dc04d6a5176945ecde5d45fad4c3652751b91af04e948820115ded0e1e064d2b95291a07c4e74f71580750e796561517b7ff8a348bad0aca42b3ff4a3aeb60a2ba1d9cc3ac9342bd0ac8a03efcacbccaecc3f21cb6d6504c1796ccec2d6d59deba34de07965b4113756c9c89c1aafc13d42ec122342651e87256c1e3c91177c48548d5d5824bd8a1acce4b8650919d8768a31ba528cd113cf286a34f22a39755b72c2452e73bbe8fd28c2b7cf3334c50b2157ca8d2456ed9dd4883f7ef2e76d971fa810ef9d74cf703b8c8bbcd97aaccae10fc6437421433fca4a78a306410fddb07f92ff7f80daea716e7eef8a28756e6d5a5b8e7117310c8e544136a6d81bfdf0c1c54a7b349fd2f0b542e389d9bd17525b075512d9ac393ee6eb2abe70b2ebd22a186608bb7081d9781c40ff51ff8ffda0459e9c614bf36f5c846e6a68ae5f434150a82eba1f07b53ce3df4a536a1e2adac9384f33bd65d84b874bd1b5b7cd09ad0930c2b6213dcca62b80eb9dcb3635d9051b01518b529f3fe71b5dab2faba70a154e2adc8bcd772248bf1943ed659c4d8826e4956e46d49887d8ad92c83670348e17f7f79ac042cebd074322255838abaade5da89814000707360f3f3c7ce34e81b1a81aa05969cd8c89b9d9a5de81fc43626df052d4197e6ac23c964045a761a0e26e6b9755d7d373cecc7b6512bafd714134d7e87cec56848ebb8758b4d40c7e5c9b4b430082776456d4608d742d9fc97c6c46a3213ebb1b569e5181887ee67c714bdd8c073708669f5dd8909e84bb0792b6a7fa07f450d8eeaeaa280db0159eda5250165b873a055793d1706c6e1e1a20bd0fa98b7866c0c8acf9fa272b830d44a34883c27ad50b44b2335ce9e452f3910bd3aaa4f87ec47886e317d15838d87d838bf8e8b0222de6081fd0c1404937b94893e55106d358ba8f0547d4cf12f6218ceb89a59118d1045e1633baad8c02f926f9924dd24dde6314f0f56ae5b82fa791716159d2b1addce2d6efa588a13486a507902df7c41d5dbdc0268db61870a78d0bffa0cf2505fd4832c65c94252261493bf605a38fc2b8bcfba5d7c77a70c55e62ccc26b7636a6482ea0275f9d06e9fd4a9c302cc7dab58517c0656c15aa6db90afe327412c5ce7738298854461204e6912277bf71fedc8224dffd0a552b41c79da06319bec692218ebeb0c6ab6e7b9e2d71ef2831e336d978694969a4b205994a3f5f8936471ffa623ce7d6d1ed1dd0c9982a3fa6ed8880f96d47b2687ef6d487dd564b58a2e76107ff80730313556675da4aacd3fcfb940bd8ff1e437b1a4e8526fa8bf04645d1cb3528a1f67c35966451ecd339df76fe8d0d9062b99a4ffdf0577782c15d89a496fd7c9487b72a7a23f8bc3aa2fc24e218ca8ae2cf44e854ccb05b1e8fe79e3af8f65ad9823b24e9bfb1c28cbbf84d2b829207a0d38a809ad6d6f7cc3a3b8b838e4d541f6d7548c850b01a9a074baed328c3254e1b9cdc396468882bc9738d23dd9aeb55d99a427cb798ce76562ee71d5cf348a90b828ade845eda0f212d9649b93124812f72af79732eeea4b8f766db962f9ebe0b664f9edb2d27697c5ca4ab9e5f6c8d6258e848e8c2ac74feb2ebbc890dc76e2af66b98ff79ad739d0274e919497a3ac07822d6bca68691a1662bc492022d515cce8ab6ea6ad91d5d96dd12f087c5a70221d4439ebc457ebf3c101f1b45ae2a2deed89683015f871e84b1a4d7c227d782a651b14598b45737f4bd6861318837cf4c25626487b7ea25873353532512caf4016df476902d61c0db1a89427ce9a712c76916e331eedda9a54c33b0a3052f5e2940f90eb117c3fe42daface291d42eabd4afa7c5f0ac09eb6922f059ecd56501a98744596d4bf3e24cadb7bae6bdc28912cea6ffbdd56e9864c4581bae7a132a0c02b29c52588ffdfb1edb7b3010ada17dd9c454285d529021ad5cf642fb69721a882a6b7945fec72bb6f563cab7d07c1a723d15ad826125a49c2f5b57ee9f73a7c01bb5aa1411933ccbfd0c3ea31dd2dd3187f3b00e8b1d79c08dc0a625e22d202cb50d8d4d05c631a46428eb480471ae2f341aaad0f8050427d6866a0ae38c3a9ccf191aca86e886c9da770994cee1b02daf9ae7ebc0be0b1039619bfee31b216834bb189580b4933433ac0979e905d9bd75611f9314293f99d292d972caee39fbe15899f0aa6f33293d1dcb510782b9281566a6810413d605c6bf5204259ea6518520bf73034d97e98f05d0a5f00e84a5dbb2e3f887864dbaac9bd4edb127a4f8505cb2ff23c748735c90b9e5f878c457902440ae9989918659a902838341080d0b2ef7de1d3f449497a93dc2ec577156698dbc8364cad8944042f1481810f9fbbfc559de118024cf019ba64054073b7f2f3215b20c5190fe69cf6072b4408f935dead4d6ff70fb6e3fb88f94624ed354d565975245d51a911ad85fe538e7ac6db67614dfc16ebf02f9bd4ed77802eb7e8edd4e949864b9cc525b80e34ecc1eff5b24613b7c1d883d0310a4503c27cb0c70b24e9b9f7f5474fcbb6d32dd60b78fcd07bbca51b4161379e10c403cb33734fbc8462d84da277a11daae3ecf345da272f108c35a5acc7987374afdbb1d12b4892bbdde83e1e8f4a5a062f692f089a77ab92ca40ca18d7de3263d0bef3fcfee671eaec8bb44190080aded80c0438547a27f3a72a545d6c1311bf06aaf0e4afd2dbdaa2d6fde4283a112f78e815acf793859f33f844d667b16b29c970a3061e18c66b4bc7d54b94de2e317aca1b5b7b77213a5cd62bf6cce6566a0c2d0c50188572cf7d1853c486f7f3b8eafc806eef23015e8614640ee2105786194410e52b7c339625859fec5a3dd01b99e32236c224e657f8782d381292c9e3d02f6be7e2f8a746431c4728c17bfd3645b614d8f4c3f1714a2d7fc63cbe8cc3f95105a8a444f0d8f4c8efe591cf5c6ee1fd011f812cbf81ab25dbc6522f728d065794ef09f2963fd35a71211751e7efad9949b20995f178f04d3138080c479175408344f1a93d65c1e324e69d86e43e3eb14d5f9cca0daf506170f9b211949804d7ae079796b1212fb1302590db60211abc0f465ab13ea0d4e97805d3059aff51f17d7634b3b0eba90c080bbcb45b81d32e21ebfec6a1e8d5f3a09c32482b640344803ccf922b06b36f22411f15ba97a0ba765f48e5150451d5bfe6dc26de8230dd148b0931de33fdfc04214b1fd08a69a3d788ca5114d8a217ad587c85d92d882a0e7ec3dd09853e3abfb6e0c6c236bdb287e3109d6a3148f99cd9c6e1f5bd4e8243dde88767dc16bf6c3d80c0caffbb28d3b12c3878a0e3450c050aa129be5bb2112d2e5596327025012f1cf33037d8fef74b068e563c11856fbba3d5f157d929d766dcf867d6993469d560d43f528c802eba3c429ed7957d8c3da3cf754a53461bbab1dce3b2987a0e05ad28934708aead0167ee806111ee49a593058c9c1583c5ccec9cce29041f783771f0bc7db3025ee6317800a0c87da1d0e9b90a1369fc4cee06aa7b9c6b872af25ed5f92595c9edd17662f49c97a68c1de7b03858aae5ee19e41ca8d0ab05d379c6d629052f51452fc38118b182c9b0df10e668ca316e680bda98549f0a227b2ba678b86bdc7805c3fb0d33b130a7cca01e829ccdae73e129902d38c0e3ecf493a15507c62f9bfa543120732e3d6a4fd4404ab5d8c5924e2be690af7dec619baccd76905b6b979c1c094ea36f259e883fee70b40aa41ab289d3a18171dcbe6a31e3004c871309cdceb030a1a5cabd8dc3c7639457decbb7d6de38544766d2f507512579fd268453f84e24194dd69c3ef8deca92e8202c7e31ebcdc7e1b18ccabfddb58936d66d384578f14a89239ad6a7c24bb887ddb395e18a3c1512c380d3b148c7d00db0f018d6c3218b6d2ddb5b68b4e737bff469c4351fa20bd683e3e8a2ba2dc6574674a870ef6a9d3b54fd5220a4f2f70b00006eb9c84244496783954b4c01515f0258dbed939bf502cf941f01e75517951acdb6adb0c1f3697c4f1090da2aea1bfbb2edde4294de4e6fe7e279e2e4759f50a5e9e63d3193d6bbafae6cc4d030144be8dc3e5f5e11f08ad4f6c118b8fc281fec0d641dfd348e38189b8861d4c841d996c286f3412b3a24171a879a8653389948637687a587b94f99e2847f0f46866d065c28a3402c536297fbf8179acb84c245ebaecd78b92986943303546addb6b78f7013b1d0134f013134b3cea4f723910f28642e9b2a9e2d9c628db540f1753c393b5681834939f59ff5f2686a0df3075ec4c2c5c48c491cff6404ec148493264cbaf94be4993b3bd7b76ecb4273b93ad38dbee2a69e23fc4e63ae3a42bd84b403a540ef633352e655083e44275b61c9dcb846a27990387c2c76489adec299e6a0709dc5b09acd9bb9da5807d9b6453ca64f3515ce9a766e56999e874c3ff2ba1ca739cdc61ead12c0c7101b3746fb53f4ff42a44bbaabdba02a3bf2c39a9ce7ddba6dd6cf11c70b81ed99ddb7f85cb8216a6893e43c9a2346be00aa879d977c6685c1a537a9ddb4dfa13221ced50f7861402c75f624d74a19194c16cd101f04abf07eaf2671dae3bd5872f96358a6a9cee219598ce48830ff1150f8d6e76682786ebb8ea8ea0abfec390db52a23a0558ef9729049149480858c00170d74d6cd6684debe2999487cfca85fd6b944372d3d4f1e8653936e250296f3b15e9a86995cc6de4d23dd09534c2fbf825a6b7fad0fdd9c60c8f48e5bb13dc19f58b477efbe46fd8886421224d5ddb37fb955d2a2a289d5411350e268e46879af739cb1f66851f129c101766206ed5702f9c8318497d1024d819c1725df802dcb2b6ed846b4a2f117188efb9cb51ad3b8843ccd0cc05a046bbf3fe53081ca6928e11e8eac26909f9936543c15876ce2455c06028377602947817db606b717ad9a76b9794ff2527494524c6c3e5097f2f5869f65529620acadfd1975c1fe069bae1da40d1c48afa09b620d1d688a730ee8201e7d6d1c157355cb526a9e1a5dccb77ad990357d2b67c59a040af656d45d9c9a0261a04c6cdadcdbbd4d8db1c0c48ecc3c3f653d22a9fae9adca9605ebae56c7fe7970b478b3de0234e491d80dc3ad3af2c2b8ca4702f15dd1f0176beb5121ed81e926494d4f3608609721765fed1db030cad3bfb385326ea252e2150ef6888683becd073ca4f9e58c96582dc76975675e0e75809ce65bd5cf3d77192d7da0300636572dbdab2ee7ae788abe70191607a28c396362bcfbde5beb8bc5f437898af29bb78906c934e78ebe330aaaad4ff01cd3db7a829126a7c2735dc8baffc885301446359ebe9b2d6aed61a15ca585770569a7fb12479248a687d75ec8f7e1f18d63c2c884e8555207a4c1cbc7c7dfb5c23950c6f2816141bf82348ed1cd4ed325f62aa04ea9937ed32f936edd62c0b62276b3a20584ea0cfcb18b6aa1a29a655ed8ef68111f37aed358d7bfd7a20085ee9b54b0d9082e17285473d100f986283bf4c7ff0453423dad470bf7965cee0c5946460e1957a73830bc752a727808fcade583962d768a1b1ccac8e3356db7564b0b718ec8be6c43176e224d86bc0e9c7235e029f171319e2b5f59c746a5fab50bf551c387cd57958aca452309caa00664e4b31423a0d53762c586eba3d3c7abe4034858f350aad6ad5499d1936172d088bf67764827f5d0a58659e3aab7f60c8a4c8740cce7f33818a53cb4fbc4086b74ac839642d5ff33cdc72d833885484967d674add51b0bd8055a7768fabe3d21ea1d0bfff2c986180a4f54f3f6045290c06b21ea3a374bd82fb525c2e3e9355083176c3ca178c3531c17a747b82382272274442108072597e96192511fafed9d79e02218340ae9e01e057c13b1acee4f85ce395a0914e76c806f1eec8202888a75fbbd7d3365a3cf27df180178055d49815971420969552892b68d571e1eeeb46ea6398984e941ef1fa1dc638f709b64d82de9dd29089b94161c340ae81e317f84543a03e212097ec83fff911824234bab68eebfeeab274c81d34550706543d7b3f7698783c329062932df2ccb6356993e130262d3177481ca9a4974512f0cb7a088e9e04729039b3da3b6dc88041883b3f9a6bb16a3a80e83e1d4a474cd47eb459bf8de596260d97da84e6b223aeaf3b652ca222942ad93c97cebef05f8a5d6f4d3b9df78e2100f5cf2d84eff8f5c820922db960c69707967c2fde922cff3bd1e3e23f8ea5e3f3975367e0ae4d58a6ecf325896612f009645f82928bff94a7b8d80b980bbeafa373a96b0621fb1b1d605debe5740feaf4dca6afb7e251deb0ee17644e6daf2f7458843c445ebf80f6047109946c0c6038d8f8c3e815df6d62b629f8462f70c00cdd4756ea4ce4dd7fe80ffa1bccd5e96f02b13b40c616cf66afaa19dc7e40903747432c8085bcab835beadb90229fad42838c332a5908b7f28cd3f4b0956ed10b7f2fd1c339d02200578722b38b8745329b2c355fa4d1bd09c98f1a28310d8114f9742ebe59aae37be45d28675845f234d335c07d5a658cf423390c4ea2e6dba00ace5b362379908c9315af35c4fe8825b362059508b031a31be5029ede6653366ad541c3f60112ff790128f34e9b50dccd49e71740233e87ab58168cf752feccd47d9f0f53b451239411894f17f0fb990c4e785b57d397fdd21bd97a3760ac3f16444329adb0b98a42011655b1a141fbab055483aff9ad3378e11463d4f6ef19c0023097206ec738ba60c508c8dd80d274e9586dffcf5efc8f2702f13106d1b10eae2ed6f8bceffc28f3e3388312fe7b5a18a0c47cd71359a248ea4156ce2faadefb0646102a46ac030712c48a273ef9e6f55755385a5c7dfb9bfeb24b3c86bcff1d8829bf16bb7198507e85dbec70655e9ea22fb25182cb7c911f403ed535f5a730631cf8b4af377caeca0583f34085d8e577713da3360cb7a97e97a48023","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
