<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"183df76467e89983f934ec16dc6567583b1d5b7a475135ec351d1c659eee80ec9509c3c5bfac7b68d478edb0377e7966f0edb7f9448d6be964f51d46d3d1c41577a599510c838223a2179693aa42adc8f1ecc27840770c1397e09a144869a937ff6773e0f8aa1db1690bbe4a52800e75865c6cb3151daa1614266201b6d036299e80917327bf9ba9388e4a5c1972cb3595f13848ab9215dba749349ec328953e89f010e4018617b43c694156263c46185d6316a165135426fb0f49468784ae4490da5b0d123fc346e611247eea0a11a5a994f61f2dfdb20974ebf9dc78db3dcbb453267eb4583c4fe107584d77dd9de330c391a573e804a10411bbcb51021016513802f65f09e10370f0091840132893970cfbaed577f0a7221f22d44ed9f738d606e912678b6e54b378e8f162a13f84ea85d79f1f37466afaa4fdffaa79b1be905871ba17a89852b9403d71355760511714626fd9492652f67367ab0d4cab9b7ebb985b63759499a78d5b41853dab7a5ef70ae8cab3df9ae539db9e450ff79e653ea61a6540cf1d52252945fcfad4b4c5fffb1fa683fbaee5a24b799d4d8893018d6d8a9287b7d6b0c27cced7e8acd1056097e20f93f37eebaf4ce593d8ab7c8d16a66721e9afa096944d3c3c7ad303adc88764ff818fc88cfadf43cbac92e8fcbde5835e576409295f3ba1e3ca934016b1dff9b9b04cf1495060221fb0f8e34252d6abd248317ff5004ced24ca1319f2e7b8c6fb3b46c929b7e1ccc9a2054d69e0f6054473f8bf5afbbcd40a107c57c4f80cd9f3746fd3a83e1c6df211505f38fd4602bf69cd9e4f78cad0346a76caf4564549b6353712835bf4e684353d7483c1020dc9594160a3ea495fc6e3c065675c0957471b080a024b2cab40e4ed513cc170f13be8a5f017408b36b10a9ef72c068dbc347f05485581975e2a431f907ee221976fe7da5abaf539e8ae757f25d9d0015ebdf52f6222dfe896162275d28b3a704dc5c000eed070a1599b1e3513fe230ec83c292d2a70875282ba014f33dfd8d293118c6fa6624ff97059f96529762849913db054d7813e66d8d9847c87a3625de90ebc741315f7ac772eba8277a82b8cf307bc62420d779e1569cda9b9f5007ce2156732cbdb7a40ea507d7de3d1d341a5303eab90332a464b556615c5d220ee29d512aa484f5fed761f4841a8eeba553c3a8e309fafa9acf547dad73045367b785b7e883a5d924273baec8a68bd7552eefe0e5e44855ca10eb17e3710a67e7bc5e79eb51f807a8cf89c37117f668fa9083a436268674ecf8e18fc6b14bbeab321e79c5270133707a2092e71c716dff2ea1003f9ece034330d4dce9e005394557545f47710ee99d5266c673594c3668b0be2be0121c1caf13882ddd80c02c8229015fa2e9eda250bdc2bc6117c68c8480ca6e92f0e637bb68a15d186d52fcd00da65c783c11052feafd5fe4d50eec0978718a0e85dfe8e7db2437084b7ee5c796c52745b8085bd7ef2b68e9136357e63917b8d34e3a625c0c4dc42971ec898220404fda3523f696031ed8341c1e85e80562f4b08c94833b25b7ffcc6f677e9e27e524313f2b6869bc30cb5a89ca36af2452cdca39ce52a860b62e407ee5d1fac25ab5d78fcce11b6977061e62516787a85d4dfeeb96e921af50e0e4069161c35ff5d1d3a48bbf2dc256cdf799378ddefa5ddacdf4d9a230967b6b2b815b005851d535e8da790d3ea18eb9669513a4d19e5da322d14715427936ed6016b8a98366e7396a253afa4b1a97b8e92cc9db9aa508979f90d3c72d55a22a282c2b18f56c9e40b4e88617def412341f2e56b7e4803a6a6cc8413b51c200269422a9fa98969c17cfde4db196f8a8b9cb4b8a827ff7c2a479fe9d3c623be71fdd8867e87cfdd623f780d062379e6e02a986787828dc9e9e04b7d0830d5d2b9ef91bac99c34e90e402aa49f2d4c531312f02b7ac95137bb2967f781e9fdac762ceea7eedaf290f47be93f7e0e69fee20f6944538d33afdc3600d4d4cc1e9f97f5f048addfb6abb51bcef4d600afc9c68bceca7c1d32d3701986cc00d3f65035a9b763968ecc673dba90a872f438718c8d11364d16f4d569ae96e1b05ab3aa64dff2b1d6c40913912b7ed2389453d22b7bd25d10d1a04e3c2ead7fd55b07f417efeab90c6852ff2eac3437eb8cae1d595f724ed92d36b497f46be2cd19f7a26eabe4fca6ff7f6f4f26acd21e0fc445587a1af8988675ca825b1a36069e1d04f09cf1a6271070e9e772fb5c06e562a5424a1b5749866bea3a7bdfc82524296adf54c0bfb4b537f006913ff07ec0e27a86fd6919e4679fa6b2adc45e94f208b135add98ef480bcef6bf4aa8bc5b04de73f3fc6885154d57bd6154194b732bb371191538c9d64350996a1bfc515ed7931421c69e853ee7c7d8fec163e4b96b4d1e2dcc1c3d506476bee0e2c5ba41d07fb86462e602c4290f05692c8f8a498d38956f62a11af1fc590079cfd05e873c88aa1f3958f3bd64011e98f7c949e6866698db35aa912b5136a7a2866fe6d2da8c717a39f0ee2833af7431981101278d7d8891b0e9a12b31eb66fbad2159cfcf266c959810fa82441951358b4c6ba79b624bbb8833766f0239b5dbd377b4542917d3f6a2f713e1aa1a1e12bba61278a8772f51da331f6f4d7826126f54db9514f0fa1b379e481aa5d50d191284ba26e43631aff639eae0076dc632fdc7a99dd74420e418f2c463814922dedb8816364a85983e8d6d542d219120d9e81b59af9329a350760ccae1303b2a3bf603d004958c93c143a83d3d9890c53233f19561ec0eadf02a9604bf6c9a8ef93fcbbf7eff50367ad96352eb6ad94a7a549764b22da9299d8cddb43599c240c529e627992247fad6b717f97123b860dba88e4aef02e97eaad04d36b35b1d13cecfd62d47c6a669f9353f024c10949a6223a4890ee09a5059f7460017de87ff2b1c95262109d8547688077f8381069d460ac9797e1007d5b89f0bdc748fdee5943fd1d6e8d93130224fa5f861873148b7b9749fb2bdf3bf146787f6b59ab53d6376a92272981fd5dbbab3e832dc7a75531ded0d2fa1c90c15120f142969eb2df026230cdd443bfd5ea2c7bde9c6e1e8975e48fa92d22a495d4ea3a07f265084221b2b7242b2358d544bb064a8a933e9445abda40bb3da9decec1a3187a842f7c8d5c4a62a2d6ae001a97298671171af378746c3cb36f76e2c1b8159c9a76fe8e196475211f2057aea7952ddca4b93bf4f15ebd9da130ab319323fbc8d304dda2ade65cbe1501c3deb0675641a41ad4fb9d9edb0785aeb23a36fb831257216c3841308604e20cc8211d6fe19e597f3554743834f310ae64a52d4b65254c65a072c59f4582225825f24967a2c4e086f6570125e2b9bf48563d0bbd8636ecd6fb7229b2989b0956f2ed3fd1feec7cdcd94b2ce36b16992a2824abd4ce0a0d3bb04b49972e088a4e802774d7552f7473e521e15660d4bfd92c7169e6715829b9d09ba619353ca917ba9716cbd78a18e609f9e823038282910b386dd072322e182e012860daed248cb62a48d7bb09cd6eca18dc06d896512dc324764998133f89531eec941dee6d2213e3465716e46d46b8712b8c8d4268c611867690bed8789b37bb464e871f388d4b4721d0ac4981890957f54c52db14171b872d0ab73d850a1c50057b83e1951de007da2b908fce259594eae35d1c0568e9f1a26e444dcbc29a38add57ee5e0651d927ce0e394b03fd235b6920b12326aab53841aa19ea1074b2e8aa165cb60f34c7ee31cbfd02e77b0467fea90b826a72fd54c1142051f36c1e39ce342a3ab6c67d28990569377db79c61fb68cf2f5f031525c816541c2e57c167c570e37944ceef33034aeb2f700624713db8f8b34560a8934ddc684be5df4037b8dd0ff8bd507be4831923f328bb81097f55967452b43013d18064c77ef2287d43a010ac86f6386deb082d53ad97030ecf110c5cc8a0e6f827081958df391c4f9f3b971b60299c6671926e694d3f9d01fac7a6f7344f5740080671a8783763fe17bc9bcd536b5e890bc47fa4b122bfc3bad4f317c7e0f36c8b53d977ef1ec6e54633778a5899579332f2fec05dc7bd2ad2e80d948611a1370457f3a79b582a51b974a958313ce39bcc34226051ef72f618e201f2bd07ac24a7b25e951bbb1c1df54ac86dd0960d7d7fbe131311508b2927851608a7146419f814f3867e33aec98a6f7e3090d7707ccfc5931cc0f6c3cb35522d26446dca634be19a486c4e01ea66ea036d03f23d92d533e9d8f3f0da30b165e35b8d9e548870e9605b1a8b65c495e88e42997428406f111854a4147f21d083bd4e79e8016b473e415ac108e511a3ec05b5859fd4f6e8de6562428307cb49bbd707205c9b2907f7c9b156a580e0397aa242d3686297865f24834432d331efe19f5e1ee6bfe4b514d26e25e1b84657e7d442e7d4fe4a30334120ae1995275da598090be326f9d181ae3caf2eb764984176bb18a999e199794a7045d13b08f8b8a5fe98ee5af734b4430f31a297994557d8c96ef8c61e4c3d508700038095819bd66dfb84bd10b4065c2a4c15daa43491cba4a9cd1d622fcba027d720de99f58d097336847e9ca874c54452d489130ac2ad9b830e702136df34e74f137b9838dfcffbcc784433c05427821a0df40917faf5fc72888df296e268669b8d3c7db549504342145a7b170c8af0d9cc0fe919411db161c838b07e2adb67e2dc10b76a56007df86048e723c51eb8ff5eaf960f3fc2fa01bfe9223350a2efadff70c1b969f777a996e95ea8ea37b5bcd1ba11ad5578d6a3cdef64068bf0b1cc1491fbf6cffb887f372d6f5751327ed24c4fcdb9f49d832b45db7bd6b91dd8c75f1c4f05044d404fa9c4040ffc5e8f64df4c204dd6a1c8a03895c3be03eec1ffdf5796935e44b586a52f010ec720cc6d2609dc4e539f86ff77b65012b1693b941c65c359b1cc57012018f24cd651118be1ef6b8e04151f3f66ba935960141300642cd3a9bdbd08249a35f7b3b56658545e80e143b27b84ee1fc7c65e43338facc7622965adfd356b0432ab286f90d24576d0e955dd6266d7ad383867de7ead853064352bfa4896422dd6b74e9b2274d84df31a66ad1ada2202caff3301f0aed80befe00042e0ecdb64d9156aa1e49dc90a6c88023133daf525ac0855a88ef0bcab999af2f4f0bc2f0b1d2a853ce5196fc99e20a3c9f22d5e8a2fa106e8834e9874d50e6690cca85431d78a54351228ba6051a961f803769a4c2cf46a27ee59ff31192763e23bd713a3fc8618b9d566ea74f7a68b9c8488193bcdd103bd98ea561757f1566306e3f8673dbdfa6814ddc26905ad442c2fe8868ea041257e49f80ea3350fa5a2d8c43e29b8282ac00d6eef505c95477a670c9596bc376333454cf34857769aa736fb7c4c82aecef98af4cef9147e1636674e651810c0cd0ef63d4f5e91a908e18d8b45713c04c8a16064559c6f22286aebe71ff8f3afb7995e7c82f88974d6c9ef9967b72c019c751eadb1b90195b748d0fec2881fb958acc61d14957d0cce27c8341cd0a4e15a2953dd6e352546bde343fbbd4a3257ae37e55ceebab6fa3bcfc7200ea2aeb0900dd72bd3505dfe3d0232ed5e07dcb99d1746cc31779f504324bcbd733deeb6e6d3f8da760a9ddcd6acf74279e21d9a3ad4d365bb7c72b5c50850dd799320426a717ac79001107533a168ec46aabe255337e5db77454a8f363d864a71ec1a3e2be739703302d077bb5f60222fa53af40434899ac5640acd92400d6e4d5a1688338854314dff2e07df1d36711bac4b8f28f46ad8ac6b8c029c1d96219c02755debbbcb991e1c1adf6e58906f96e632cb045a80b324aad50e4a4775b41d82e3a2fc7f49ff0202fc3f358e8962993f9690a51ea1849fd23d90c2de5b763190e09d0d529f0aba40ff2636b64885cbc0435873dffaeea189a3d7724d2353a9c4269f353ec407af4fc381bc95f4f58d63f97e2afd939a5ac94dbe29a0e4ec6ea7698cb9519ee10be6ba590f9c04bb912eed1051bc481320fbb0ac637adf761256681ed3902a7594286bd39c0989b810e36e63ee5bbbb39fa4be821e05bc7410015e2fc37e47d894d3fa9ff239178baab416a6d0f2fd77b1e111ab362175e39ab218f8c79847392a136d51ab783fe75016eb0f7498ad83e12a6f53c38adaf3996e78ddc5c4fb59e147f1805ab36434f889f02a1b8c4a3ed1e17a2bd546a076b345aaef86e817a97b5cd173116add76c11a82af322c14fc90122653b179c317b7936d79b701f58d66cd8d6fb9537aaf7e03846ed9d7f809736cb24bbb9f0273b4e43e8020eed51143d015c3688329074b07046c667e8b496bb13f663791120265e2bc6e1b884d20bda6d4a451edfa4c0ef24c171c1a95270b6d296e8d262a9ffcd3fc3d698d2756e6b4fa2f26847fc4959eab9231d68a67d4b3ff693a5b36c578c8a3eddc0ed47bb9feb826de9f735c6507bc0a5956200c39a91ca3a7703a6f5ec0433692502250ca06c3fbd283e5b3e147cadbbe1447c349ee37a6b63331043ab1ee366ddf9b7e82476df297a83d6d560b4db2fdbf79fd14443f0780ca24a88e3eb45c22a6fefcfbf75d0e0419aff35668b819ffc9b9fc64ba83a7039a73eee2901eac743ce6f15dcf8dacf3cbaddefab1e62d680972a70c4a9f1d0c47982c9783c09caacd0401b094405c2e1de65757b73316943b307007edf034c98c4bf809081814c8eb905d053187c1cda5a8f07391c43d29e4c997e7699ceaf6f38490c904d4a7246124a3918c582b64dcdef331a84127efea1d1a217f0cfbc8898b7e6bc7c87d8dba8153fda22cad295d229586b81d190852021a892039cf7b77e40d3678789a10526c717e8a47017091c16ee4ce2c2e640ce30f67bef060e2be3430c7f9a2d4e47dd0435d0484ef448a505446415117a1c68bcfaad7eceb9969b7b3fcd868dbe51d70f90a4bf7a473d98196f5e0ab67a7b1dd9a5fb4169be15f7f3da00f0a830df2846199506a73541885710310ee2b3b2635b45e2d2824c54cad6325ed8bc61dfea6c016d7609a97aa85ba0890a9d97828d273c7d3ee35e1b05371ab264e63896d2566230c0965bbf4cb45deac8fa5b7f9d7e662bfa8c6af5ec70dcc96e6e2b2e95f32fa97857903d7ec5c8bd41396de8502da757d62745bfe45ef085f8ed18dffdaee1df8f593af0aef48307fdca73910970a8c092061fe20ed3fc56eaa5fcde64dd6514eaf8619d762abc1dc5f2200633868a249b0bb8188155aa2d2cc95f38623604cfbea02c73300b5dd53cedc48345a84257bad065d2f38b752e9c77a9f4f2916e846eaf89803b1b81374c2f1fff1fc62952bfa339011a23ac980fdc3e817edc077ee0190f38901c746d724524b117488371d23a30e700a5ee564c5c28b74ae9489608926209463e7587d45817185c25ff3d4a4e0ba50ee27ad1a6a7bcecb76d41d1a7ef23c94dddc732d51c98eb0ca5552e547cf29ef657ecaae28f82b3c62eb9e1e0d0c9db8d11242a2928e199b470102c368a81f8766acd79d3395b0be0ebc31f30e008ac1103e91208cfc92814f571d2b1fe3a1c0a104222812c9bf83442714e6c94ec4a4c484abe758f19066aa63660616dc4568f911723d157a22735eb85c4c0987486f12ce7849d608caf9101ce55d56b8a7b67a5e42fba69c96fb81112a0c9469d0cf1bb6a983a8f81b44c023eb705fe462d95f0ee22553126c7412808c9abf3ba65188fba5ebbfb8ff4993fea223255ebde436082120f129f2afed90ab1510aef74ee4832956c26028a047cd2be54d54ca9641d902b4ec17af0ae0348b238f873f8b1ab224ae5f4ad68b758db2d0d0aafce16ebfd2ae7708338b3f4a3a10fa4cf6926376f39c8591a1ceb779256a406c7b2de639087fef5637f0603daed34ad498caedd6f586948aa9a3098b9ed85bb4591d0ad9922f68289b075215ea756da6bdb4e2e6d59de31c7c64736e8f6433dc0da19a1cd9375e70759275480bf233a725df8cc4a6710181b4da6a5bdb4a3025531439b991b232932adb3493c165da10e68c7d8b90e0570010faef4cdbc454f71ee4ce1f5131725b52b49c583db524011fc2a83b0712f39fac1100a1be0b9d943d0d6ebcec3dc95b41eb26a1cdecc0c9e63a58f7d9f1c0806781cc2e4cc6e1be271149bedabe148657b1a43f2d39d18a678382a1305f06a90f0c8b21a6728aab5a3ca1c5ddf9c3390b803c3460e18bf8c73f0c460533396d741f27ff0e8640127c7f9b4379748f8dc60587e3c11fd4d34428bb955fe1d54e2765bb59f001e664299df8fcd16b59a5cae804265ff0e2f1802b9f40973480d32bb82b61c24d76fb41fd28eeb94518be89c8cf6933519da48734451d1ba6d75903b09fd8fb54e041812f90125aca699154c493af302d59acac1aab0fda714e10f4cab5273659b2b2003cd6984f079fa5130f0dda015a7a2f7ec0453c7c8499bb4c1b75b834ef4ebe8eaac0488f2d7a9b8a2a84976ae8e523d21eba9be58745371687b2db9c413625f975bbf4847f1d28a84bd015f0b4ef150ca26bd661d80e5b1c60d6377006e34d28e4f31111fb35351fb4b6aacd65458bd62ccd968bfd9b5a1d66633978763471c986b487a585040d1262ff24ce525eef6a83aae1f3fbee18c111c7f5f439d72ae29beee8823bd5593166dd34ea54a77ac48e40d3db8c94a227ac45ebd966766e6f5fee4775ea31d0100e611b92822721e75353951d6c6a8faa04334c32f280f10a9a54a4f8dbef455ea689c2f399012ea94a93c32047a7483f0601d49f914a66767a609b40fcda59ccf775647dbf04267eb51a72be310afa0c986305b3cf03c69bf8374e3560267adffa96f6ee75782ef025806c56f01512bb5b01f1ab75fc2b7d3004785ec92e6c353c56449eb8cca9d32ccd76c740605c20996a2259e9bf79c1fa58cd451147b496f1c88c9cc9893086c25e1385cd42ddd5c2da1ff1e66c951328d751a873b87e30330ed1bdd1c83fee9293eb557a68d801a117392c941ae2d234151517635befbe1a9ed094fe45f646d0f7f5c67f75d4d0cc76e2f44c2f419fd952d9c73f5f2673fcee137b63211d38562e1f96a55f3e1f9bc381ec2d17681f6053041541e9e7a7e5786b585b5769097150f3798e8e1a87633df9385cfb63676bcf15e451e2d11346af92c1fe9cb71daa3c71166d7e02b5a78cddf521817160a4ef24149843cee9a35f7ec73e579c3909ba647979ad5126bc038b8c221ace5ea5d8887ad380fa62d84e83363f7f378115ced1081d221de2a23cadc991133d27221f3a82d60f9cdcb5755191d726d031f5f9548bffd81dd662e6e791d4e43a8b8fb18cc68a03df227bdfe7846bd80835a693253df5e51b791f4edcfdac941cdc042dd0468152fbf9eceec691b839547e22196627ed4e17aba4e794ce11d1615b132a7a62b41e6714b8b38a438c67c2c8de90798b99bd60687f0d5ccc8594c33240a074226cef1c7483d34adf7518f32da6daebed818aadde97a9e440112126db4dba583cfa49f4d36e5aa12e56ada8bca60ae0a50d91d0af0fc880b9769924180f12f8b229c081c6251f4622b2ef075ca415352be8e6f45c3cc3e5348929144d4518e8b2a525599ef817ecef23f11ad1f4128151595fdf5450d9663d0f6c703809be696e26fd6e3cc972ff9733031eb2f78a7cf6a50d2323134c5ee502ec481e7304bc44b243a9c8664b108ab9b88a18bf90eaf1b2590bc55ca30f916d1f44200cc5524afa833dbe849f1644e3965741511637822363671e03450db78c7ba14508910f12d6d45362e0e3b18b35ab423be369b9cc9dd8332b31bdd572e7c8163049b5a83927cd2d145a85e6123146c3de194f375b3108d0daa9e4a6cf41e3e3e803ee84dbdbdb26552f378f86e91a60382003447cd5a80f5607021667bcc499c3a3126d852586f7cf6623f7f0e410ffac85e1933dbf4bbb0257c8dd336ccac25896da62888117e826c3d446cacbb9575f16bf5331219a4c502d2fde2b8a1e5f7125ee6c91a05b50cf52628a139cd790c4a3c6ba0cdea53ae8520bcf0b01c356190c7e99b731d6a998d3998e861aa9c4eb617211764191f83508dfd182c1e2928e2885996426f45ef5905072bfcb9b10680f0ce056bb575967701d71040e69240589e931434e3c67fd5166d5342bbfbae8a9146af31cabdb70adea01fa64d8274877e851690f99a1db19869834c9c0178148660635a16d493b38d1c1616c2e57ae59b1e75545142a3a6f8cc6bac7c53de89d0a79dde755950588e9c2df8a7123e9c69649965a89877d2f1a00ae28fab9a47b705723f1e9697d88477f30b965e4d8cc7e338f3b7043519dd05acc21843de5635708d805051d89072aedd3738eee2def49aa51c2c0c67aaef3b3c528ef7f7a98068afa54a6ff58879cdbcb6e2b34855c65d7899a219e2ae68acf47818f3065bb30c9cc342fc6c4a0ba6facad589b935f81512f2724debe34865434e7904c2dd1428281d75ec256cbd1f545fb73007473667a34619bdc1c665e9af0491157685897a4231cae2bdd9ab42e5c1e696bb95aae79550ff7d3fb96e58481d984247a3083bd5f874246f8e7ea2b5cc390e82a10ec3d10df7b88e05000da6733b3ffbc9f2a0ea7e7749a4bac9ca3dd1a7de830e6e55e0c7841d5b55e7b63e297e5c97b3be6695480c33626ff85b176584a31c269dbdd1e2cd05d35b2cfd4a398c0fa808aab9af71ffa159c274dc44fe5982e9a625a42204b6a3e2ff9e2fe2746ad17d42b041cd2eaaf10934da44e6f487377df83a92584fcdd1783be822e5903d52a256c8e2f73b57eaf5538b2646b029168052e9f30f366c05c2c6d7d8ef3542bb708d23c290696e0463bfaf920192ef7eee52bd52b92bcf61ac5c3e2e71c55cd0be96d3f872c05d2fb520152240b31565c3c701486ff893fa590b7482486bc1e39d8e4fe9fa6e70369fe5704197f3a366a4aa1e9943cbbd70868c8b72ef89fabde42734cf7130b983d5ff57645fe69f2e08ee970df80153f032e7ef52b80348c22c527e2b8abacad18646565033febe9ff4c7608ccb30cf8218303cd6ee6949a0f0efc6b88fd15c54750b9ad941c7da59b8f29d4d58827466b26460d7c0069d29796fdefc9274a455b14247ff9539c7f06c68daf431f653afb6909d08430ba07400f3b8a4fbb92fd632091178ca26754fe8c3046cc12a0c272a166a1e0c3e4b664f3cd0842df22452df3247ac1efb05b5b4f005b6c876f74fe502abae2b4d25a5579ddae98205ce10e967088009dbf7e13793c932c452de69da21b39773a8e720c4c9f6dff4fbedcbd0c5dfc73c5c055a1f2c336332181d1332d54103ddb47690dbf5fe303e67148aaa0979257c002e374968074e137330a6105e8f97f210761a293fcd5d84a23045ba8239f5ac3352b04384fcd47d77e938d48e7bc3a7b71a676de1b5e0b8b966af39b35ea00664d12612336d9f4a4ee458f706750b37663fc9bc53366c244013ce362492e76b6fd46eec3073b53eec829829bed3d1128ad9958d33dfd3d87aee529172b44252e34dd6bee3e4a5d6d0d7125d9b346949dc339af95e6b1fae8923f52d9e50ca83e043b958226a7f023b73ebdc548d6fc27ea43a1849371800be23ceacba8f04cea1c74880181766b16230e2e783681830252d734c461ecb2a6653915e70db9801bc3e081b660b425a0d6700f80703c76e0a9f0e86c83efc28de2b28e9f30e8f64cd0df220e3a26523435e97cc673b26f0df81eeaa3e23a9751c46a62848fc13e0e724245e714ad0d7f30576265b1ef898e0e45a478c7fd172d895369fef4c9069b1adc4a619fe4976870c091b1f8eeb9c765356c372f267d630239f5968cbb9fe40bda0e2e50e623ffa0571adb90d4f620d7f69d319f5466226b1a575632829449457b84b519d0982c9732a14bf04d39d04f769f47ccd5f39acc10fdbbceb388b7e5f2cf33bbfaa739471b990832c27712d4fa7a4cdacd3a9e30a8843e72e000aea0f8b4f043665a51319a0b4b37e38b209f91df8a081f1df8f2ffdfc4bfbf18131bc5ea741e999dddffc42b6c07322977547fb9fce155956d061d1d955cb7617850baa113f99b186427d3e8574a07ca71790f7f44c60ba0cdf09b3077f36f90dd6887c31423e1e81a62d4d2abf1004d476e85948935bfbf8ad69b337fbe07041f72e01da9a249f53c714312ed8fe992851d7524846b0ec52fb8b74cb82a16bcd817969f8fdd2ddc30d82550bb45282f5f22bba34c1691372c2e07e872efec4f387399c79be0e7e5f447e5f44126a0992aacd028a6b9957163081977d6af7ea6766bbafd7aad3bc1d74b4b96b7acc4e5675ea59dadb94ec2453a3ae0b8d4cef7ad61aa712cdcccc285305fa6e9b0f127c408f92a349ae23ab1f4a9324ee6dd8fee217298157758d6ff0a482b0c7f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
