<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6848654381abbc32926de6bb379102204228c7fada9aceb5c5e604d14f75c53eb5b66a44b53724b42669304b37308c82c83e67afc4e685f1bf5f6de07b6cda28ded36752c80ad428a3d6bf4b2c50fa7e7990951a83b546019075525928706abe7c0694abb2c8b0e5138278b3feec3dd29c3c227478f1605ee9111dff747bfadba09a82d22b192f8e5495311cad42cd4c5882e3438f37aaa988684bf6263195016382bd0469bc2fda6ac19fe4b69ca0a256d4916aa0a62bd7866dee4d85239f3b4524129f80be19801969cc8c986e493e26189b5ba94c707df185ff5e788ac8475d8fea8afec6678afbfd7fd643bf176cb81a11a9f67a2104449f066aa89c8a74b1149de05754ab365f8ed701375e71f0095837d44f1b4f720d598b310b1b3f0dc85d9229604df957a5c246fd298b72b5ab96445f0891de2b42554f0380379a891669009aa925fe78ea2cd0426e8f9533481ad2af3cc41e3885a692db6aa938c286ec13166e1ad47cced7d492d144f3dfe26f209d0bb3479b6e894a188f25cf5c3ec45cee5f562166c69a648324adf8125f1dada74a7b17b82cb539560e4a5b1dcf5c7a196c7c472ea60af810bc8956ecb30f2824ac9512f2b7d0368e4a3b371fb8610badaa8910a274c13eeefa10436606ac114a4aa35af3e9781a286c7b6df3d832b4b2386ac8a42f317f908e104ac293c612def4f9f1ae6eb4a8104129c9609a42dc251a0d5acb583b47d3dd90527d98f516346280075f2eaf0834c69a93e4515b73d2d6312cea9d74c8b50eea15087f02b8824b35a6241ecd2380dbc93b1acdab0afccb266bae63372733413e22051a1d51024c184e2ee83d6b1fdbda2cec766791bb2e5f588cf01d201486bde98ea40273b12e31b6a7f6ba98514a27eedad7966c39a711a161e8a608e9b6f6b4ae75444212cc9ba9dba4a4243d0da6a015e26c1af60979b4195261ad5be592a08c67e71f083dface7ba0647f4a3fe24b4e8f1ca89046a137b86ae79b2656361bc9844ec3f8ab30383e5978c0c58a3231278c730e0af61c982b105e3a87b5d91f54b5abc40ee1ee5d5f241af2c1e3c794287a9f72a369f1887d308e72923443faf26beb4c3fb28ae276d614c6f14fb0689f9712af55b20d24e058eed9f229ae182e0a13ad01bc6180061dc667359a9fda2b79ec26b47744904c4c9599e9531650904e91219b4c5bf021601fc09bbca1d624bb91121a39ee127ceee6ddcae0c340f8f3ba725efa41639a4b7ffcf4028cc50d67a15c3f49ed35577961bedc881d94d170d2ab20fa6f4f9b82e63513dcf7a3feba3d74389d9f53eb28f389cd6f06d611744f8ec72c3601915d4c47bc7b22673ea7ceb5e6f89c29a1676367a6c2ceea6b2c44dc054dfd8aa6016a156dc275ee3fa9bc5592d0d996c22ab1f617abacacd094a9367b5d88c16c2100c66671af6a21edf90921c1cf9abbabb9187111403581915cf8b111256b4028267c91c2b7c7e524675e45f77f599bb6289b7485e5e1c0f9d6551de5c6559e3fa4062f6b0573d42ca04e0fe5adee1909cae5ee0c636198258c41bb5b3813c390703b2a381ddbf29371e175ec82f17acb3c751e357e7267e9a3f9588b3d0753d9e6bd73c25894006c62c29c81fa1738385dabbf019d27125fa72becedc13e7922b8000537f61df852f45d552bc78caae9af87c44b923d969ad19055e7e8b30e095007d83a1a5a96c8504cc2585b01ea6f0f0ed59b687e8d546a099c78aca4d5f294e4b002a30be0df1960b628180289451179aef7b4b548fe6ac01d0e8322ff1a68a65ed2bf5473ab39bc9f4576c92c1f5ac52ab86e50b6af6772972331b060765b4272d9b9d1c4dbfa7ccfc47958a4299bda7ad6e7216d8b2e7e86ff5229399371ced28d87d4cf3fde77345f9d62180d10699f4617d2bcb093cc50acd14952b97142374c5936ddcffe5411abfbc7f79daba3f61c9a42719bfa4e4ed89bd6d1fc1c0085dd23e68a920f097c0e31cc2159476600be889b4b684e082497ce78a6751c7815fc061be6cecc19c75ede9064daaf338486dbe875637eb1204572729b37c914cdd2e67695b05f3867a8fb409b7019c8dad7175cd58fb1dbc951fccadb633e0c56047b6b03ea38c3056a589a6e5ddf7fa9654fc1b693a46d0cd799646aa2ede1b82337ea83939eb23621063056ef93868cd396e0042a6707c9130d5c095725ecefcf548c8fdb6c6e564a48db5101a72ff41a574d20addc546fd781aeeecdb5a15991a390a578f38c3b61a8e25f1b392a4e2689638d859957f2a1f31fc6d9993784f9792e577d81ca06256ba16c85bedf436f7fdb7035b73ae1f2c31cf2ee5fdb8d982c33911305fb95195105107741d38ef17673dff35f07f2e79dcbb0e94e6f0527f341a1443bb446e03587550237336e524d3bb360aa7b8b8f4f1d36d041185841ff4c4023e0f9aeb494b3efe743235b1be481c36d228757a7b47aa3c88ad51e79b112f135d5e9c110813065ca6be0989ce2ef64783a84f8b13ebbf6091b5fb2e6b18978d4c8704857d5b0f11313f1e75c33d9128938fb4871e7a9748107d46c6cf2f56a604c38fc49e993bbb7c5c06d42e9943ab9c22819ef07d21d97e100413cce538ea11767d079964ac85dac9e9d05b8f9a5eac436fee780c08f7d442687075ef2981dd6d37a8d319271e4e941f7e9aff220d09ef3a764b86ce76fdf9603b946e9ec79539ca1372bab8ceaaa10b9d1fd9df3149bb4ff4846b9ffe5e09af87db6bb97df1d3ab81d551f94152049199cd2ad3eb7f9f79a6e86e9ce6caf0c3b2942163d1317a9ff72cd558e4e396a209e7e97163fbe1b09490001d0774c2b07fe46d426fee17fad2f091f7e44a2fc9e32fa15995bbe13e454b440c1aa22c00c07f4844cfc4be7c01cfc78c33e83428241301bf063f03d8127163c69d0e52f605376727ddeb15067dc35cd485c37bb432e929b698a140746e634986b700dc081636da0c394887b8d75f0d9dc6a8bbc53eb38ecb91cbefcb0e4a5bc16db000a9602fea650c1c0800870a0f2a379a3842ca9992965850dab69d92094d8454da57ad213a4a2453ff27f837556d1ac97d36945161e4b4a8179eb478edbe6eaa863ced5321ddfdbabc1c4b36f59e3a92a394be82b30c47a1ab6fb35dba69146220c5bad9bf8fe4cee68d5e91abf17def62c9b0bf682abaefe666c0336bdc69af0f403c3586a30ec494d3b8c88e5624ce92a75bdbf01b4994f262de0007abf5b090274db3b4642aad985ba296e0383291f4fad8b064d7cde7deb25bab54d2cc66a914c3fb6ee1ba52b0cfa04be5ea5d7544782791b47952ab3002cae51bf033cc6e2f200e580603977eca2adbb7d3f5506c1bbb138c1ac42bfe74048ad41bec633922498eddde34dc0031f0a002097614b7799825d52c8f47aa7f01afde0ab317f021ac36e4941954b27304cea62ef5c3054712a0f648d1b0fa935e8510298de3bd63ff5ccdad6bda993718a0ede4fc53370b3d3a925bf0fc28e95d0f19263fc87797954c652e49304f0589df4c869c52101dcdc474efd1986c98c368d8a05c909d60f1e6c2078c020c3bdb629fee503bc0c512854dd8aec605d4e832dbce064fd1204f7a46f48f3acc2a52f96b83d7c0e174a75ce486e5bd5cac8cc9460844aced4d92d80a64341f164bbaf8e43a0ec7a30ce19ab18538710aa3f284e4033e804a1a81477fa37b8235b6dc2b383715063f58c8e07ada9b9b24a2a83ffad3510cce96be0fed545167a927f5c75cf8b791a4efe1faf3573f922dbbac08e094d935c2a75ef57a76fb4b21b1ccbc8dd9274411098b60d4333ce5a1123480b65574824f150dba9827b46d9ceb9c1dd8ffb5a6005b1db7d89bddd079e4fbe00f61d68cd0836d8d3ba03cfff6b36772ce30a8685ea642ba6fa3b1a55b2f0f7ea7651b0705ecedb5b4e1f5f7d0db63ba784f4b0d82c3620d659c4778e130394252fe1ec8595148bb161a766783e7830102f9786f4e61f72e9ba7f26c0cece872bd6ef67820a50361c4e0f8a567793999d9e49c23004769bf49069c9d541fac17e68471521b7713dda2af77cfe2cd7dc3138dd96d79546fccb2615493bcf3a1b70e58816040855b619ddc8045e620166c94f02c20bf9fcfc72babc2d93f71a31c7325d3130428516026d802960be5040e0d12c8e3c534965e9537a472f6ded222142efa2cd350b3fa0da6894ab7d83f100da50e36f7cec35891b64b719225706d60eff5e95e6c0004a78dcfb24f26092093af67239309468d9b058188b3ce2a8e67a2a39541b98f55c07ce6e372514e0f0237c15aaa8818d886f67d2fb3a616d0283118860cf7f359d4cb595ddeaf1e67b6892c6f2403c5606e9ebdadd25cb6a12d9fe7b1007021a613d26fecf50720814a04762c3f0c551e8729bf0e1a5702fca993c3e54ad674aa8e2dd46706e2b998a329ef0c6b15ed9e78d377a1903cf44c02ea9dfec685d016f7be09aa720b9f248734b6ecfb88f4d3208accb83d5d1ad496cddc710208216d762fdcca0aa3108bbc1f56015fc00edf353b031a68c2ea76407df1ee3b8e2fd0095b7d4c74a58e05af19cb4815e14e9af4899f0205e79e34ae6f3307423e90f35588b614bac04188fb2219dde7c0815558ad8be0922b608f157b246ea13e54cd80c291aecdedd5d5e44f50b98e0313bf8134a8f24d436c891599167f60430816d630b9771ac5e751f4b1762e116bae89b6e8956bea34e4e63430435fafc1e45d4a854d825883e428d6d9926cb569bd52eba9b4777b3d1da55e90fdf8570585dcd7b68b46d829af972968b78285f52c79db4e403b52cb4f4b30849fa7d68be515f6f9a6e9460cf133f4971e1c8e1c494a439b926ba8892e8112871c4bc7e7a9904260cec5cbb07c7c08911c3b734b07550f3a018772d9649b337596e88ea0107c4e37c2f240a075e9c331557204d16e4cf34d08027ef9002eaaee24de46c691c72654b5fb59877860ae946d3017da4a5773475eb11adba62b5f96864f0634d47f481ff5d9b8949f967a2ec59175e755e3aa11f32561c06529bff1c8be7957d0ee0aa39007b362fcb1f7f5bf02091b2dbd8d38b17bd514a8f573096e088bcfe0729ac7c477de898638cad86b9942fc64e2bc69c135f2fff058bc794214c313425c5fb876deb67a5b87d2ac6a6c6b0642cdc8ad25ad526adb45f4f09e0ec629594c15e659298687d2248ec19d96f8c42d6f627d24d5130b297ae7aaccbf9104471003875fbdea2215adf69eec8968dedad1dfd39cfab7ca726a4a5f95a1111895e1760777f975c30b3914ceba409d644fda24ced10e34270a524d6efbf79144629c09c8b5867e514c500b7b0620c2cc49282696dc16dfe5084db4c48631b62e0ba72df1212ee4419303a2db4be094a4b78efcbb3ff74385e7d36df1589b5a61b796935926a15381cbb6c5a5ac33610a4667552c783acbd82e39111a807b52b3312830159feef4c89fa31f334d7bcec721394a65e89cd50b447fc9fa326314fc3efd2c55f42f61f3621a6a3807c7658a7ccfa1ca6b1eba2b3715d8501ef54d1f2246e1cd4599c645435811439509a2305111efabc7bf80b1d27dafaa49de0b7ddd42eb786d12c5f4580fcfffd206650cd8fc6189bce703a575e4c2ee99925f7bc195d7a07754ce158f7fedeca314ab5bad852d9a87dd66f01371c5a0ed101026adf0e64f4c78a06066eb43b3197d3f51ca6ec97b2ede5a7d2e63cf10dbcf4670db0ed321f80c0d474ea33aed76a2acf4a2fcedf85351e7d9ada14c9579046ac9f19325a84aa777e11cc8d942cf869b3dc17089acc712b8350b83d475936a757f66a0353ec84326a7c31b1b3a9890a310ff71089127ec5cb45fa21f07af070d5b244689bce6ef369fad13d75205ec03f2711cef38a44cd7d24350affd6dc2a41390c246d12efda16b45e16f3fcfeddfda73c1b415f99b016406aa4161d7bc1db8241bedd961b30a53b7ca98bbf81eccfbcdc753b84ba86044da7a455ae05381a25ef5126bde681e3c3ccae1c0478191b392f44c3d7f5d9c2d26369bb43c29d8b6c213c5735a0f3a8072a52dff2ce5170d0d0911d51fc0a2048db3c6094656092f3e9f98fdb271fe43c51e0084e89b5b132b7deeeb920ad72cdf2453f96622107cbb4c74b0b55c9753ebcfefde072ae9ddbf0f18db05fbfc19ed7d638931f72e8fd8bffdfbb35deca1c9fa5d4aa0c7da01e7dc0d75eb7c7ced826290a308e3ca075a39d9bf827cb0e1d0a5f1bb20df97a0d429f09ff5795a6397279f0622a4171b0918bceeac416b8073ac3bc4510c448fd5b3ab672ebc27abed049a58c7f0c26f0a1d198c118906fd497e09ddc413c562cec22f353d6e66189bfc3c62c88de17f75a88f25549d1bf2f4c866405ed047ed799d1fbe8f66269987db6f4c82a6aa8575eed68a83b6ccffe47621fe8568e45a34342f329f8817a32db8f2ae1f501626b9eebdc9d31cb4a822d17e0f39bd203a3e3d90ff93ada5684412b7df63ba0c5e7370ac7ed7599f9bdcaf14e4146352b95efe9744ce7f8464d1e165d3ab21c7aab2c0ce7aee8caa6415e6a48973ab9b27e65064242aad6e4472a90f578b3cfa059c9f22876732e7ab7448a5cbfe64bc06fa820967177e155c903f41b590596d7e112d39ccb08118509ec31b2f00ac75bf431911b3a0976741ea23b17141dc8932ce10e3c332752b7c54154785de1dfe12dd7d03f4613f04ee8338e0049f899b594ad35de23a7adeb485fa9f3a342a8bcd1e368c9c4a97ed9928c7c811b712ef2b5ec6165660574a0ac63aef439914566a3a73ed40ae7dd2932bf4f9a5272b69d9ba0b486e74277db98446cee8811de228418306ecea186c3d948563f171ac3eb0b1b7c6cdddc814a39b38e3ba65dfb9fe0b615bfd82cd813909eccfa93f8f701143f59158906459a9be6845b82601fa8e5a923d47f74c00fa42377988a28c9c385eefb4ff8cc5b2185ee3f1001b5e2902691fc9140a431d3d00c9a690883aed49efedba5a7331cd1d661bfe66ae2f1f6c6541bf7f3545addf9ae26ea7707e13ab19d6bb781108a1759b888de93e38475eb490373e9627b8ec94d91506066c0dd9d9d2f41ad0d97fc88851e064600c395aa9bc1961f9632996ca1bbf826058b520b3888d8e67428bb65316c41bb0a034fe0f8af144a1a3ae2076e1566cffa734aeb817b299b5b045d176a9c071c90eaabaae0a7d0005aecc17e0c0739e90ab2494d9d0bec0b139c59d643e2a7731c6de6df495a9271e88c12b3657ceceece973ba5aca18d07506ea3fdfe28ee6ff79410e68e9c57a4c61882e77535357746ae7cccc20d3e295b18ec994b6ed3db5e68841a0e75cf5129b14522503f8dbc2238005f9b2d9445f3753ef664d657c41c841d58e7f85a37fb7adf6aaadc9ad17de8a9a0d27fd4c651500518910ac1bb13533280365a506cdac3839b5b27094dd68b7bc11c855a660e634672d98be80335f858441728339f1d45b1f44b85e66f96dca0f745616cbfca40333e09ff548ac2466f220b52a4e85c793352762a2ac2d729925bb59be34669d866f7cc5ff2002eb82e31ee6572b1c893b9c617ee7ea523507ca196da110e87e5153bae66955a663d194323ddb9df78e613b87c22038e19ad89816d7fa21caa2322d410bb3072623efb99272d0e34d96ae89460b29a7b58df5a9953d3fc58a4ee8b8452ff43bdc44399cdcdec109826cf4688b8d23f4713e315c5108c03f8df2ddeed8263a843e926c1c5f6959ee9670fc4cb5efdf8cf68c2a4323da8b38f8d4634d10fb7d9760964bffb2aab3489e4d9b32f63cff951a26adc61a2b6ef518d097eef3f54c44f400fa740c79854e54ee143200857499276b83e3b6c7f76971f3eefe71f811a2049b84e2d2e2cb13dcebb4e26ba69f830d6bb91b1d696a66b8d8240c2b6ef11289fa1771b252d597facb5dd255be9c71e4edcb80d03de681a627d89a9f040ec3d8334d6748f1b1b2fcac01b8f6163e1d8fa4f5d8a34b07ee882aaa820509ee03d39c3d58a3206c440b5d2020b9ea0d6ffc36ca7ce95fd573481b131e116f1f38c98c21aa2b5d1608f920a9b1a0b96ad60c87fd3084877485cf50b32b97bdd3dbdbb02ab06d1eb40413b1b8712579bc6ff1bf5bff811c19e9e3b5f8e8e51e635473da53e24bdb84e3ae58cb1108234469e72e47e11576aaf64bf9d0b8e7d64821f48f981290c17d58c35bbb440d87a0bc8e59eaf8bd0b4e848412f3f793b13def61beffe022ba35872d68ad6a8e6779a02bc37c9440ebfa3f8cfe9e007e08de6f30966ec0fbb781b863f1299d7b524f772c432e451dd685922df2037febc8709d659a6c10a661da2df8875246fb052418b696da3d5e3b03ab4d5cc61e8efe5b6d589e802ca4c1d417fe3c80bc40a27c3d9969845a30aae81a116cccbce467b5321930b0da74c9385e9f1a4594038c4c62cdb771529a0fe97d9b00d4081460e1aaa2010bc515beb6331be1ee61c83f640304e8e50dd6289502fea3c51edaa28679810ee59e4c7be19e9814a2567124262566fe6903494ee89e2814f549d17aff59af975535e33d8975ad12f0e286e04cc891bdf7a8f5e8e7e15853e746b6587efc45fdaafaa371ac91461c674c4c58c61680a75b52f0e841bf37954b1f2c0ddc77020168690397ccc57d4661dd039d9b2ffb78b6fe6368002fe039e8622e08f059f73fa390b65f28c5fa80aa0a35b9dede206fdfe9668c8f8d8b4149bea91e04f70148c2f66365f74fd5a5a405b605f52340593a3962fa12d8bf6219146614d040649b6abcb63338df17d6ce1cf1a49ac1ce0532953b2c36fb3313272a156ecba4fb2aac556b6df27245123eabfef3fd82229e71cd2a2dfe0e3f0a57c0b8831fec5271008f5b4c57bc09961d92a20bc06acb6a24480b7a51eced11d5d838fb177920df28f5ac99b49df7849225ea3ac798f9991a007480539df372162022efcd6f84e6fd473341a67c87064101f8603ad1719c77672e930eba1e5fbec25359eb8a6ebe537b47e1ab1a1a5d006839b0296bcaee9eece4ebd311eacb8f0fd4686e1c51761444c7160cbb3b1e7d046283f1004ddb7b0a9a04bb015437dff3b931eb6819e771c04d9f19f4fca72ce197b23385bf01cffc3aab1b6787fcc0b934ae8b7324d07e65395097b71ccd7c62a73692137468623cce754c471417cd109036df5de4a290f8541645dd38edd155faac510f6e7304f71f845ff864e1d0931e9bf6284ffcf3164254a9bba8e2b9f0ccf4e57b15a6ece43630529bf7cce9dca67e176dc24df63264f415b597e412e32f8866c3f4e52cbffd6f033ef663b0c6603509aea406c47611b6e24bc46ccc17332cceb2ca2d7ea78ec5c8bcc68b2792ad25bbc949e2660a3d4f03b0988d7395cbb9d35e7393423e365e68e85291f13065cc922a054f93bcd6819efc5ea762f8f78ac40808e27e4a788fcb85d2a8153a1d061e9e84db2442d220cb7dc80f047bea4f82da708a5516e0f9bfe0099bf05cfd9eaa44b00932c7e109759a63f80557e4d3acfbc82f08c0c8e48cddd272ef41c1aef024ed974a5370d79ab388d6d715c8e6a9e6762d95ab4358fc93e685360d769d95c4ff6ed124864d8228b332199325713fb7737a02429b485cf41ba77175e91e14023373253638cfbe3a781ad7f8603bbcfdf04571abc95ed08a749072546e282512fc1e0b2b842727e5e49e520685d97f1c0917016e429edbd1644e4685f0731c58c7eba7b0cfe934d84c336b3fe7e27e233b4397c3be9727bf1d195b61ae90ff0828c0e8c6eee512af2813cb7c293d6293e1d7974114d9fdeaa18ed2059efd45d824b0375e5e20d517e23f2d6debb9f46b3ff36f1c9b992f263915edd102595882da306a12b4bb6835e732993942bb3aac0197871edf67c9028a1bd42a4e5113c4be978b945031ef92a3b7ee79d436f6d2699b16e99c743504d66c25a386118be110a507f9e6827ef5c52d6d6f81c715e184401c7145cd154d8bc26643d743ccf7839e052a436b6c4e2208c25684a0ce72f7b891ae1a8be2dfe91da7f6adef0b1707252ab944a6ef76a6fcb020831370b59ab2d8c43520b989171472df3f8b05417b46089fcc0bafd75e9f41633d2c315e7002fe87c21a54b8b0afdaf008b18036079e82ef651e2814b9c618ca7634e673c2f163d9493e62ea813e5ccbf74cfdc93bb48833afcd2d084c7865d86765b734d84803f99f6e6d5f4895c43ca4cc1541a7d2e7683b3fff385abe337b07220b8ad6f13a21a7dd6f6eaeb325442ca8d890b429c7a77c7891d84d2d77a89726899dbe24ca22eb7e94ac1e3b8aed49187e90f3fbaf7c33c985090fa8e33cba785c159b85d4b984fb854f405a294ae9dc4dc44ba2331d16b783b7f6c99438605069526efd0ac6b0fa0538c51bacbe6083db5683f11f0a215237dc2d8fb09223b172bbbeaba1c99d1351616603947c324d0e9c0c2942c8ae6829760969bcd7c1b841e20179d4d269b3161a1e3fb6c76bb528190869423eb79891704f7e014d40390150c4bc703611abd9f8fc5fbf85b09cd9da3bac8a7fca5e90d74655b6edd7603adab5aeaa92e02ea12aef09c36fef146083a422dc7badaa8fee41bde1c7e4c3f3ee754a1641528bd229b3ab2a31a4bf94cddd47d1e42e3c92b44345dbbab2bd16ca39b251d4001af48129834536a5c91174bbd2a4bec8654c65ec6ffb3c696d7529ca7bda66dc8327658cc338c8d6be1b74f2b4c62aa955eb519cfc1366e038bb27052dadc226984a40d85dcdad960133a71e99e2fec877f4fd6b5fc72b1e2bb9cbef1d6a3da5a3077a9f5fc0090fe9cb71dcec7939f518a3c76265ca76580f39ab87d38bec4b4f1c84cd3b93021dc8dd24f53d476d39f577b4344a84620a65e454f9f53eb443fb652f466675e5c7b9488220d97950e73d10d82a49800954ceb53acb8d34da635c5f219a65ed2e75f1c3825111a17761cba3e24fdefc9bfb0f74f2af6832332bb3fea977a97a9105b691988a624c2341d0a9c9e69fa29f60d56d904644d4696582cee20a1850f3b80e7316d5ffb2a47c7527aae33b9ef86a4a9a78b3882a9f2aa779d04f3023d9443f2c7ee9f4d30301fa324add9ee887a34a080a7e0e104caf0d1b0dacc20e33c2baa12beba3acf88e89ba7e427e9c4131a283d765937fcb77573cee12aa4eac9b75214cb21d933c5705814e1c6224d37380f91ea77d10344b33dadc037da505c6b7a3f6674f344df1d8bd2a5c2fe23a6361d1da31ecdc41fe18abd3073937f038b40b9ec357aa643ff5015f60c30cc0cd5af8d8d8be31bfc643cd04fc3ee76f42d093bd11f0011aab32908837aa037eae8558fe7f5b6876166b0834f518a33a2b07251d6af76240b7fdd67f8c3a981c8fe61a1789b43b6a660c14b7c72101f72a7277c8445934a8566fc2148e5079ac4184c3d45e9a4d281b88b3520d8585a057a9426aa6c87c571c7f31df6da8dea6759e5eb4f85ea663cc2821b2f46246cf1d2c2f4569559e98a6e4f16d6bb99db5b29aeb53959b18e70c4a1a1cd8ffc24015dc0645762b30668c92757bb814996744284f1367677a49fcd5fcf559385e4b9472313bb0ae52e19ce01af8b5a090211843295357e6f0452b55a3584a1b1f4079885917f1f238307698628c6a6c3de1e4a3e7456a52329bd418f58ce1630ea5d3eaaeca564d5656521c41279aa82b61136cbf644e339bb4648441b3465da3233da347a529479e90876f3d3049543b9dabc4283270c413e9965e435a7d7831e25671fe1c49b2a75045fac6e789290fbd1fd5516d50ed82bd94fdcb48edb39150b757448a649c7081c3fc6e08df893e1a262e8ce7b3eddf8bf3140eb0627f74f5e79abd28df056ace56fe351a1498ba7a2f281b1f6fc81a38969f330aaeaa26273820ddf6223ca1c943c6a07d089ba465a5782359ee1f7cbf517b0a27f3548898a110f3d38c26e288ed230639922d85dc91c7c188b7da55342598b6c5248e7fa83b69edcbad6a0b6c0cde74a03772141556496926d1e1e0c5bad3283343b394077986de2923f7f8f7b20784e1af7540c02acfe3fc3e478e08c2d8c5d4080c493bebfc0e6b2d718fd9141b90deb7d039e25ef73ab79237d3c61a2ba73cd8e48a894a27492d7ef796afb05ac4039590b047b0b65ad336177a4879fed6f40f4e1862deef0a94ea9c999aac5c39b2fa3c699a5c31f57a173fe2f1ea1b6fe86753414737917fb23a10acef29583e244167289fc69e0ce18eebed99ad056cf06cd8ad6686579e32c07ccf6b73e82cfe59452a108b33c97d9185021950c26bcdfa04d9e45a869a7ab7246ccd1c2f98ee92f8a52bad427c9713e0e46175d0a4e32981ac24ea9b6d4cbcc1b20db79e5811e83b1de6e2c196de7f42fa0bc3b5ce9b7c79598ac498980aaacde9c968cb659dc6f0a42970d9b7a8b9543f256c8ff5bf49f1b7ea142aa69f1fa9906ea6e4dfd96dfce1af2a8ee3f0e315c3d5feedaedd8ee96fd14c26d680b1efd194c2c3ea3b357335fad3c6f91461117ea0330f56bfd4e6ac28e8d6a456035aaec6ebc20ab43842aad6e27c73e8f625d93a816657a8b9a7ef42d4a0ce047e893a41d279bbd7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
