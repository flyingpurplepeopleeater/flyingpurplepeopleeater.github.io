<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"255c965d4dd8f37237ef7b943b37eebded3a993fb949544ade80d938d0af19530c9b0bc7ed8e666160e8ae941d84673fa9ac02f0978feedb21018da94b99a097d233daefa7245e87dba8b3ecc74bfa03d302569c5f66d15e7b621cd84ed4fc50ff9276317b4f0128d7f8a6bb12afecb97b84c5c033000b0acd0c922f6bb6e975c7dd2a734a539aac8c4728f68eae3d25b1908851df711a402813db1836869320a8ebd8de4b1b101d5e07c9d886dc334d1ca9bb63e56df00e45071fc7008328d4c9ed91979c207a680c1371e77deaa4dc06030cc18f3f644c40f70e9b19552c94a81e1fae835d026f51b1db033933f05684b516afc84f044b1504e322a738ef79659d47dba1cc032d7d94732bbb03fc8e74b73d3aadfae8b95cabd389a46c5ddcb95945f7aedea3d1d22594b37dbb4dc243120090ec93554e2883dae1c363f335c46b302b51f32dba12135ec4e3ff54a4ec4b42fe34de3f4c4c0bf982b82900c545e0e29b409d853e2efe52660244e8d2181cc45f53c516ae4065d29de6f2469a24ef545cef1b464d038b34f4943095a276e424a0ebffe3fe1714e8665626d4202b1dc92fcb8d65909d530d0509dfd0297dbf11fef5abee0296ebf2cf8dde80c5a19b0bb1052962e5c2941dcd3bfc125952a7b53306f19cfb453bbc4d6b275211efaed9626a1bd2d7c0bd7f82a05ed8fd8b6e5803e54ff7451278a66a901afafeaf478255c999815fb4d6561a62fc254cffcbda71fa0775699b9f9ac5eae9022898a76764c915a557a7cfc20b4478aebce45a701a8128c099778674fbfbdfbdf1aa7657a6a1cda26b91f5b091f83e2ab68c687dcaa034bde6ea5d596e24468eec3be0aaf0265c30ebb3d5aa051740a52d0df4ca0a755e01866378c604ffecb1e6f2355d1659d7271c14f7cfa663c85b833fc029c2776dce2c6284985dc5141e98b67185cf838b31f4a456ebf5dce64b12d1bf76e2ca36e0cd88044c95a8f1ddb95763a3a08dae66ae7ccef11f3a4f259393477ac02eedfa0bcebf277a0982060f4374eb78a5c8fda8e954469c0a6eb3822b6c18d7fdd29e640abbc4301ac66d0f8f5fdb91f114e13969d12ca6a105422d90fc734dd556061bae88f2b5791a4ae24704316caab146e3e8b6af3f2bf4c7ef67399c4eaced35b66b5358c5b2bf165091be6c9cdbe192df29e80912c349f9d3cee56a6c25cb8f4c195d1b5b0b99824686d01bd4ce87598b04dd4ed963d06dcdbcc37087c40be687d7cc91634e7bd550554c185270211862047c2034c9bdf70f5344926346fa606ec94c8f90d8fc0da3b9ee85f371ee747796ed73d45b8e2f6647124ad7f96e3d3826f5609569449f507e72ebccd086fa032f8f27cc39ddcbfb8bf9e3450177a0d4e4378abbecf45afb977727ddf9eb7b4f6fb71f364c12775f4f82e677fa21edd3780a881935b3654df2eaf15d218adf94676534ecbdce915a9225958b27c2356d67cfd59dfd184a279804f65495f804fa03e8867228dacdec9845de07379042f990cae389a79d0ffbefc3e3f9f2e739d64c995edc28d4a45a434acd9bc3daad43dbc7beda208f3320e8f77713220b2ce8bc5c0a72491a4852bb87856617f8f90095dd13782c9c92742622e5be468a95de4c73a7ec76606abccdb64f22c5cfac0d75b44706a3ccaf2f6e3cf059d4602c65c74e014dcda9befcc1f0714a917ea119d8aa3026b8554abf7d3dfa85c7ed303b9f24ae2638531f7548c904a4b62c511c733d97d3a0ddb73bc316f01793de34e6acbbeb59f09933d54e7d1c38f8ccf1a38842fed53dd46ba3aaa89ec06881d28f68b06b098d762f0563fb465670f9255ce5568d8b61ade272564f3ff45cf939207b09a06635ad760fa06a6a5ce2755e24abbd4f06189f08141ebb78b14341ff350b6eed3f3ba4f245a67a62641f886f1656dbd0f1d2ef75601aefdb6104e4537789019a68874806945fa512ca40ee027bee8888a6326d60ccdbb203b1f83f6ab2ea194960cf52dc81859564e74bea52471a9a3b4514103e7dc6c85a4a3b01d73189bc09a88c45fe2a546a229759656239f9952b56ef88af3812adbbfa12051ac75ccefa0800598ba4c7d8ef7dd43881ee6d689fec6a76f7923f7348ad61909b48b229e85f27dc645a345b67d2e4bc7eeeb2d1365a5daf2886dbf9e697e4455855d1c95e18c21b67d4d310d942d04b806f8e198d1ec86359900fb95bd1bc54eb4da16b5e4d7d3a2ea297abb33b5b4d4a22e1afd33123be5b53f85e6cb525478484d7459790e935188b59cb978d0e1de8bdc3cc578c92c21f8ae3842434ff99708f06c03b8c128956ad3bd062247e1225d0d2a2d4d293a8e822ee68ab5d2169af695f3aff1f616b0c36c990cd2584342be49c412867de2965adac8d7988bfb2bafaafbcb22dcb3b17edb3dd7b26142dde971f702249505da35976b8f0b2a54b584d12fdb805d7c381b86865c453927f5d49d04c63ddf8c1c766a56472544e2e164fe06bf884debfaaf22143117d899a1244feaa0c78dee99f644aac25daf9ca44ae8c1261d66aee1a621f4cd2cc4d89bedca553ee8fc3485f0e0c4b6560852b79cff96676a1bc0ceea8490b7edf40fdf340082df6ab180bbcb2e895e92070904169ecfb59245f97e94050fdee65f73492a10b90329a038eecfad9018a63641308bb5d20326615298a0007aa4ef0c1e8904d17ba17138ac0a710d3b7b3cd839a1562efea92cc1e9a353e271022e084a938bf22c86a94c74b8aaf5ae67ee743ce5942d810b6df8e884397aaeec2b840cc80c00e7a00af0805468f8613c85a5702975e14d71be4525c20733b2c5f6d4d11af493d6c233f8416213079c7cfdac1c3119b51aeaa0fecf87aa46566916bb3062842207c61469d4e0bcad2216e7a1f16b0ad3630d7fd47db6ef5222d3026bf6be080e276b9e03032e5bd51f039decb5610418352d05cf82c1e6e2183342d87479772e0f73617f732d7182acb1d8256f7140b4e5c45faee9bb9157b7a1de38b5992501888191d316cf2f8e8dce47738dc61f06c3461c0e68d0f8cf8c7bb27ce6bd33cd2195f15013c411959528b7cb958d446d5728cb4691915a91bd5f749a8d7d272f3e5645b148753e197235ce369b6f1c75506b46ca691d9218a5199b7722d7b77af66831a17386d74cf2c1d5ddb488ce83ece8ec87245d2b9d4cebe2d891b4ae1301cbb2b402844e685b72d3c26ac4000d5cd79270e3ae06947a5f93b6f92780d6f461bb08387b18b218cae77f41645f6d0eecaafd8cf73c1bfaf25aece863e24c73543de2409d68e1ab3d2f93be05c9d97098b101c3daeabf11439f4a9607c20aae9ab41e0e986fae7e98265a90935a644e859eb2075d558b6e7dfa3ffde3150b92b3b9ab1699e10ba73b73a868f99a8a168aa5aa1676bd6d199adf88fd0f11e35c274b8db3ca688983601d5558224245a417fc49fda75cdd437390fda31a934a3c6af6dd91a4700bb92ea99906a8d16afefab64715eec67232569f216b47f07d842270844cc0ebebf7bcef507bad32cb10a6e727ecea263393b7d7ba0c98c9d6738dc9aa2004059fa1934daadd2ef1cf3bff51c93e2bec38e0eb8aa1b1a2d5c4f7ca7aba43bbd87a59caee884854a9cc324f9c5a7cff5184858699e5e78ed54c4b4e1fc5ed57be1a25ab7e2a44382de5d33d25358bc1749b587bdda91709deb10cd833fcc69b47bc18d30ffdc72b2ba5945dc7593a99ad36d15261005edf39e71cc96bbe80597248062c1c01284a4fc2fbf2534a63faa4b81d9c12b34f72bc3f0edf6df50111050fbbde095366018229a3b1e01395e9695c0dea6bf09de7ef1fc35a6bc6e3a27b421839a3af297642003f40f856752ee4851293751adb126483693475b1b88a2951becc71fde060b3465f2854e7aa5ee76fc25e45ea314e949cf11e7d1eb56fc9a8a4a3c03f935a0a3effe0e15ef1ec8fabe31fb28359493043725ca7bdc5d334dd0af4cb1053b2f332cfa4297751988fb96d97dc58028d71fe37e10290ea0c2c71f2db0123f8a838ac21088798c7ae8be0b1bdecce05bdb87cf1539623fac0bbc759686a867d391080cb1126e12b8a0bead253b9f0cb78c96c33b128d4b5b9e0d7a8d17ad006bb4632c6210d9db7350ec183cc880d47fe877db1bc3395c3656a29e460221937e95e3a167b916e8201412029c550e7da62bbe3cebdfaf37a2a68d7b34f44651b679f7cf47b676aaee386120165d42c1ad40839215f60ea4da6722cdbaf13473f166232690aa46f71e46658dd2ba8f49a5eb1139f85ba821272aa914488bd02fcf96502f15f3bbe4606e5d2f8a9b820073d9634f4c558a147eb00f0e00d22061a737bf625b9d12ce05ea5d97a44e57dafa077301c09ae65ea78f6e670f4f90bd670015fe976d8173f8f00febfc31a9d498f7a7c029fe7d1c0c613590e2887aaef32883e3da882635ea2648bb284e6bd373d02c676301ce8767b49f890177efa837cdf9dc8b6ff600ba42664ac77ba3f58db8ed051d24c08edda1d6f28c27450df268c2001d42d5001c644b4bab18ef4384f5837f008394c4c1e7017798e60ea4f2af988f673d5b4336aa35083c52a1dc6ef2499b3db94e07ff766a1d524b508feaa470c562882e71759602e71ead364e58185679a9cd0e6ec0ddad2030842c180d2798750c2712740bb4756045a86b8ecf63064412687e89b6ae96ad4aa263225bed39299f230504f609a656b62aeca0274d00094e13fa574947da7b7786e864a98bcf536eb73b7820ab3d6f52426061eb0f59df8b96035fb04f740e22b2ce6db3d68932b630821922d06a32d5a0e75019eaca3c226e9c536c2cf097ad86960b014c759f2824949a5e3d2b047282985fed0bebd878cd28215518bdb29eb1876d9029d9153d5945a8fc2d47fac715654664dc95058ad98c2dbacc4174a66c7248e740695301b5e1081969ae55579c236bb2d316823068046215876a2087d3ee3a1d0f95c84969ad54795f679f85735210b24524b12476710e9b0964062c5c0b27180ae2752809939f5333bc8eea2903075f2184d25dc9cbc31f85920b4bb8f22aba50aa12d4dd0670a1a65c5fb7fc3b0994ef984efc49e7348c0c22b0519f54178967cab48ad9c3debf9bc2ec7c828b867b3736dd0a7b763cd6847ce22d249016fa8ea372ccc429638264fee867110015b179ae6236e205cd4c50b66a38a1cc83569eddb00980f3fa3d6c3164f1c190ea2f41085d3e9cd043dc72859b2055cc0761bb69c5f7608863d3868365596e05995d024d9676e09ddfe6eb4336083ccc18e41c8d9c081bf0affe248a04bbc81abc7747fa96bfb6f7eab12863e1524248c914d6b1350f43bf21448b8960403ab659275c4af0581b5685f490b0b4502aec2ab2c5d573ffe7490374dc93c335b5bde0279483f44067422c9f5f81e17d393202dad60731649a15c77078997c234ae7389b9346ca956d5067432f2daf379b92afd4e0762146790718422bd578cca6637f210a6f8a0ba09d42a391fee064d37a1b77469af3698092c1d541038e77d4d6a2a491d83c4acef1511f1c5df2b5b34206c30755ac564b3f1fa9c0bf12d4ece597469f49eb8de6ca1563894f6eac7034ce88f87149890e5ec4e14bfdd31ec29937d58c30fd88a4cfc57154d254ecf27859aec6bfe03e13d954c23c00017b6d3466257a6f23779c74867b3987d8caa28cc645b52fd70597bc1d39dc790e6c347a0738e7c17da69722bab3cae64805f89693b13b5b81a5faa9ea257bc6d21296811d77989674bbf846a0afe7d859c6e0d36f2f9cbdd5a21e8bc162e37e76e36ecac4709fc109664861ee8e4f26ab60e6b9e1bdc4be484edc67c885ee4780e3c89f9208f93986853994021e4bf74d658c46113b0b708b1ba0f030a47a8e594802de5962a567ff0bf3dc952fafe0573aa459eb822d054d60731472b03c5309436890fbe0bbf355884fab7a7040121286e5e478bf5f92e637538a3cc55d66d751ca6c2b4028e35ef4c38e26b5ff684c706f9d0f30df1ffd9294a069b1eb256820fe415f7141b0767a6fc46be4abbbc71578820769ad0d78049582ff501bc26831ba0c4cbb32a3e7b5d689b1787bd5ef59f5f88a06a8660e7e6e3de81ddb0b99af28e1d4e5a5cf628a7be77a664493a150d15a9586823128ff066a24a765059e49cf8cdbf73b4e5c3abd30b5fb32a796e601a6d2b9933ebb355be89fabc7bb26bec28f7ed51615842f6973a553c0759f69bcab90139f9f9614ac84796ccd5f2ccbc982b45528743825a8daac63c956ec5b8cfeaca20bcf0a2580f8479f8a5dec01b8efb482e8cf95dbb62a9b1e1a95b111408821a46e18c64270a198b09cd0ecba5e95acb0a52437947d66204f2f4c7c35d4e71dd7a444b921031078345a9311351c5ec3ff9232aa6107dd79c30dab50447435fd58dabcfc4a8f088b12ff9dbf0443eb7532538d51e74fd6b894e4d2cff6dcc187a789cab1b06030453d3925b1569bd31b7c18063c313dca08e21f8b811ec9004d0610f4637003ca16b5ddaa4634322a363be569f89167e4f7514edcf29a48b00139837bde10da251ba500c98ab1e7893495091657645f361f630adf015fd9387f3eb5b7f330bc92b532405ba166f097fddf61bcee9d5b5edd6c08832a1771ce88869013476d95275554263fc770a2ccdeb3f16cdfadeabf8df1a6f2a4e0ee719459e5e5d91607e4a278a77e6862fd4c2fa4a1188d124d490e2f80aeb24819555a0ec4306d9f38fffc6f9b6b4122750c2ec1034e7c6a6ff0dad73073ee622b676b9d13a128a7c9c1def1897acde14f7465b90c1f45c555d6bdd6c3cdfd5c4dadbf77e1d15605d5ddaf4e48d5cde808d5fca6d6fa13b52a50425a6e18490498310ca9e947e0b048aea66ea55d44111f765e636fd5f06ad6fa84f81734c678e323701850dacf33d34749d5d4d568d93d6415529be69350781bd11affebf3e8015fafd34f62af8931ac05b54229e9d02c90047a0eb2133d04d91ef56b709ebdc39664b3aac7ef2c09dddd737b7cf2da65947ea14c999ec46d79da9652d632434e99daf33db2403683861dbe133f08e2a5c4cccbfbc974f1c2085b99674e7208129fa0649b5abb7c15c3e0b05988036d4143964b295118da2b3fcb9f1005ce672996a3542f4aa13c451ab38eb3b60846ae845e0061a612b6bbd05df6a21b886e9a44453cae840c1c808d1869f8efeb43e66e1bffb0855b973283c6561f65f3c95f171c3c2eeac062691543da637fc400f1c1d2258195da1a00834ef66425f4fad9e1b5145d7876801393a152dd2b91e651ad8c0b92c94596ec14bc4d941fa651bb53269d4c6c6a61266c2be6be967472e7b29f2e77551adf1a3628f3acb556f71dd9632a9db3420f6bed148472d8ad5fb472fb1308d7012ba8aa9dd56e4d56770f313fb0a3ef675aba88d1f2a9e3629da5d91e227bc505e6c03a76fa11b55f36cc4ddd17c847f0fea264b12f7f19efc612535535b719c38af1d535d40785d060bb4ecc6788655a1cb25b29b98ae417b64a8a88df2462417d4d60309a98c67ca4580aad6ea8322f89e4238f37f9eeac8ba4f6cef87771a04e26170c09b911ca4f936922980ab74c07444199e9e4f1b5cc6a64478c9ea09e03ff4cb76acd3b91a38125fedfe0dff3c85271020b53beda7c9649152b270adad2994a1ad782a7ee6d69c68f23f4296ff431268a93ca2755f3b867b8ecdcc1198e0bb2568ee5ebec641e1764e8bed757915ba1678c7c24785f10b69e0db6f07504d8dad3f806c83c80614743d4a5d9d36c16af74256808efbaa64d031a5dda1562d12ed163f9479f74ac9d789717d4895dde947ed2513d01a62e1bc0a8d9cc34c0dbda12c9232b2b7f392339e3b597a79629dea5cb7981fed978cacef877e712c2c25f8ae80edd0843b7dce5d78aac6eacc5dd7c1af1c03bc35c8b8fae38dd6985c5bb79a6e50ea4dd01dcadc46ebd850887238cf7ba6317cb3e8d102cb6f4e7d4dd3863f021ac5dee7f69ebf6dad06d30af4e5cbf8b8274290f7f82a47c07b47dda3b9a926618cf6f3f8c5365e411f38ab9051131453edccc1b0a79135c31f16492fb9420a99691aafdf135ff9c2aaac32c75960acc88406d45a36dbb1d7f253516805a0c28758d61961875c386e0bc01886c418def4d49cfeab3f25a6d2f189165a2adfd36c449f6a860fe268c14e8101371cd5a8f0bb7145733078fb5408b0548d765eba663622af16126754875339024862fb482c217b2248b2b7a0e8c6b4ae8a07af5c7004114075b3aac61967c0f1f90eb5161eb148182f244271f46d8e034a20627b83a65a4667407254fcf2d15a39df58a28279251af2673523503cb6f5e45b53ac4e43cf1a98bbba4c83d0cedc7143461e73a401e8a968bd0cfc48c0c6d6e0ac90eeca71ea48346cbd6765fa76ecd4381aa06362ebb13acacf438049bc053704724c517bb1e33b7bf1755be7c974d08df2c47e375808c3b3af282f6f8e4f75be6ad0d79cbf5d9292245c067c5876214ddf9f7a96148dfd286d5a4c76423dcee4275e521628ee7e007c5d7806d0cf15b3a0ec8ec17f21e9ac873c15096878c3df99f3e43cfaba72ffc06b57e577ff6c12290b2cc08039828ad6cc85e057d60a042c552a739316aa6963eb1f96efdd9fe6fd0a743b660e9c8ff4768e32f27d2013e5afe6a038f150e374d7f7c796bb53c9721a6ccdadf114f2a558aea96505df71b656243213bd8adf120b4d400616e1ea4a7b7eb7ee2161ea7b0a01fe70756ef9aa0849407ac18d5d6ee3b27725244565378c40908c1637b82629f6b6564fadd6ea40fde6129ae644b9f009b8491feadb1e2e8e6a818408fc7c4312e1df5db47bf2c048f6ca2cb8117b10f0c49b9805f16332d0978e2b5938e184dba7a0e779c0e30404b10b80febbb007e0bc4920376f691a3432fa36a2df3558c4ed9a4798a2b05d10473153aca8c99ff592933b8eae174a70d3c4aa20547240ecda31f4d8125988a797b567835b0fce38480188be2ab71338d35a75fe7dd706f0a2c4eb8e410be7d6959a9a827c026f6056e873346f96ebb664c5e1bbfb75a0e2f2f0d93e945fd30496c659e56280a842ef362640d421f62581b24de1e9d1b199f39b713b4a3d94c3f52fd31582a879fcf99d4ad3017704a636ee71c1fbb1cbd986ab81c62b79b2a138649f4682c09291deb5df2c4d7bc8bbc2a76925470cbf3365fb757bb4db2d77e748e5805c3f09255abd0c745ae0aa77aa640fbef3f41a991f4ec403305560cc19dbf72703cab485a7bb8ffe28baf1f10885bcc4d8b6718779ca5f6eea37c95cbeaec65fd3b5a0fe82f2be064728edf6a3aa8d55e41a2311531fdd4e22600bf2a81a4d15bbb917dde7ab5f916eaa15f31d4a8227c2afac74a53eeddc0e3b844d836de24bcad194862ad5930ccfa0ac9f12290706ef12a952f169420de5c81e14835f039fa733cfe8f4f0cf8cba39080d5494359125eb5302b6b1f190d50b5aedafae8fb71be7945b794c1fe2ec5549405c82f1b660629e68a315503034149453b683408c760c835bc3c9182788c3b639198d432f0631e56263731e5c1087967ef4af639dfa68b6d29a18bb8ca1ebc58c95251fa584d765fbce75bf17269daa8105299b4da37978121fc467a9e84a623a6fb641a05bad9da28721a55c89f75f01d9ea926674300964857829a7aa144892b56da031b9515ee95734c18f0245d508ae29c467ce1329d2f1634f160e733161e121f3630d3560f5571a7218ec5175d39c80163170aad4daccaf865fa34ada5b146c9b7b8bea767cfd6d8d402b08649baa95b166f0b12dee754b153e293bec6afae8944acc11588c3f10489350880f29fc90b9ab6a4a559000c090cbee955ceb62fe211ae653466f90221c3b4b8e3f0da4c2e882cca76539144501d27d6b28748696b1e0ba5d5b234fbbbbf310babf23658cb61ec7724334adeea9a0dbee3084de223801c351d337cfa790465c801eed07350fc0f0659fb38126a36ab12f0a4269c27a306f74651d31931b66f3fb2d81a5aeb004048756a4a5bfdb1eb55017ced7dfe7563113c9ff1b10f9a7b861c144eaa45faf7eb9fdbb3d013e0cab92645f26a0f4efee7e7c02bf2071ca863df0c59df963c92fc9a8725c030e8b4af79a5091869a7d7490fa35c78978113fd9c01ce797cdc2e47b8ce040f0ea710ab4ecfc4ab843ca837ce445588baaae435c015cb09db6aeade6144a6b10d21f544c85d93715b40ad4093154faeaefe59001472e8845d49073c8fffab574436dd5246ee68088bdcfb02c31d1853e2d72de2612b6345202fcf80d044a63ada9ac045d5a7b8d9175a580f2d162c3763a43460d922f17921df51eab7efbc77ac78dcc8afe3b6ae0a20337f5c473ac6eb43899e931a00f8fb110287cd366eecb651bb6e5b269940d009f977c08da4a3ed18f2fb1daebef3a3bbd8e4ea4fa86ac4651f08ad262ec3676780cba5b986754cdef23c1016e44f1860389bbbedf7249654bcd399624ab3bab3fd610a558cd50bde2dd1d1f6c8d84836ee8a6db4f80afa01d587242dbdd8ccd0c36c651dda7c699974f437e5161f9368c1fd2f947190cd7cb9bd890d45da3aee96424c61dc10f9daf5582e2356a970d326e28fd395844a6f65c995fb30b6bb2b0c987b57dc653e6b79ba4a60998ee705c1007d697f390ced9eb0730eed364fb76d0d9dd6e84a90d88cd41b2a2502d8c38e8ace1050b2f8a7c3e4c2882f12ea393ed143f847050d39b03ff55948007535c0bb5856ef71593e15c7a14eb3c8d0b9a0a5f6b56d065ca01afae2bac7e73393742de8a098f1001879f164f4ad2b27495cf132957a0d8b2fc64cee7f2d07c78bcb38d5c17229a82b88a5688c575f7929404bde3a322c9aaa122f17cdc67016164267a64059c333060db04d0d0dfab93154d40d7a5a6c4b24a87e5c99e39fb7527819893382ffd03fb7c09338b0a710a7cf3a6f05c3aa84c93160fca3199718ee46375687c5493e659ecb2be3522711b68e01280a095e45cffe9d5adda857ed25ff96e420673b14260e25662320b78df4aafc220cc6150369a89bd57310c79a378f8ba0a1ab0a59a4fd02f61b743ba4b4b9fdf46c3d6ff43f42d78b409d5d1c16e9aec913dedd310f2d62f9492d84897635d27d5a3e0c6275d9d4d03ff3d017c40ef3e197581c552bc427044bad36fd7a452e9a82ff76962649dbb1db2e7cdc5ecd1580f1db1716a4ac7877fe41bf259479d50467de36f51414fce4c627ebc78e0026b7d2aa97353e1ee91133f56cc4fc196762e16ed2a64833eaf7ea0210e5a80b769f1ca55d1fcaeffd9337014b8085196e5b2559210e99e8660ccb31deea8ca8d217530f69c203e55f70e1d3a9212fcc2d68f0d22c73143f1befaf49154174bb49137ddb4f847809fc9cc2b65e28c7058b70cc83f46979e4f92d144939e0d229be9d49efcf9f3f13952bf256a9107b53c235e499d85fc812f6f7a526e150693461596db8df1222640d7b7c03419d9d64e3f1f5ed678e771d08e1fe8bc585182df3a8e5ee76b5bf1ca5ed5e57a10d5e341bf698d6ff53dcc34589d03a1881840aaf0152c5e35ca9edb241fc91a311e710d2bb3085d358b86d41b1be4b00d5f3520630969e8697747ab51ad4666bdb150bc2189f8b8ce9470137bf3f5a11c0845f8775f19b9b407ac8d1f1562171931c8745fabda1497b59284b4d94b627662c60cc0b121f2fac6d8b99dd6e8c13b3d2eb9301060f4392a7882877c09fba0d5df0a8726d1c9b6b3a21646c6c25cfc2969813cd778ef1fcca7a7b0e0277123fc7f026d06defedcc037016920f3c4fb8b3a830b6692643e06a4b4df438d6441dc4e97663ff1fa1b6baaa39600e8c597501d3274dbb1fd5a7e67a592ae538da051fdc2d45889d66a3c0efdeb9f24cc7e3635d1487657ae64301cc64d5e89e72c77641c78855a7ec002b430249404626f8d86cc892e3da6f49bd4ad6462f01df7a8118f258c389c0c6196b5fdff028952c55dea4e21dc09dfd24b540182e0bcff170cf8cb95e8172bb6159605d199cc50be7920855585b6d3518e909aff2d8be7313f2706f1481408954e439146d30c9ef584c170fedc8aa0c287ec027b7e813e121749a6aa72ddbcca1d51a49e73ff29a0b8ac331c35a99f6a63e1f2de3898914814f0fdc30d9f00c07b166c9ecec0a145aca7307ad848ab9433357fc2dd0fa9491a91ae4bff87e88263577d71186a45196dbb4a592824c83644961a37896f3da98bd714d424c0099b1bdde2fde52ecf5809b71de4834544ef2613e1540d4fd7350335cd5b424b509000069b2863e9ef57e2f506bd9a2413acec8ce052880c73b1ddcc384d8d2a75efc572505d16e7db62bfc77f6d0146d269002e4849536728cfa9be82aaa2c01466df6d4f12f01291909a1b274a02da57fad2f75fff57a1b7e8c7d2654b32f2ff7027c7dc29453f84503592c604c8751098c62a1ff68f65813a8fff987cf49832fa0d907386ae20e3464bf9115324ff9d9ffc22c21d59004a36ec6a9a92ee4dcc3d5c8d082d27e51d1d9c6b4e9a7ae489e8145895aeef9cefa6cfc1571f7426a29d053986bb4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
