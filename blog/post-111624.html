<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                 <div id="more"><div id="space"></div><a href="..">go back</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb8ea29bae391b219eff28230935023928dbfc9fd27ee555ba7e02c82cbd509f23c4c176d7736fc336e96c287d4dbdf9a8360489d8eda7c7a4b2f1ab407e3326165bceb0c02e881e9fb6ea97e1b4bbb63a23a0a29f26e282c3606b684b2fc818463ea52758e6919dfeedec7237d93846d0836c20699a868a51ab38cbcd93eae81a165267b24e276e69c08e46c32e6b6e661a821e6efdfe7c053570c2c55d30bb5e4014d8cd6076f618bde9b78805e548431369d18705b23f1928a89b785fbf06ca079087dcfe190ea176c8d78b498cc396e86b5f19c832257740ffcd94303defc12c583d23592d80e4d5e485e7254c348fbeacb3b56cbb2016fd0073b7e98685a972f325add607a40780a4562c42d78f9b4263c54376704e0c8c49f94d4d8edb32caa7ad5cc86fe92aa3e4eb3532eb3a2261bc14c34c3f32e43b14df3b6583a3be536a84f30852d37751e4d09f55dc550eb2e7dc43a5bc12b267bc4c532091a1da934cdce59e3183bd07e898a4220fc06aa1494b4df3db6e24cba5edef7ebf9a0049ee049672a656c35d6526719b6c319cd628fe22be286fe3743ed43845e94f02337230f78fdba7b16ca09beca4861eb6d0afcad424d3be50b9bd84a90cac9e7c62d28859ceb706c07d6472a8c3f906095833418f854762bd44b3f7d7a8023bacc232349c1e0abcf384c54d91538c85237b5059b0bc8e3a17bf6642c41854c24a5b560ef124fd637705ff25bf1bba3030a1ca3879bc461f2a3663641476290c258283b2abc40624a932e0d6a799bb07b0fc5defc4c9a58bbfaf693644179735530cd20f964b4c83c3fe25773e203916cdc6f81ca7f59983d6ac658a166c2e4f5f6d5b4f5e391a2aedbfbeffe0ccb567424dbe7d5d3ef26bdb064c5395c6428b45b7fb6050d121e306eccc90d75c8b937878e4f2957236c0cbf46d3f722db7ecef5be61f9e24782f32e0b7400a26c7864962824143035633250c01b799b158b0804917e546c2024f95c7a9850cd75f40375d24434a3503204dd463c6df8adb4859b506cfa25cf681c8ba5f36c8856d5fc3bfc3c97bdd490f3399f4dbe075ba53c5d54db8652e62f7b9984f3583eab636b1cf17717c8dd7201c79b6b704c7a5d981c0a4cf71a49d316daddac44053b45d8d7a701808d740dd152d352461328794f268250bd9fb99b8108bc28fd5c3c713c95b29fd0bf6d4a182ff093136c5e5ee451933001d43f353dcb2f6181a2f1c94e16d7746c17d6d5fd8972e5d2580faa544899c9f03d48fde9173a60ba95073cb92ee44f351b8e8b60b040d334b5c322343a6c13659984aa7329a9256131d09f956cb2c736d9c8ae1f3be42646d61329e630a7b8a0f5633d2442606956a683fd44be59174a68c1d93d68faa02b37b78d4200341357f511627237f675440fee9aaf5dbca6b28781fd32d828796a9646e6ba1bfae19ab26c60143bd7c9e797be50ea1e035e6501127af5130207c26203482ed9547acd4ab7625d99ec164ac061e742c754b8f158d3ba976cf5bfc48f62ab5ecec1a53d385686f4fd5d1e63581a7c3269058cadfd17e6fb9e78e6dcf772b6240e8999de4288db290c2c4447cd0e0b8246906f46d56e220c88895a6d435e3b7c378d1988191c2db11fd549dc64c1eb865080ad8f1919d8954447c2bf3d47443f698ea2f2b8083974a5f9b9c6424f61f45b1bd2e8d1d25ff9e29bc17741c2fde69518464d54e54c6a25a52f3cadcc725f728a8e718f363ae0dea12369ea87e6c7fe6c7bd5ab9e7c8873940e111bc9edac6a8b67e2a278d1f557b928424dfc41bb35090778ba757babc61f639b76254a3e59f362581ef775a5e22fb03c625a831aa0a38012224ab0ec7535bb6a43229513498666d0d7d91eccc394e2d1ce92d813cae56c49d1a247375cc31897fc592ee0f171846ede097fdaef18ea482ff9b3042cf709a766261a68b46d9311e380e8f74c3b8e381fd39b4fa4b381e92f124c22bd60af52f1b3b91fd05613a182f6f35a399c7781e807898e7add9ddeccb20b4d5344e2f7b29b6666db0c57793345692532c7c4ed04d392c7c027070646a0e15187571c1c76289f119b5608efdb8f9c915d5bda778933c1a54f0ee13a07a1d7410e35f30c23fa2d5e98a48a97b50ec9f04e6c8f7bcb872af5a3671c58e6e9d295191c7422ab25d7e76dac556bd3a008007ee625bf4223595de846f21e74ce5313eaae6c07591c2221c90d56598141800da3cc972cec70dfe40c3b2bdc4ded4a6c72363d2ee4e7d2528d7adc4aab28024bc342895d21a4705f2329b9b831b838987a58f8d2de09d8f6c13e2b8caaa21418e83530b6873a0e7f18aac6d738e5a759d5c7d72d6e29550d279828cc419c3c4e497565f4079cd28852b54b0c7db49ba9d19139eb16d5cd0915eeb57a0fcdee7711919843dcdbf1041bd65608bc54b3274788711587bdaedb009454a105126336a70b6f3d62693da5bc0e5cc2ce82fc5910d849e0bcd585eddd4a7602551a0cf6f6780499f2388c0b4875de91bddde3c6132d20d24f4c489b302563bc0632d83667d56ec481f33d97a2ddf171bcb287c910e019d9a179de3c87f7e83f1d1bb048c42d9c9e9b9e223974dc36db493dd088757f386166128fca091f7e14dd381f3918d6515c9029ec6e4ff7f7732a0f01acdeb996637cf7842fcd3b47ff468e4a87de6524de90f31da8f6e8476d2074f8fb35a61498d03fd6cf28676807fc9061133c9c8253d31d534e004189ccd93293e5c449da2e5002b923a343f96e05865c8442ed0e84b7421f57881d57674a527ed5d643d2c1050e2756408ce8d6b02da166b1906b19e0102e64641ac5989399f74f32ec77bda71bb7a6c7220ff85337eed2cc8b62333d6f428287f6097cd4af17550dd70df11fe72c6d4e888ca6c3508ad5355b7c22545347be683ebada2fe8cef1c5a72ad1bc46abe56ceff5d7971e9e94049ff51c4b7bfd2b6b03f000c94fdcae0df6c57fec5fe28754f1a65baf5c2d6a4986278898b419891538530a22d363de88acb8ef8c1f5867bddb3e14ba3bcf60e24b46526f00a6bdd4d12f68220a324d1082a611588b0e8ac916ef1d4a08a618585ca18306489e6201e6f6c7716fe97a8543556bd857ec3c3e5cb3b631e4cec188d5eb5340d1eb17581cf5b5303be8929fc6479a67845f0d44cc1dd6899db2cc433e970aa411afc6e281ae96b55edef8a554d959f391d88a2d38cbf1eef1c4dfae3ba05af16f32ed4197e4758e3784695053b9675997f9087627f46e7da64aeffbb14e8b59ce352c164f32ef22a595568e94aee2ae3d57421f344ec6d00d0f5c699729029f23d221bf4f8488f2e492c6d961531201a889b09ac1730388acefcd736733d6e3f96dba09f198ed091b42756aa5b2315b8140e0edf56163b658c089000208d407eb812870d4aa808bc6f81d433a046e95fa14efb914ca11ea1e15f771060302adad1d2376e573ea8425f7882802001b8ddbe539382985a634443cd4bd4c021bc93323c5cbadde07b25878d1520770c4fba2e493feb8a0caccbf1c9a53877bb5a4fa305990901afc2e5625e53c5fa066c065c09e47be82eab37d3f7be9f01d5312490031e70ef60a2b4d19114a563bf5ed32cb300102c3615177ff027cfcd2f2fb0f84b9a1b711c791b243455b5af7c3bdf38e8a49e139fc24c3c32ad808e23aa52d5b7d6f65238afdd3d6c58a3dc6beedfc12f787fa04d910ffc3a66a105e2d29db1652094cac26cefdd38d8b683fecd99870d2e701801f86bc9349ae4300634f03e982127cf96e3f8f731632352bfe5006ab5249d94e3c58dc74135b2bd41657042148e24393a7883186810e3df4e9fe45bfe1261af8f09f1d65b08dd131ea39f9a43fa3ac509859ee330aa44ad5927beb493bfd2b5c185c4d68312d71c0af049613386a768cb2ee97ed72651df7f00a3173a2ac516db4afbee97c38a08f0bd8230ade238ba1705e63327dff387240a455f30dfd3d046a428da33913c6830c2a2b7a96f4650e0ca23a76cbf8e0b6ce335b802d3d5309f2f8d5f69d2329f7da776c16dac66163196df956355858950e6bef33012c2cc913b6769d901deaea92a7127cd08ec27a459d61f8d2741bee4fd93f811c4401bd5bf0ae160bcf86703042507299898a454d3c4fa3d53c9a2062a1b2d2293d29737a8522b1d662f8eda8aeba324bf66b0c17cb1bd088fad209658c2db164a6eedaa9ca94e8b8a216d6969db8f4a5b2de2f5ccda838755d725b1fecced21e6d28435686938ac46003af2d74e4a4f2a31936360a75b6c3990246dacba75971cd6bec40151f05e93a4e056c589c25e71317fff6c6ad5a21ad41f6f2adfbff7127b0b3e617787d4e6e4790d85837fbf5d8257cc69f350c603c72438d82e6bf5c54a89358848dd15db834cf3fbf2d4e4fa08f6e07b211c45eef0ced04c27abd3d07f4c85cd5e5444e3f9832ed289168a8801144cb14452c22b1b78cf4438a1292a9214f00c0da2b22c3edc27d1444b29dc477229f368cbf2e83cb53067563f2e93a3ba991cb86ab486051900409f513b303ae9197173035d64c001af31dc617d8c2a237c7a72f5de3d976dd364472748eb38bad313b61b25283b9001e0fa516b3c422d2b13f85d27e66576565fa9342dd9d17f1bbc9224ab6bc0c93665adb4bf864260cf8e2320b2f2594f6b0bd42a6a5e2c108e00a2a935d59763d6e4bc90c8ebdfceb2ecc9c95538fdbf5330ce3f352f2e9f69c7248166981a96f43b5a5b09ec51c2306f552aaf79d8bfe44f787854c3bf53ee381a699ae5e2e388ef872c2276d2f62aa5cfee67cb836455150d5bf5f23fdce7cf300c1ae72b89fd4f5287a527af8c2857bde1f3c3fa08510332d7bd2a8c12a108347cafadc28b8486ecd378ce72b67c13803cc8c67095387ab1880adb080e07cfa8cadd2750ac35ec408fc344b4f6a079a8f832c8a94e5c27cb49a4f7c513f898435cd436096fd06a6860d5bcd600e3ac672f992eda130c1d1feb9bfaf155f2faf2da7740cddc03e4bbf216c3ef622f96738ba94087a2cd8451cc2e719ac64e376370a486bfee0f6ccf20dadb060b7a9529f80a1d107481d782d4a2178dcfdde4d6cd456fbb579167f7b61d6de46fb4d8b05b5850483743061871606d9b881c5fcb489fc722b8ff32654b97431610d502cc744712fed44a40b88df8de6af5b16ee19a69104014947e23cdf701dccee5960205a8fa3edff1e95acc65e3313b0dbda366f35d02269dcfb744567d57a4521910b3959e16ce90d7b024d7a64d7817b2b504960feb5b4f564aca01878da72a9ebfa6aa1baf20e3c7c8e53cda9366a8c69a4b775e8135f4154570de30a15da2285d7700fc939ce7ae109b21f71f8cea521c79d652b1593fe7242a72db21d0b2b53ead24cc4a8f1b5878c2aef6be9e24a883f82ff59f46c57067eeea495688203b93f07d299bac209f8a54991d8a2a290665bb0dd167ffbf0e4317232ddc657d1ce75f639b9d0bee56bd2404935556529e841800c6c695561e0a46d7bf3747748e51868b604f2ebdbec21e1693e9e91aa8ec7a23d46e7b3fb9a186bef932a9d1e5a9cd3ea07085bbf3f66d34515577b45258a79e5b0e39fcbd23c842779f9c5b44e4992e2a6e15c1f42e76c4445d6dbc76f8cda0f9cb12adcf19476172eafd9dfddc3ee57c4344a0e07f1a0b339d897610aa26c30708ca965c4383beae83ad37e61255a0cf152dce6e18f2b0fab0407d5cb996866c860e4c57ad448fc778a9bd188875c539441c62b8ea4d047c8130f7b3ba444552063ff27ab55fead0ffdcb5f26a60a038e42ed418b144963e9f8139944b5eb6276838987813edc1cb434f93f977592e82a7611cbc8b38b18d7eb27ba59aa20f6b78b26ee0980d39ea6aaba89b305e26f97c45b57d6449607c36ffe259054b323de3f2222cc58cf2c63d3f6448cc24a338bdef616c97237160d79c3d74773dd69d57add2908a961bd25dbc46b34e26cf9ae244534cc5ef22ecf1c811a6976806987db6f30b10bc61f2318adde78af9acc946bf26ebc0f870cf678eb25340b94db95b90048405d5ab12b6393b1aae5b6c664db6d70b4b8844b4a11506f1f2e85b015214a985c0bf7c00b72d5a8af7a252ad380122a2a7d60ed88f2ee5bb9407df8c35bbb3de978b7c4b5ff35d0e604ed3badf7b5de76436c23aeb5eecd9f5e952f9db863abf01fb5f346a98df33f2d6fbd9aec3efb82b958dc55d3ed55b98ee672395493773b7e72d40b01a538bf0e2992b969d46e7f5203677c0e9ce22fbf83233da6f1abfe5cc313b2be3b0eae7a83bfcb9e14217cac0b99a52a3c75141ee67b22ac4e6ee686a4f8ded0348bbd78f432857e6edf6b76a99335c5fa3d3419810a281981ed421cadad09dfb19cae6caa66292e416f6c32cd50b1c285a330b806af83f29ea06acba756ce43a2d5cf82a164170345c3d58dad4cbc026f48d39ef0c62fd7f4ba2070479af7002bc1d41fa9392868691a94e6e3f91a8983b38b7c1d9cc68ee9c7312d68dc3da3fe596ba49abd0283893702bbf7a9bf0249d2e94ae5ec9d8723c0d9b37abe06321f9abb66eccd1b60f497fee88760cd9917a5be62887d7b020675835cbaae5541ff159886fbd4a9b6815983ad40198fb326ad1cb13511843c95052732103738e3c512a9afc26e519cf6ce49c6444d116607e41668c867966204f8a9dbe58a6cb8e426e61957b1c7b426e73cf76fdb1c29d79aaa704a8567ebd096725d2861f25305eef41fc80f280bb53675abc8cda586f9c51b51ef1ae23736af07f9f18fb1cec3b23f3a7866e25d75fae19c541f081fd65220ffd0b0b1f17a2ee2d9dd5e5d02069f321c12df1fdeb9ebfa0291d9394e9c8a42028a44bd54d7a4c6c08b34985914e02787f49eda0b1f20311ae0f37c9fbf7ddc9474a9168bb674e220921d9c8555b11534d627eee63fb378835c46a0e911d1012492fbac7c797a33c0b28ff3906e64ec4c37e3a0959c13099e7a0f2380e69387efd256e803f56bf1fb7cfd0afe649e4a7fe6fc08da61a6980252799d04bdc13f8419a55d09869da92e0b2efd2b7854d20329c4df7ce96f7b4997207a5d875a413d8aea38368fb38878edb5e43e6587066e08e1f4da13ec7fb5c84f222ac7651a24e022288c3633adf55a34f0feb9bf8918635c629bdef6658e271de7a96b1d08ac74653cc7aa8227d44aeb527663955792a0584bed599b8edf4b994eac5f0412c4fc9981032b01f4ee6ae8f2a63a33bf068d6cd4a7c93d4c784908787e8875e0216431a8f6c902d0d7f57e833a527ffe3691b1c28e00656244241b5ba55ef210f841f26d249dc8ac404d1c92def30c02805eb2c5d64930e2f5d40b04b0deefd285d262c0933e900f4924eb7ce9a71dfae936328a09124c6715d628e5890c472db91458b495c5a4214c0213f1a70244c236ba25b277ca1f808d2cf68247cb0368abaa6e895cc4b01f8e0a4eb766b63d196d9c74e6d8a41ce918406227dec9c83af1f470be5bc933050d514a732df3d3eef315aeb0f7de8ec4630d1b0d719f091ec0b266f443d811bc778bc284e41dcf04c6e30de39251bd8ea42efe909f709d2dc9221841106cbdc2ad770abb9e2f38fb39ba956ca71f6f8e2000aa610056f52e4a1369089c1587929da4672d7211a3afc48a21771f8600eff64a4294e518f2d08a9cf30452fa3a91b939018a828966513a0ee248a1e93d4078fb3c316ec0ad8067aa2842e40b7f2e56a0a3901a492ab67680cbc9acb7c5ece5484ebbfbe237d33acadfbc155e58f44b14c086f17b23958fd4e0739115fec7e7fde7e70243d93330dc23187c5c9389cc202c80e7d9b1936771b15398aad7b6ba2c3199a1e51c044d40b43f0d3ddec72169f080e8cfcf29ba718409aa825dcac5a7557137eaed574236138fdaff7bfe71f6ab5872bed050e023e80dd430c3c77f8bc8dd6fdbfa9010439e3005ba462ed143679820496b5684c0b7033620edd72c148e928e04f0bd5b24f52b739ce883b42920f506ab660cd496baff9f40e290c7dce57d553255f2d039182bf46c9688c019254b67e3bfa8abf2837fda0b5fc58230e5bc8e8ed36c32f3a64d8248b3fd15ce93ba232d05194f5e10d3bb704f38fb285f144063d1ddd75ec2fc7c82373af564018d5374cb61e4b68a90859517e425f697a9977568c4dc73bca695f4dc1a5dea66083b0fc5ad9e094a6ab824a50b59cb0c93f9f9cc3389dbc17b5cb8dd6bb2f797931da8f702f2b6932628da0c14e8ca5573db0cfce187f4a62f0e6a03f1b2964e44a37208f5ec3ebf4abf5ab1be33c9555e751dd3203b79b1e21a36550c6f9221dd0fbee2ba847be72099782d017e8f29b612d40bb25dc0e18da7f04c0e4ce570bb3d7c31bbeb7b830d7b6a122805e01f1d07d32f86c24f98265e83cc95a4e645d8bd1c6e16c1c4a7655d305863d8e42f34b6a89efaf444b4326f719bbd7893cfa9860067c74938ef075784cbea293326875383252c354b6b6b36c7870fc68341793f2700c1e5b2b1b0786986067731d16d5c0ae7ce7a5faaa3be4243c0d4bb8f6aa5ddd2c8e748cc5fd0aafda41abc0ec55fc7f8967b86d2147d1b7e676605a5d25347dbc54d41d8da3e0dfb06f0ac3b5e7b6b72308a30dc3275691004293cbeea9b2a668da707cf642cb06b6346559e45eb556b9764faddd65dae0c95e10a4d5d2c3a900af66643e666771dd018178e7fbf943f0de5d81e641d166c0d1a384cae5f276445868748a267e0d1363b3eb199908b1c595e9228150dbb90884459efd93debf6f3f236758183fc5081f3e8c7cd5c979622ff59bcc952ef36718a40a245b2cbe536c81bf11d4e9fa7cc51a3b9fe89eae9747810c7dac1f173e1f7018225964c1bfd9f6a034f7ef789bad5737b4be95faf5bbd50681aba259d8daa64001ddb9ef1e60a701432fdc1bccc96cca9c60a456b23be6ee534fa6e98796f001f1206e353daae697b2d8506e9efce3be933d940c475e39cc32c9835314a802e57ee887abdf39fbcd0d793e9e6a407bce51369ede8631f2ca6d5694b089186e9c930864512233f498bb0d1f1571d9c28772c17e44bdc8697bd8dee405dc53c8b90f2d4341a7e677165c09745a655489274e63fc28fafbf3a1fc7d8321585308bfde493de9751e70b57613aeb706a65fee77ead3ed429883f74d522a6507acd39ff418c92b2ab6ff914959473afa6d1b715e46ef8cd0549f0de58ee2e309ad12d3912b70e8fc4170af62204b87aa9d0f3f1aa1f5560260814e22733862bb853291e166b5f70b6d139ae7180dd25614f360897a5c100354c1d64b9b1bc6a03ef4ac14f9082e38a07ff06b887a46d69d3afb87dac4498ad0b2b7a78d9a52870608a2badd650a9c42df3abe3876562e500734fbda0215eec0abf7eaf1dc0b24e885721be39d5097cf606dbf4baea352ab1ce0047107b2a11600b2fc4009274ff25e0ebd895efa41a9ac15090daf219e0cfe9273d934ebd46a48d29dee4ab356d2b7d9d6a6dcc6d0ad795601f454ed75b0caa8749d79beecae5a1fd67a285b4a13fa85c8993c7f6e9f519ab1f6826be6883443519516ba986545a077cbababe56191cf1230c2bc0132c52073b2a09c6cff6bef926366fcc16929b92f1082484024795306176e1fb3ed71ef0a07d780a9cd9be30627ac96c01a8cc1ed08fdaf1909e4ac894628f92dcf0a4c6e0efe6acb3ca76a64da2e185ad4a7ae365549e83d3c610bc12894abc3d9a31c1847ebd8eec03dd000013b412ae37385892ff940f150d0d0c840e7b75a329252b3fbf536c205a543c772467e0ce22220180afd4ac917132e689889d2fba4e41d1f64f532dcc45cfed0efed872511d0393005054962112ab0342e7905e92a61ba16580ef92b8f301bdb2c5f40fe9dfdb8cd8b63aebbaae4bd783f8250bf5fb59098cee9d4aefb26fb6133210b556ebf6adff5a9a4b1ea7569bd2b31e1f9f178048d610dc5f27ee1dfcd254d23b722ba2df4cf8f266c394e64cc4c6ca8690cfa600c5f48a4f1175c964863072864489182458e4efe6010fd0706294c09ac9a87cf05dc292c86d1e7d62f2522ea2966dc6bbd49e42c88213b458f34e32c7b196cb879658e77ab88199f0a30082211feacec5b35dfb7b04891e2efa4cdc9595fc36a640517ae816f998f78521f872027aa69357b19ee8233062a900facff29d4199e596f74249e5dc79285c797fbcdda1cab37ca2a131b8b0ea560b372d36682a7a89d0f45064e6043a74d1441728df1c70597af511d22115a7a539e1ad83c43bae9f2a889ef27f4570d42e47f588673f71e8494ee95335a4e73179f3d21ebae21273ac0e7b7cf9a2d02eaf5a1bfd0bb92986986e11e9a4b9a3d8f2383f1c5d6a4f11ac2c4b183caabd0a898af0134c3a80936d9d7c28027f9b39c397d43719070120b5711ab9123c4be7efcea2e9e8455ea783b4a4b4dd5d32cc83e7fd408d4368716c4f76f3e96b77fb525ac4c17f16dd613f0b029e65d1d0e1b0fa281b72eb8339a9a15d3a2b896d6a5e9a7d429f129521344bc4fcf21b0644fa46d11fe28eb98e48afd459382c2bcbf44c8dc61295abe70cdc9c1fcc8172fb693e68b662b2c117dff9baee502bf7aeffb5a4977209769f77f29fe068480a232267aa600f67b7067b1f76c94a1deb6f79a0146340eca28cc88ab937a2c63f8700088a0d8edc74907d44ccb1cf7b7a837e417165a364c3e13e39fec45dd8ac2bad0a6d9f35ac3d01789171543243bbb2a1a3abe5040f9c8cff7082080a739c5b335a1cfccae8887fca8bb40aebfd2e0db4473ea5a8ccd46ceee7c2f4c7dd22c404e6a41e5e8f9ebd4fbe4d90eef5d0854d504bba3cc73fc37e71c0da120418b8122a74502e20b20f92f86631a01ae5ee44d41740b7be780fba9085efe41c2a0f946f536616175026a898b2ea788e974ee762522b1fdf41ae2228cedf5b5b058f9be6fff73e5b4e36096f9ac51ee680e2cd8d7d287de13e2c7b978707221972de5ecca86287f96c0445a081e71de31395fcf07dea1e21dce3cc8a4bb77db289567b5b856d656946e514444ac5401d8301587e4d83c87ed30e74680041cf6b7ee3c189760a3183a0484a6aceba1123bb71a825f968ccb2dcf8026e4969d4a30cf1c58ddeabf903e700b2e70a02a5b53779032842105dca05501546adfc10512d709bc5dbc0819e115b2940ef6f25e450ac4492719902100450f58a875337d515544980d56424801f957742550b3fedc6e620a383dd5fae9e0837f123403cc9fd3b89117434da503091c9f028e7974350a593af76de90f4ea10b4ab2f42c8eb3d1ea65228e61a8d0c93266d00d36b5cf66000d544a33b97d88db1f74b026f2c744c1671b81908132ee24705a35a893baeccf901572ca62485c9c2f35e4e774f9a2b246fbb95c68391eac36b6931e16da32ccb5dfea5e0f632cb3534675bf83b81dc2c12393b0cc9d4ca7d9d37271cc3ac2e2a4b5bb38110ca1ed9d34952432456227396327cc20c71f51b17eef4dd11917572d5ea4235cc8bf7c5d6e8fd1b0ce8029f867183eda2be5d2d65941845d37b06f5867f934e7ad2cb108c1de917be57574941d79a02732a906f4e15991c4fbdd2b765ed899ccd5b3dc0a6f10ca8088c76981821c7c98ef881077ad4d34de84c66adf598d54624989474e498d4dc0f6639b7516e46a7418bd817421f637dc6c772bc5be965841aae01e0765966467b43b1dceb166209ad5c1284edfc8647b60c9298cd85d5ef38be84cb4c436e903650e8bb5e0fd3667394cf880ed27d3493a47162d96c36b3221e5e83e6c110920d7c85a79ff1140da872aed38736a8a9bc24a1bddfb45ad627439160eb3455111f020607487d9c42c1a140eb0470a0f1e583ff6c719bb1777ba55762ee060e6e77ca56c06bf74124c3fc7fd0763eccf47b96cd3746fb0b9df97e1b91c0a0adb34c4186b54b450f4c97da569b68b9577677888daceb5574d7a7903ec1b25ca8440ddd756bc5115f190dff890b184da95408b5d74733c34ecafbee5216b939fdf2dd2f105707df3b038101fb44af26677b5c84a59cfe4869c78f3bd638ec10b6f5c8d3a3087e29c8124093916b5738fdfef9ad9c18aa971b744c750ec3cad4ce3aa6ffa617f6a8686ee4aeab28ac81208361608fc4e2eea25af9fb978e1108102d5af8f41aa6b1c5cd5546bcca256484eb3255fff55fdc087249e197b127f8ca1ead623373331cd122334a6bd6a92783f1cc410be37d4c0946fe967267e15be8aea02f0b1d5dfa4efb78f2e8007fb0cfc32b8b48ea6d5c4e7f0d8a855b9b5c2f07ab5e2def0bfffd1ffa237a580e0e0c60b6052b496079df7cfeb51dae6fae7c1b7157666d71e55924e774f3aab2056d1ef3ba09ffd189c253cdbbced331477a37d33d2ddf53bf1e298606120f6a9a090867e630b7e75c0601612741cbf4deb678f505d5acd1f11dc7f6c9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
