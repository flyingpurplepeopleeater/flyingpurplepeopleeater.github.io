<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href='..';
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37c1c4a9ce6927bf1da34276640e30d9889035ecb758ef75e9ff76d7b0acd77813fe4b2131127ceb8eb75e4e29a0cfd5654b359e8175dfdb7d1c5a336cc26f7f08f6aded3d46e82fd4a93e87add8f3316f13d27ec12e94133c483d401974587aa09b1108a4645eb401cf21ef0ac556bdc716ea2351c4ab988c004aa8e76a93a52c398a2af8d42510ad1a28e1263308724e4f7f8a6989c1d7ccb50065ffc8969fba71bccea59319df6f076bcd94f6d20a5ff33912044254ca9e3304506e2cef5e143586ffc5440c1be3f9df3b0c022a966373051572212b3813052e57d461d2e77167381ce5ad27958e21a8ac724f2c35f43532f8635b5b3301127027bcbef0e7f844b81f8ce69bd613bee2bcc9bf503677c07235b6139721adc115336957ef0a296e6656dba9833863bf1e3883dc516d05d95c3cfd245f311e64bc6154482cce57347e00e46afb5288fe16adb6902792ec098bd7cf7af4354755b181fa250eb44d5e2f8eb03f9d54e34a0f8ad29b10ac164240179a45debf52b55d8483ea1c414686c376ecb5dec1cf59057433da212adcce0cca1a696fb0a41a66c4d2d97cba587e3f953c16b6fa07f48a55e23e27b3066fc97e9a89c239adc23d9bc8bbba6b601aef5ba22d29dff6a0bde908d69dd50aa48209836c3b2628dc3e9e43e690c2e75b4bff3c984e90202ca4406a928a13951f3de9f59cb0fc784fe68567b20f227d3f8a01dcecd564c7d4854ab8740a917ee96cfd7a8044497391c48444558d21469bcef4e9a3cf157327c777e8cc6af99a59ba20fc6f659b21c3c726cc85e2fab2e1c7d3d3f92e28a207721c398221e64d26435a1e7f54de2834a7ef58a434ea20b485f0294327393fc730b5eb2d2945548849a3e2ed2813ce69f2054f988c6488bed799825fd449750cdf1b562a483ef67379eddc61eee5517ea3f6fc2b6a5f78c9cd9b0666c3e176692bb796a08d7d650e01c1e86e651baab3d927bc5719ea3e59cb91420b30caad73f09471a1ee58ede27efccdefe8cb35fdb5dd4becfd13665e285b875a67e7e8969230a2cb4719eee9d495b51ff17b1128c7eb6f8a15f44e28c58d1e0c68ddd09d52be320ffc57738f0ee772bde64c13453d30ba18e5ea944a37236de83ec8baccfd57f71dc391a430d4ce76ec068d05750fc6106e9c13dc756ce7073ee6ca7df6fd16b224d4f1b593ba602dffe1e73251c788ae63150d7b0c0c599d820cf8e311df6d760a86f430601b922acc349d824eaf222a49d782790e457ea6f6ade1786ba9ecf436ab2bd901bd58ede8ffd6455ad6b11960ecb15c557ec4637a55747a4371abc2c8192554f5c5a0377f93b1a5d141c9e05ae26ea00e7b9e829cc7f7948103b0c4759354eab05f8b628af3071d4c29b8f69874f5b925f89e5c80db6124549980af9240464946c6a20a3abaa5c02c512997bce4b005d4d154fdaf3b814cb149e61908b4b2d32722f4e6d2f74a874e7e82bdfca8479cd33efa57cb21e9113ef82829380c71374db20ef716dde060af3fe4692e4149e96f2d81ce720741da5a6cdd3f6449f276024d02df4644e39dc89b8fc2510ae7044affcd116c34cf796eab75b9908ff0c5a458ec0ce6a64d67c6d2ed8780d28733068c13dd0f0582911a715a5ce2d530ade91509a53ca810e0b58a1ac650ce487d1fbea5bd78b5a3c8e4e2a8c926a77ef45e414acfd74908941ee5b3b9474f6951aa0423619c90e12746d1e77ac6b58eea631bfb7e072c853dd42ce50b79b335cef6427276c0f799f9df8c7f739a883ae090bb143afb7c91ed3eb30f9a5ca40f84d56d519f2809160ed1af00b7b7b1f80143cfe65e529df2e5e893cf67b1e72554b2931d44fffbd5a95cd7536a1db13b42b8c2e95b0d337eb62cd87c6cece3f9e043a74d513943119e22f80e23831b024462d9a3c116abeec265aca14ae045cfa5764c90f8b764a8542561b2aeb8df3ef2ffff7c7cfaba117fa9076bef07c844b99387abc59fac31433d5db9d21077c2a8c1f8fe06babcc574b706f9e94f901dbad02a18da85cbc76bf0d4c6bebb745b65d34349990083696fa0bcb5277fde4f0a95b7e7d2e01a0078f63c58f2a3c9c2bacbe3b8d193c9d53742938a29503c31e2e9bce537c40202bbf09ab35fd7be023382013a94146d2709d55a840c850f6a4c576542ca9d3b386d919d2c2645b084f05c964bd26dcef25f564a3209e7b6f4f3a7242ad0f46a3c2b9d5e5da48945db7adffd87449a1971e01f18e2e19f87f889d85920002d50a1a481b4c2bf38002f919da4b8b49ad84cc60dea3fd875096e02a8ca25cf5b91638615848595f6f3ba29047f817f5161f9130f59f4c3c6211dd93df8d4d4de6ffa089896d5b24d4deb2d551776c3864bb084ea563f38155083dc1ec57328174ad5e0cd05d1ac6552f0d32dd667bbe40bef68a8d5760c85530287dc516b5118344113f25c77b2f32465883d8f875fdf9425322017fc05950631fada2e361757a8308d9735330ea10faff9d43cdb521085374ae092deef2370da152b503b6acb2068de174db7f47354ad89fb5af7b3787144135252082ef5d8a2412adc7590a407cdc735be8f3bd92e0a5b2269f5e1065019e7d182010a775b7f876308698847f48d2d05cbff37ed95a19eb24a4aa088f05ede208da4cfb2ac61176c82f0ed3c758d7cf1646020be69e09a47df540134b7d8167ffdb3fabaa5d39162d9f3b5d5509a0537cec555b4777aa5abd337fedd15bffd11bfa4f7125afd472b486df2cedbff129101260e70a72d1917a77093fc29f2c01a68e979f73e7270a0366b7ee184a1abbef7578286c2f134a17b04edf5fbe10d867e881535d7c4d2b37c12c7116f342e8fb171e52ffd4ead3164bdd6a4e5e4b041e030fd37375164ea2e8d2f9212d610aef10c0300fd5eec33ac28d230a9074227afb77079e07546038348e9fd475b3399d49b93d0166839eb1193cc0192ee0a1854392e8162e04133d3d56b33347b56ba7d7f33778d9a2af0f606fe78e47eb36c189ec0f4e5fe8a1b9ead206784b651d13072cdbcdc5582093d01dbcdb5fffd27fbbe7a072b4e31036031e1ec4e811ff27b913c21398afdbcc9ef4e9f7f37c0afce1cc6db608e83d09367fe178949b89ab97d51aefc39a70d209969345cbfced77aefc40423eb2d9f1176f6ad677d4c95d4002d5cd790aff11e3fefcf1b6a38d918d3e5929ba0caa423790a53b52dceafb2e3c6b00ce6a7fad56c6ba70d05ce06448fb0a422d66637d242a322ec112055af93bffcc667f0c61d415b7d84f2fd4d3b2d278ae6e3425372d270cb4acffc9d050346f4dfe2443a58fba09ad28c53ca684e231bab6d93fbb45cbeaf6ceeb46c6be687dcb01a0afc1c42249f4c895840237fef901c2d5e698fcb63fa93970caabdb1093c370bde7a544b13166645fee606a81b855083933a5ff3c16e849db89dbf35a122f9f996a7d844d7eccb0b782484e966cf54cde57127ccc8e9708f3543b6e7526abae7db29a6781202b05f10fb6293ad7c87985669f0c73475de6d23f7663ccd7b0a838ed3d7f022c931a93a9faa4add5790dbebaf7f2234bc471c18362d0b7ffebe6812d929d1100d71e793957bda845dacc450319fa44172401f588a0a787be462132c606bb6e9e03947fab7f9ead79ee26b53906807ce7bf731f2c8792c0c103d42b2bf2ecbc605989a2d1cf0eafe479bf27d35b494309b3df4fa630a8970157dc4c5353bf7f4abc060b42abf3ddfe86714e7861f7525cfaa30d761fed795c6857b46f590b48aaea60cded32805d76744be472c96561b48f7acad0e696d4d64a0e7dd305034038ed624cea164e222873f43ce16d337dd5c1b951c255904cd1d868ddb77e6ab8a6a379ec2e595d4574bc91c5cda33dfc49579585ec86338ef14af57814dfd0979631745bc6f20a976e0c7d4ac949cc3436e9553a6e0828cbac54f0f6698625dd673fd4af4d487040e5652fd2cd0e2df730170e6305f85bced6036a1cd8f8f79bc87a709292f1304f8af7493dbd859a7ff5f6f1a81dd125ac2ba64a7a043057c3c16cd52a74af9bdfbf4c95ee9fd9c3bee594d58b1902825d20b69c7b9c27528639efc3187c2e0b3885eb0bcf6affb733013e050cf53ab7e868cfb963778c91f504c8d2e7bc706109c2db3ee4765e82fe139f28810321985417ff280536339f37d326cd4bb46f0fc176a2df7733314d97e31640f628f82ecc774708c80da9cba0ece1f14b009a000ca1b8e67151177ebe3c1ba13fe9ffaeb22da5c6e84d25c26b2c54a8e3e8502b183d210098d363b48b60fc18aaaaa7b4d6959f66de0feb501db4eca2afe046c2db19535914d3a3d9244bfb93c27460586cd4b1c3de1068d09380316577b0b115ebc1eda6f26df65abe27a1a92081a70b86b6a5073d6b6043575226f3368ed79ccc037b11d2e0b3b0bbfd8c3b3c6482eff8774163ce43ed133b154b75f16fa8ae98232f5c4282c9d550169d11cde93f433bec6219eaf77634369396544b3a9202bfe469325d9da7a575feaa6ebef7a1b08da3598a7017fe6311385bb218011a4400157d1a84fc644f683b9587212b3a2e107407717e9ab11440fa89e3589dfaf7bb0d4dfcc36e28246bd92f073e482aacd2578e41e7006320ed1ef8863757f8bc5dcdc9c6829fa7c1a3c3e21316d20a3b01de17f65e44be1e2a1dd56b266aeecc43ce347b377096b3563659b0a977a3a5bf7aa1a60e5abb37a306a6111e3f6e0b100c26c91afa41d05defdff1126bbcc8cf04ca33c7cea8748965cfde9bae7408c1dc6b5a634d80f100cfc85b32246139b1cf130ec5ffcf4d558bf833c6628ce92e8b4501a418c402714134d2f06e1d97afb34f97207015688ab4d17d7d094a0fec44db64e19e2df0bb9f2dbf5efa95f364ac61a5b5383ecf8b13782097cd420fc321a134d23aeefb2dbabf34e65c444cca91c781a70fb473a7b99d9ab9db03039c289cf844ed2f993c6bbb5859ac12b1f14771764ec28471d48b717e64809095338406106f5c24a7f6687e6aedfd06abe6624289cb1250e2021a8b22634792c8b53fdff07ff270e1ac6b2089c88949a145c388fece59e182fdf56064f19a7f1985fb46c2ae4f973484ea4e52fe5efc91e87c87e253de8f5aa5bf50c3ad32d0c33aad087a822656b583c340eec56efc5bf7cf382d75579703e643410cabdea74662c25ff536215fbd0c2656c115922890f3edfcef13bfaca4c44033a9f800719789e55f4d714e92f401e4b2cb0c4feed0a9492c038879fad927f7f09335380a3c7e9f8188dbee54649070ba789e912fccf4d0fd4813a5e65fda99d497cd83dcac1becc2439c7ad83d6fb4970912952f943dae47d18bee671e3467f55b2659dc50d430761d8eebd1437c175cc0b78979d1eb72ea78e5963e202004ad9739d909d64a11526af20d893575c03657219f86d45e9af7564b65bb2772ab40fd7d066f06478915cb09f27a222b48a1d0ab5828946602b880e3799e5b34ad9ff3b7b15ca9efe2f9368f7e5afc822f15ce038bd877f79c8de5f074d5a06e91dc259c03b7ce4f5f7d1eb22d223d7e6ade14e3cbc0dd484b225b478edbd9f35dc08e20f072cd42cb0a2e8679c606a1be7975641a3fa5e487dd2a18efdc9bb9ce7d394cc9f3018e1142bb3053132a032d3613d2d9d9f1cf48de51cf1dadaf097fcfb82bdf9a9b51cb687ee26ecf251997440841ad5c311b0d170d7897f3a59fc94c5f3c35c8dcd99c31d902ffbdb93f2bda2072745686aa61d4f7dafd0f0490b76f9d1fd799947f1cc5a787daa7b67baef0e0a9237c7b788d89e2a91b61067d5d3426fe6ec4f39baf74229b73de5914bddeba5b88ba564e3a02a1dfb96f7deb560b35d617d11105472dac9cc27f653bab6b7e1b32820957fea1628407d95f4e1d6144611334b7c8dd6b756aecf2b52e380afce8b4d6408213cb9edf3eed7d295653eed1ca4cdc19b9da6592aa1090b20605de3835d1349c019552f4ef59e6dbc47af0c0ee6ed3352799f3e5dcabd1ea9674975fc9fb73e523683d42feb71042f565333e1c3de4111efbebbe88bed3c6f3048b7c5836e80e415587a4bd4da734f073f529dbbd474d7fcb639802b9f09a32eaad5623f0b58a89642f6bf8dd49966dd313f07ba0a5fabcd33782a3db75b1f86e3c6cd8000a884d495796028062d7bf1f190e623867c9f32a6fd13618aa7e6205c4c251625a5741e8adb86127f99d198c9a226bd49f873d5ef6f92ca0fcb9c2724c7a37fda6d06af7233450dc3a024bd7d88eadb66cfaac5ed2193ec8aed095cd16a5833b75c1aa6126c672391a3c2f7c2b00e8a698aa82b3218f480100f2bea598b0706c93d57dc343d2f8d32a082e80d649c44a75cd70467c87cb6a1782f6c8cf743be572605b38bef28462f4908cabd30a7c873ba5062ae4542a7f307dc620b234c84f0dafe4a31c477681368ef4f7df862a05b3409d0f9d830393279737517d1515648d2d4ada3cddf61f2ac2f6cf610a4470c5afb696a4ae8207c75520c47f633c9bafe4ef084db95e3fb9efdb965f0820dd1d866ddc985fe822ebcc61f4e00ab0b0ad0897eae3f965fedfd768911a5d046a34cca02508bc043ae690d909f7a32f5e45f8e8d6ca030da679cb3aa35b743e0b559dc8c6f04abdf55f3ce6d2d992f074ac06d84e88dd7a94e9739e592ebe18917bf4d93c6d14820435ef7aa6f0935d898654f6c9b60b148c1ef82ee620af7ab41f211ff64b14d1487dbfe8d1ef56da507b8de08af376ba0abf17a6b0274a7e3e547972c73b963a58c752aa1fa9f21cbd57bb8806cf57ce66b451ef3bbdeeaef8941a29dade18db6e51b080067b431ee0e9620b11a53b912185a5d8190b76654f36fdb531cec93a7088f2ace2213f449cb814a66c8ec1aa5f659b48d518d72bd9a1a59863c8a0a697187cdbdf6d709be8527335bcc5a9df322badffe07b6d2d7c50abd5e9bb3ef0fcb636517b6346653f3ab013c1dd25a6ec78e4e2fabf963065876bf0c592318cd1fa6fbca73728f42e26dc8fe2bdb8fa92679d1e25b2a68733ad4b4398ac84fadfd6492d68e4b499c58f6ff217eb2b496d0eaca19ade39460ea93aece893224bfa74b66359aab2636526e7db67623c7d4cb772f99aaddbec267e17ea27ab0a973683d0ee44ad37da5cd2f70c22ff72704113dd41550b1ba29cd2c9b72c390a8f0a723815599056869bb30331220a120d5d1822a3c175c0209ad7fe8df6e0f17336de87597d81a3c09c9981b6a7cf5983f4a98ff97d1c78920202f0401ac38e6cf43a9b4c8b76c46e0429fb3dd2b8474bf0e25c5a3acc82b88be78235b34dcc6199f15ee81975614aa30baadcd532f1d201402c5b674e111d767216196e5369f49aaea795400ab5f9ffa7fe5c2c87e3ce6bc436363c07bb018801b04aa7f94487fda08868974c643a0ebfef7e253d011af66fea284a0bdd581c9fcd6c3b9131e376d4d117f9bbad99cc120e0cac7c84d2f06eb4a76c31b86e697e80d29df0e8debe820767dde798ed3940bd1802591ebeaafd0f58fd0db4c3cd6dcede840745114236318704eb48e8feb8b902ca4ec9930ee9d859b067753558f5b108e2c90c809f331441a6a42f4b2ba65c4fd814c20b2f4ae30368dbf7ad0f75591dd90e812d6cf0c27af1e4853ac594b723a1ebd0464716aa966c0c6acd750e89e1508de2b1cb1bd0012fa7bac46934516c8bcb0e4c266bf3b3120b7cfe9f369188fb9aafd7157fe0a98417c68ab6c5bac4b0419d489018d8a7dcbf43af2e05e5bfdc812727e16e7de759c26ed0e28e18f79636d98446cabd4349f9a251edded5c9edda42f8edfc3c2a1817c718684f8f8eebafb1d8af710ef1fd11d328271121d8542370f2b63fa45b4c2d4716501964d96f0cf45dda7e7538e426c0466785835c1e2f78ee1c109d386fdf1976d741c10fb1c9d70b879a42dcc09995a7d4d92aa40b4ca16a79fdafbf18ffc8f3a02e6edf67cebee1b2ca501120710b5ba508bd46ca1189458acf5f6cd1c6717094a5c348ed04018046077c343e9b36c0d2a0ae21b1af72e23a5a9e9c5c3e4f241ebb6abc454d7f2843727ea85257e92c163a12f6e57597ae1c18587fd16d201236cb6f0d8820fbe23ae727dd73da259d2d2a6a2a82adef22b9fb50bfb724138d521c738224ec14632d3c36ddaad80634e6b2084ce776986540c97677acb8242c94a6f49e1e8dcc5bf9003322759790cf958523eb6ae3f32027b36bfed138fbaeaf9072cb9edc8cef9e27bc655a7ad4c7f2f529dac8049ee8972091945156ae8ff3fe22a7210b88465fe6d0c5546eb740749fa13c5f5d392aa855b524e7e97d70d0c556591866847fd36f7e6338dd68dfdead53bc0f805d77df40d0fb5fded5918f56f2ebfafe6588dc532c83f4639b24c85c83731435edf8ef15506d9684d468fe2dc002d4ecd40c5c3f9eea02909c7c872720fd3c782720d367b00bb2983d50d48cccaf418d56973584aef503379eb193ca6399072bebb906a17215e2c50a0d355518f5436b789228ae4279d686ebf476e4238c4542facbbd21f240ecb5f72589afd9913b02d31def0b6e3cd2f3c23b8d7a4c0007acbbf3a7e0cea97b479a842a0ca272a0da3fad7800d792186ef441ce79488ee25edfaa15e1868384a02687172a92f4cd789c4195c5b83d9c3e643f613712bf36531832f7420b56a0221dc3de99fd2bfcb0934fa848b0f630b13b1c7de85227ec102cc523358630f773b205742136327aa6bf754c9fb2684c833eb2cd54358f61da03e455539e7a036acfab4d3398c7509a9c6c8b6a8902cc93da01863959bddb3c0d8b395fe81fe484562370923e31daa2882675150be3bd8ed76f09794d8b1038b531b8eca20632694a4fb0c03a31004953d0a581c575b5bfd3897062a0e244c5ea3c2a05b55fec9b362b07b2d426a7b36a8cd4c00b63fcf4ce228a0c7d1df50e061dab445efe8836356f597ce4845de9366288e90af8ac7c28b0b6162bf41c5ad7efee85a08495b2e0a6393463e5ea4d7f2d641d6c043b78f38898883990ef921494756c66533c4035110a30bd11af1537188971c04cdcd6f0c96fbd045ba78009221c89c1ff8ca6558cf0fa761713db66ebf3a5a825422ac00c80dd0b1f7e54207228caf826bd8f074fe2f4ea8a0854aad6941e9ef9b5478339e4476139542c7a0b67eec203697873096b634632b2fc533ba48846b925e2fe77c85adc109c90070aa72b666487355df307dab8c74ab2d846eadb2be6ef08be136c37bc8b24c094c51ba702d4e12b2cfb853a8743c148a63059c2a39dd8c086007f239a9ecfa615fc329307495a64d8f9081776125177654fea7b3a67e3e5e295c8a9f374f9a31200c648276ac45ee5d32aac8a0d50930b710695e519d6eeffd46bfe0a0bcb231ad5fc0d4034fa3487ce78b71989cc3dbfab36069b6d616d941df4ac879ce5ccfbd836bdbb4d5f6b8dc2b5e0801159d83d987056f7f8017eca64365fed171a9df3a99d93ed35d07e25c9817d8b3a79065294dd87bc6e6b7a32002de31994d3954645e62279d6f59ad8dd20bbff17e0f1cd9309991f38fe9b4c5ea72b0ea2b9790d443d41c97b2ea9a68daa0f0ed7a2c46c2ccea42e7dfcc7fc565d0d95269b1f32387ece4e1e72a139d6fe7a1fdc09b6f2062bcc0e2e132a57f66edd166a45a940dceb69b287cc9a31bae83255f17d2ff4865cf1eda3bb62052bf59eefe1c8fd700e72d3bdb802bdfefff1f188b3f3adadcdc0ff004365bdace5fa85dd160bec2ee764f85797a5d99e4f4c0c9d4496b59abc533bc55f898911f7beaf41395795607c410f3117fe2362a6449d22fa8f19bf79edbe4c4728c75cdce974e5c51e99f501d0aa2880953d5f9725ad30abde6fbce1fa2408b05469756e35d7f669fc2e7a8cf20026e84f9cebb9be515f95eeb6e9b8f87d0c4b1396ec769811bc8be639a75f71ea9f4d86638bf94b13c11090d907635fe3a6bff3dc4956cf2f978649ac5c0141a45b718d3590dc785881ec6ab0b5a04096592bc81accbf4b00dfa8a9401d8dec0c7fb8ba6cc287198b819856877a6446e38fbd4cccecdf20b26e649a0226084da7a35793da44d4dc56b393c9ff539f45525c5c2d152249e3adb6a0037c4320d1d36701e71b0c503eb7feac4c59c8a426412dd8ac53081b389247c6f6de3bc122ba19f25e987468946cfb896c6a1f4acef4d3908a61f769fcaea3eef1570cac2314504d60a15b531e37ce8203165ae920d0a4fd678d87352184997a29c26c19c5fa4ecff4cc08380d35c360456ad08696032f374319afebf03905881bbaddb6e6d73204d39b911a96e31d4fed692896c08877126e677521be7a66b64429fc58039f2b5cbab4d3989c2a24ea0fa0d66fc698cc0d796784c8fcf7cfe5f4b88514b3bb3d781e706652392c0bf0a8c681f4681120ffc63de6da566deb8acb0965981213ab73d05aaf9174e336695b310ef6cd08165e4e22e667c9f1dbfc7e6d76c3430b60f2c067562671dcd444d1868820748bc5a0e27b40d84ad63b72a2661d25029e4374040576be4021768e69457b18dac21bea38295be2844e2632fa8cbab4e3039851503fa515fe5a5245d6aa729a09fb800737f7bbbfd466e780beef8b93ca149fa069b636efa21aa83f92029602a594d5fcfb3b45e74fd051baec28678b8f93c8a00cd1a95623fcd3d01ed249b0ea05153edd7f58853b3d5d32eef98d38c469eb3f2f39e67047b3c39d0b69eab5bd6c9e5a9a41f15f84143c82e053a97f067bb5931e1c3f226c05ae6db86764b447ca371cba99527d31b28db52a2ad3690feec81af159030ac49a257b2a6a3b3b08460834ad4dcbc666778f4f33e9ed30e7795d646b994c3b71c310c37143f02ef8fd9210792a2881e2e147b3283d819ad2b1a144c3485088abeee905a842d555e273bebc6de1654f589e8aadaa3fe87be211dcd13f164f7ff6a5b2918f5e0497c9c444ff9faf02c37447cecdb7add1827af8cf5b189ddee86e65e25679cefc66f843b5154d657a705d43c5c784a17eead030d4560de236e6d5389d9b97976e0f6f6c8065c9fd3328558f2a0b801635a4536cdef631546bf6e829cc48c277f1b7b255d683967b09da09f52d33d745b8eeeec575578de1e4e23db91b33ca87a9efd8d6262cf3fa3d782417e8a1715bda8098c8970888c4178bf76e7a3d449a3c1bdd2cd461debaf2b6fc0cbb4fc8344c13eb286379a491b794e4f26f04f9c860c0382ea6a204c738ab9353b9a71faf6360a286636781008a7908efee53654a3e75227362a6c8eda0c7675339dada301e4094d189e73c35ec07f7a306a2b5c5c49a78b2802be4a86e83fb7cabe7e585ddf2dec6a78f156967f8ea0ff1c400f18b9ab49eeff9190af5bdeeee1961dcda102b5b95f5cb0aefe3882b34fb31ccd407f9e3b3f1d619ce58192a7665adc41a0d631e035ebc8354f35845bfa432c4853dced4d3c77fb7137608bf594a419c234124870f94ffc3ca860d2a8ca46b85cf5dd2f5cc5ed8c16c000e09da1362ea918cf4ffb25350a7139d785b36a4f2f50d388310362cb57d200e61a48951dcd239a4e43d41b6cff632086b44862752dd89af2284a3cde3f2a5fccdbfdd94845b0d0e4e2249cee7d4d1e7c7835be1883e751cbfed8bb1a65a22a84896fe9a4d20de0088f96a7eb8bed59aab47257cc9f92855cc355c107a57759b3986350dc54bd1ead37ecead0b0a4eba244388aa59fbf1962892ca0082a64f7f6238d73eb4550be60a56beb4fdb50e7cbb3921fe29551f8328ad58f584bdfabdcef84a7ba1801628a65bb73821519d2548d22f016adf30c842f5b0618cd3e9a62d1251d2a5e33ae516488a1806a93eda44371f1811a797f04d41ab79eb923839de373404dd6f575532d25e697e347fe34a7458578e96f74c0c7dd2a80b1540f520f4d5485c68f18016b00ee6e27d94641e314bc8a0c63666d0ed12930e710d7feb17c92ccddffba4386901cec2990c21cb9470d499b274208dfb3e60df2d2db24611ab4f5c692e11c17a584a204f2e9158a07c5cdb1077dae3cf2f26b6c965714c28b8689bbf704b44c0750af192564372b2cbba7002803a5766409daddc683dab73bd4b4d57e4b615eb78191bb05dd0a26c72549a02e04c026c009003834d17b2d1bcc53b3bfad1399b3359d057dcddddc07eb275b5f43f06683556cfc5b638f37c83646d882e0b602dce4cf67cc4bddf16a925c7583aae75cda0b31bb1dd29028bcd471a57ecc26c44bc3185199705b7cee685dac768a534edaaa2dbcd7e23981eaee55f2e53d51031263f3bbb55cbaeba4a64d4d08dde2645a2caf40d7a2d8ee0bd51093b2b60d3c546facd870e2ccd261438b57edaadd8816916a29e4d03654f20fa445901ee963d9cc04ad033a707d521a77c12e1b847981424c12a834f852e3732e5bfa3fa527619df867922b99801bb2894d5a3d83f85463f6ece929f556ca9226b6ab68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
