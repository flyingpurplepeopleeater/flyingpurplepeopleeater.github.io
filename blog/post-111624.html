<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"649268fdced10d41fcd1fd006ff8ff19a595d417a32615a364b796d91989f616b475f20ab19f8b62f26c7840ae77c3995613064b7c1ba8fedecbd8bda79fbe222c1b5a893201d556e97c81ccbebe1243a5056b300b7fad2a3d5ec32067409eb563e8014b72bc8a5ab0933b5d99b4d288cace38ac2a1fdef733530dc7671686565b939f335eb40903e41dcf2194d5c2b9f96f806cff8db2719e1a5fbca299fac9d5885b7f5af17c5ba9b7ce2a5f3d8128143e5f6ff0d275e3bfeb55a07ee98152c8b3ead2cdf6c9bca1eac2a734995925ddc6d3fa015e9af27956260b5f13362714e80a818d6070bf2616a476f4e8a414169c885464c69f05182c68c05d896df102c29d81e084c4f08b9920e9b770ae829ac98d26d1a64ca6eeb63ae18985267f7b579d6155fece26b24b0d6b167d41dc4bfd25407286b269f01299cd5cafc70f11e4b1b3ba8839c406545fde68505731fbc7a5136eee75c2627f44a2134e69c91340bded545c23ecee2e597d214240b989d9c683f48a6797af1ec4148d11b164cd2ab6a17806c41d238b8190ba363854f3622d887be61cc8f7f74f0cc0c1a5d9afe1678ac40cf447a9174e30158766f2050ae79bb59e4df4dd0b105943fcff8bbf13edd92d944b34516a3127341c257978f0f4906a2ab1e06b6f832f8f4e5f2a66f26ee8c8ca78b6d4cb3b03373c027a94530250be9cf22048dccc694f30a1d94201f89357250bf5f8125ffd16fed257d18be844edc6e768f39446c9f62f9cf49065abd24f718d8c4da0caf774377efbbfefd9dad186977e8120f2ad216985f5cc33608e65042ea327d6663f33dbc5888fe4ef6952b2336295a17f49f8556d3f106ce76c906e4ed921e6fe2baf671893ecb0499f6aa8aa9d728eafc3e9bd76b1cfeca09d1f44bfe076cbfa3118115933fb88a57491ea6779d260ce40cc83ce6f91e479d2a19857f32a9977124163569f4ada888a47ac1c5015f578692ccedb5e3201540dff369a291fcc364b0b72a5c60b5d2e2aae8b059618109dd71a782bbf0ad0223337fe62ec69b1d7c4c59b1f4df459ce9a0f22a65ec45dbed9c9f3498cd94d33953a329d7899881658916f75fadbaf01779ffdda5e466a8428e8c90d85825ea0bbc6e61c2b90768a537efe6ee0ca13425cd08a49ad677a46bc46ed01ac44319ac26fdbbf422474336f06d3fc77d4debfe175cba06322802a62850f2185c209c87f3d055a2dab4f2328d01aaea8f47739a6090bde85fac09f14307a0aa157ef47059143705f19d8475d8dbc7710e42fed565b11eb47e7a7a1793e1ff68720646643e73137625ece16cc0a7d0fb87570f194a98731d58bc43a52715a1df05656195a0d5eb5dfacb22342f104377b1ff003dc3a71ded0a9a58762a64714a7a01c7dc34deafb7ddb770f99a8609374ffa490b72e9a1e84b0bdf0fec403729e1a5f08bf779213647ae8bd816850a3281a9dc6fb90d3501b0a28a4d16f33be89b7df239fbefaa6886da36a58915b71121d22cfed31adcb3605dab646303deef657178a436350e8786fa5667a35bbd723e9462fdf8099c685c27f35f767b70ff879629dba9fd7ca7b00603e00787b62e438b207711211b4aa04b6792a5515d08260d872f113af53e6fd1626136d66873fd6426c37dc56aa816caf7df50437538902df8eb66a9423e41be01afd8e9b91a2ecab1f78699b0b76d7444dc4a5c08868cc49ccba01ba0ca92a26674010dce62e00ac074d6618f11e8dc8e78dc939dfd9e4f23aee98a894b99bb58b6ea0204346c1bca5624a9d3cf9446d6a095cc47baf5e40ab908a67685d3678027910a8aa22c81eaee856065f12de8223a81b9a366217158e1342f3f556a530e8715f550b8c28e684def2672b5911caa4ae6a6442f5faf022a95ca7a96f3b19054b7c6575989b49a09eb8031875aeb52103e2d3b56cd9dbc8f8554b62caad1063e18c4af2538cfc5f9dd43876c0044e235e18d2d5a1bcea77cfdd6a793fb70cc94b010bfc8928eb091e8f3d5f58e90017749617c1f8ef5e129287ba94a5fb2396e007addd39badc38c5c52146f19a1776fab26865b60bb171953394aa808d2c0f965bd8d6baf3afb65fb0a7e922ee51602ed28875883ef0ebaa52258edde100e1d180805acd24c5ec45833176541bd78dfa333ca9756e46ece644755049ead94a9d46c2ba66e6295f1a479e3a5bfaf38a98b7e6f2e57dffd1ba1a41be69162c9cd21c6a6fb69a47d7cb5b23461bc3c55af9fcec0fb44c0a3c3fe9794d330b5f34034031d27148c10714f8014b400e1f9c2da5980f9ce2697dd42ffd4f178541a63bd0ff7262df27ec31b5d82555cf548eb572d49451f905b6ca88c8162a53b3710417af35012ba379235cba9e05a90efb81d256bbc042f9d030e31ad13a8990c17d684ae903bb6826432beee0321c494611b029fdec4d44d3fe196cb4011cb873a9cb5d4371a5904c078eddac9c34cb4a00eda6ee12f850421f7bb4536e3814d6ef2ccdca9b5fdf938f38de7634e46aac789cce85689df6861dbf483453ecbf84cb9528b7bcb8d42a4fc4bd08aa8fb6ec7558da468143e593118d0cfec78ad59ec28122859a1ce42138de686ba85b9413e23db063d88f1bd65330fc1611a5b63d4d50838d07cf9c76b8e25b3683ab5af74448ea559edac5e6e97fd87b306a9870ad2bf7974ed5fb62d35edd17673b199c4076b85185b0c302a3d47e81114017d89acdd71365604d91cc65ac8b66667ad5d9c7b0a4a29e45709dd7347c7613fffdcc798f7765d8aa858e1f825657cb99ae46544e26e7173f3d254390f4cc3ed2df5a7c92de721677c28b6c57dc6fa8965bd9ed766d6261fafdda75b7cff719bd339355f234e2937fdded4f7bef063f468342475b9b225e344384e65a5d9058abbb524e9033c08dc5110c1a70f6d6a7a94ae0349a7fd95c5421587a7a11228fbf677043e13bf051efa94338e11f1bddb8fda947fac310955fd88bfd55db0f9b8bf120e75f7667e64301578c98f38e5144a3e6561e83d8225fa45e05f17ca17772aeb6571e002f8340451f7e9daca2fff9d7ea21dab5ea6714a6334cf12b9ea7d2f97a253f7647b009f59888d235eec9bb9cb01625344815ee6adcbe59fd58522022737ac4de470ce938ef683fa62a66672044a66611800af1d2b9bc05e5d897bc6333dfbb4c69157ca5da3c2d63a9ad30c25fee44be90fa450f9c015633954c305fa23d138aa347ed1824e030f4c1a91698959129980112f8f97e7d1ebe29cf305356d38672ad3e223eb6c5dc64a2e9d85842e98274c815ecdfa7e186109b1de4dac072a0fa3d053a2352fff537818f3111268914305837de0a1994e92e396615614c76b0175d88ce5cd116e71f6b1d87478460221ca87e6315f9df28d30a533f399af3a2239916fd1c126582773ff63436ca00f419fe0c365313085647c733f0d57b70d9e890f2d8dfe56515ecd832b4a3be22154f69d144370583184b5dcf0448f89e05c0aea09a50e976e69c187c7055ccf8eed673c30e1f2169d5d04214fad80c56da5c4f1f87fd6e37a0a13bc848c5e20c3ea6b5996ff914e7cb627aca1ac75a01c7cbdce14ee49de011c9f6a683e06a4ea646cb34f218f30a46e59577203127b3ec4a679fd92534528c8b71b89a9745058c4bd8a25ca2842fd57f811eb6c424f19bc4f0ff20875955f95c930dfb45bfa4cb0944ea1e720b31ac00823f107559f94bfceb9b892fcc180bcfd3ea6eb62136a389fdda0b594b62d834ff364b5750f2c751912983569e3ee1371213b5c38c73d73454f96f92e0485dfec9362ae99b4fefa388fd86f23f52514caa74c446d06252d00b50a8bf9b7b8d471259a21832a8ed4c90613819b09aac073f2b7a3cf1cb6e316ecce11256586b369713124ceaaef59ba77d5b255ca7777f4f99978ec49e288452469e49d30dd332b7f742731a588bab78096439596599651bed56ed409a6337d948fe422ad02413f900d7f24d20aaae5603969d3ed9cde523649d14e68262d0a3327d62416ac151a8b6aa1fbb42b4e26271578ad53ed54d451bd8043aa27afd3ce7383f445d2bed9b5c29eb2fe6f81abccc2560af090d010cecfad76d7d00649dd7bc090c1cdcf44f6becb66602675a2db61f25ce2cd1363a8c7f6841d62e170aab175e8ee692f9e590a2b409f727adcfdfdff72b5c933edfca010287b514a9e32780cd9b574ac255690309a6fde5e9a308887b35d9416d89e2b744b42abb34392a2e558d3a5290e46eef564a3620fcd4bca2ddfe7f4dd7b9e495caa756968b845931616f1a3ede1d88dbc95ef8880c489f74b752edca87786bf4203966f13ec5be489929c46fba039efeb9754a9a30f964f30e71d9924eaa7aaee2c3a56d54917245d6ba9bb3958b905ab7f776ad9f5b1e76135b072d55616b5c4282da1817a0da64393e1e007e7332c80a8a0c3c8b3d3d3fd34817bd875134472cd9127746bff82ca47d870a29a755e400a0f3b3dd664ddde7f821e91a41b0719bde7f29d3c689592d3a0ff5850e95b30dd9fabb3023ed6ac2513c31558f39f5226353043abaef371acb8774c3d115eedcd87873966a435b7df8e1a207a99750eb98f1e58072cc10db4f4b0a7ca9a9878028a54ca4cab5f03eb154a06d223b1ec3bcd024e39b32ede1be099d6eee9b03c986eb50bfb6bef122460598dac045501fb0fe80959a6b6eb31e11fd983b3311bdf0c282f3612c8ad784bec20bd1f24fff0e476b21ab3a19586b3f753c9f197370d898a5e2cdde903119d64d9995b99752ced176fc11c4aee56efff1bf5064299fc20d40a9be207bf33289979cbdc551e03b6c0f8a60bde193bb2f5fa728c5e89e8cad1fc3ea9e90c780d75fddc912f910a3b7b1107fea97e24d368362c482a689723f5f34dd24736a37d7b64e45d3f6d0f82ab3fcec2cd4eb2efbf28e020a634403eef3efc960030e653f301652b28662149fd3951bbfb17edb774f13768613df166a5b241b86bf9bbbc5db30f4415117a5f7c06e3a0ad56972f2b58b327272d2d0f4c39e3b59d1783cfec772a553026796d8b3a6d97d0e374107d3309dcfca18bc89009fda7c054bd1a10d324e0a99047e0f6eafc361866cb02460b5cd7e2138955b1c3787716f69c68d394e6a7b8082c0050a2e69aedad82dd25d8b1a098056750fe542f6edb30d8c569ce6184f069ba3195d65fddd11954f8c7d1bb32536eae2f4771561ae288638501d484bc14206f98c43ef5e9238c7b7c8649f009855b358f6175a9be05ffc23e0ee8d59ab073ce460b749fffdee9d6acc926683cb33cc3530970e9677fa5fda7e4befaee0fcc66bd6786276834ac9461498f47eab85dfc67465cb3c50f79db662db85894b2c3a1d4c6a00b65775ec82efff5f25ef0a39a16f00e7c192d20b2fa8ad8e2e763d27cef909633a153e00c9823b9651d1a12ec6c9c5bd328f6c5fd8b34d784871627912a4f9897f6ec7da359150d53bacc34711198b1efa8606561f9e2c17da7074dc7503d2277ba416fd246c80e67b7cc0b08e562dc50d356adb39cc03de367cd5603c57a015ba6f264d236a504552795c9215926e995664c0b3119d689ca4ec4756f410aefc3296380dec8fe45596bac6898834de81ee42dff4ca02d2edb28be33b1082a121752eb173881897e66a536077920f0dc01cae79e6f02de86babe0fb337a7df21faaa079b22341bb46ad7e4ae0e178786e2ed77f403444dc0e1713c6d537ecbd86d6a6106ed4f627f24e70867c13e080ff3dd29eb744a5d831262d21e607ea03cd9386c48c58e7b3641f915fbeaee9b5329fcb313b7b4b55fadca1322b6f85f731d81a2639a9e2d1c216066284805bd8564e1eda41bfea4da89783b7c2e7267f5075867ba7fd0443914163bc6420cb30b67906173ee0fe1f1e06026b78e1ac25e9e43d0a74a26b339771b2ffcd6735a25405277d2faad378d20f21a88d1d078e2397c8c7b26b2bfa0f307ec0a07f4aefc4a948ca78b57f5b0c9615c6f380b0f73ff32d26252bb642a5d3f78cd59be89ec92e82f5a0a05631a5e28ed706dd980ed2fe62a4ed4fd4b7c577e3917b58eb6eb19f74a6ff8ecdb4d92bead1f032c32fdf83061e439a7ab0eb866187f879bae610833d08c4022f4f8ef193553eee965f4aa95996dfa1362a91301b8c0b121473dfcc096d153526c526ab67c6c2712ffc408595882160d5eaf3e0a2b577fb9d395b44cd25b3a6692919d54ac3e2e8dc7544c1bbb1752c2db6f7f463b9844cb4e4e739bd53ddb7c85d8b94e5607e2208608f65fbb84e7098c19b979c71f3e668cba551b07e425313be6051bdb5cd5f82a17935f60c106690350dac6f0bb288064731850d37b1fd136a464d45cf26cfecdcbf436c41bf0b43760c9b51371fed61d7dc04c59697886b9be4f0ce0b0a92911ad53012c8d9a1214a8e97f117808cf6d6a201c4ef14c1bc381ab04861992a9129258fa341f63b77163ab7f7e48cdde993b10819e981c77f439db43f5e44ea0fe162c39e81f2d1755810d1524a98ed92e0a918487f2bb5687d18bfd8f91c5191ec06a8f70596453dd0eedb36573f972ff6466548fe4d4bad7705d5df3d8edf7035ee0b52227c0b75ef780f745d360b5240dbe53c226c0a8869be2c43dafd5345d40d392f6e0549cad85a64252ecf41d5ed9be458311945501bece3638718aeaa595fab0e1df6d84ba3a49cd5f0f9243e303dfc409ede05944818a82b2357579797db32634f2b4270448185af1923f69784ac53e111adb9d9c83fcb6a2ec9d485c7d21bcb97a46530ebcec586b631476106754d5bda77da5f9bd5d25c633a099aff76ec78f469b9627f056c514a64c509f04caba741bf8266efb3127aa1ee088d2ea11454d0b088e8cb4da886e9d10f54820da52c5f679f9ed40b33589288ce6bb3f3d727d50d921f5ec0517859c2daa795dc2498bec57e70f5fe85874733e5f2ddf78babf31de65a6e042eb591683dd055b87d856939d042374281b31908f9263b67abfa3acd40d0681e6bf88c541738b87325d7af580bb829b7f30affa6ecd27c51bdf5f06827be82e2cf6db9d11bc10aa2e4809362b69141667b6452bb7099d4b9dc5d3f7268012675677876e7a18d43b3be14ba519b782155f42b7c4d96042edd8f4de5883de36f03e7beef1912f477f6fba33b2cfb6ea25c059930a8f518e26d37c2b9934dc9f235878827be384991ffabc4f20eaddb959cfec8dcc6eb88306c4f434c65607413f31ffdc2fd95b00bcf90bb0ccdbda6b9ffbebb141ca0c89ed0366de7b22e1df9642ea4ec32a5945bc24ebd215a4341c8df86ef964330861c6f62585ee5c60ea5283562afda4f0d345f137f2450e7bd94ea0d903176e401982b7c7da5bdb28b1ae8509ce11978e42b3dd165af834cae77296e0e5ff5da316380ddbed5a9024b500f3e06db824c6f8aeadb4e13ac43395ac985a01cd1c5ba1b62b28bf9251f48e02ba83782282953a639397f0a6c360638c34ba9f948076781d1383905b57290218ae2c2a93a86f37970daa2c4685d971073915044c30436aceae0d903c8c89fae8e1ab5989703ff155e7f3241619d34c996f30b684853dae63025cf3b1f54beeb3c8d607bad38daf3c7d8b9bdd8547cb629161452f2c467971a30480cfdd601ffeb4b5175a00a20a8082e9147758e5c17de253a67e3fca66a979fb4da786f04e1bdef20d7b2b411460fc7f06236804c7ccf9b8021ac95d619746bc2dddaa27bd1f9fad11a899e8fd188be04eb1d0f544edb2da7978e0e3b980b227131585ed632ed2d1ca5a70ca598732449f9549cd64304f30aa450490a559e63dad15aee58cc87c67e688fe50ad9bde542b7326fb944e7d5f8fcb2d52120700cc334a210751d1ca231ef2a0dce56a82aed64572cefad193d781b552501f6677c7e70efb2047df4a47442d746a940316aad5f4746e274955afb3a79766b3c659fd52bde1b9398838a4b5b0124323e416ecd0c649baaacf69e40a3fe123a0b9153c005952a59b798faab0f92cbc7d76b07b5d67c6a468d7153722bf0555ed481995610528be22337dd3e3341a813a465d46529c56d202316aa530fe52ecd23ef286281be01296c8eaba77ec165de0ceded2b3e173ee5b2bdb656cc48bac7cc2aebd13e01c0254e6d0acddc33d5db62cc115c25e1186b2cf2ae8b921b5ebd63525530e950d29d770eb5dfe8c75f1917013e06fb8f6630206298f4096cd95e17af6df2e3934e0b7b41402e48be1dd090a18c3560a833d01c25de062525c01f1bcba87fa3e99155210fae0d0ee593ef5df6962d295c1446a5a32ce79fe3e0c08f31ec334685f852f6ea8436a71ae5f3321b2ac8ad90e93eb677565d4a6ce3ce275037d177c1949f0feb2a40935d273a636eb59336abef023b28cf113a6c3888fccc35bebdc5bf74c45572ca99ad045b2b43f36edfd73d43217b1bb2954f4330b228daa087c2b797a7042a7a9d5260d55d2d35b5ba3d68bbc629e0d05f4a828c2260d16d8c0ac32ca9c48efb65cb23f474329d812cbc12886392b7df85c0842ed7b52edfea4abe36006e03582eed8b53c8a9d7cbd277bb39620bcd7e41b38260770051a3c7feac0d74e8ec551cb9c8e10c97992d9754cca0d70085e16eba337318c78dcd967135ad169718c7d88a73ef8626b0adbbdbda14f7864b713c901a8b6e3a7ff7918be052c9e410ac4f02e84f4cf1ff647e90c1516bb27a94677a8cdca127ee5455d433b6a71faa2f21e1b62ac5b243d7bd3d8dd702016bcae562d3a591977c1f4db463172996e981b4279ebc1f4cfc575b0a793bcddbcf59b04148a7ea5998a0f453bf65c4ed5d32dfea8d5cec4c16003bfac2a789c2819a70bf8e4ad882fc5ae138bd2302a7da4e03898834db569d57fed389ba50763292e9a94870794aeffd8b8d129709e7f26816fbf1255b553ceab99b5b299a6edb6ec0df682733b730559ebf39ba07b9ae66dd30c18538fd9278dceb50cbd25ff0415f57ce31af9e315bfac40f4cfb50297b89b458b9c522ab856c3be63d4b1972e831ece82a141f21f29abe485326d632775b088b75a7b61ae4efa23ae291ec95cebe545e90bfc188b1e2f80be768a397dc23723af3d35eae74a9bf8bd4296fbcda14963cbd52e5c59d00b5a406d173528e9433229b65d6d0e225591b3abcc6843385878584977dc695adcc40539547671ec33cf43719f7747b5b7a5a39f779f4b4589e0ecf8304ab37c75b0b18d1d4939a1a141e612d20030d86c14d14a85aeed5d133bcd74572072b5d0fda72ea078c2731f83f17b51d9a23bf28baf36bb7d255e155e5584fa633a565fdfdc5e60b81cd68ddc2fdd8cd2ea4f6445b7a03826df7e7b34f3570da40ae3ef40dc15cf03408568eb5f0a4147a8a034fced6fb77f076bdcee34e8440be51707ad5f472d000c2dc2e75045f12f877f74fed2a96df32009fb4c90bd8ae0e9d3308e50d8583702fe1f13f34b1c08f9c2319a95e0f43e705dbe2b5fa5f5dabae93ffdd9f4df94504c7fd748a5a472b8b1584cb3b521f6efdcba07107ac82ee069248b7141f4004b7fe5ce8f44dad93a78f7c253b8e709dc2ae1f6b613766b1bba277c0d8852ae4ecb367a229278b38d18e6cdb1b1682e0272e6ad735e04c835b371920569b7067ae833529070eaa67b8367cbaa2010c423e0d5f101812c5952489e3066be303d7a15fae75ed34ae800657821375a6e563366b864c3b9dc9a6a3778a3a0b7984696df76bc308072aebd70d645a1db25a12d91c52b691f28cf2883f393723c5101d231532f74e53aeaa3b716749a9d217d4f2674649ba5174b313449f0a29e2a3ab74ce5362cac6026df91b3b40376bc4faa514363b4be105307c6db37007732d20e31de36795b9142e96e8bdff4f1086809783b3a595daff14617c5d3c200d17dd5b17b8eb09e1783e6edec2bced4af9e369ba34759f816edda6b50377f245539901f2dd70cc49f6b58c27e09a73a4cc0fa714eeb5ed038ef5de25ac0d61ee14e99b2a79ddd2e519028c25de050abae962b3405296dd9cc78126abaebb6d084560a7129b2705eada8aea9f7125cb8509089c60699ba97723ed1a9b5cc8f4383154b9724f9393ab9044e2f1c72ed7657eeaa7b96e3ab2746ba3f0357aa43ca50701bacbeeb0587ac3d73629484df1a4fff1631fda193d93f2ccd0b0557ec9e135b532fa1852e6506bea7290d1a8b134177c74371ca637cc1b7c39323e63e1e8c868e941892741338c1f8f8908069eef7f189083178892fd4788b5bedc334a0bc1074d61bee152b6a75ffda2d63a6617316397e3ec815e607048a73459e902ddc1aab416cbbe304d4254a33b651bae7b3efc4d646df493508985bdc60e2c99967cad4b047af0aea257da412b5fd43eb56d589e148fefcec0aaa68a5272f7bbbc01bdb2e28e3c6fb642a6f49921dad9eb597080fb8190d9ab272d0cd70616690b336cc9fdf7ed8de40125eb97621674e4f43e4bab12620f125fa496187a16cfb0e32d223d4bc80a700f22bc4f05d450cff2e97d0298b68a8e1e73708473d88893b884e76a17b752c8dde4d8128d3b2a1b4c2f2eb856f79d0cdf60a5189e690e3de8194a71c07072bdb2f4530a0207488c435b596e43595e72aa155fdf1593b968f56a411d3232cf1f507178d0b768f435c9894a26058872dee8e62c22166dfae1c10e3b4d05a65b480ada7997708e27f1278adf9917e7d47da8b8d515540d0fbb7136f09b2edd9535de741cc3da31f92e9753001077105699b87f7a8358a142b1f5d9a2fd5bb9b74a9a1add6a54468038b9e564f048b3bfd44548017a77591be44ca43bf466210b087c82739a94d0c54274b3972fa4d370f701114487338e392c24dbd70d9ded40170ba96eec49fa236cf545ce08c0b4bcf52f8fa8e065a4d5a954b97297531f7a399dbdf4d1502925581c2a77b1e3f35b936a76c715de2b78d8f53a4001f9af0ccc927021422cd641436ad289f0902e45c22d21e42ef75f34feec0cbd0b6fef458c52668d7ff76ffabee58d886874b05c1599a7d149d34bfd8d7706939f85e1eb9ee9b7dc5a7271eeef5d377026b4df35b589b16863a54ddfd5afd7e94ea3f5fb67dba8829f05c118873af5e35fb85cbee9f8ba088e2e1b6d5a0973d1b1fc4a647cf9a383e87fa741402463e75ee1e6ed6448dd5de1673aef367c0a52c3804b904900a9351cbd7ef8aad84cc86515322727654c3c99b3e672eb6ff78aea3f4a2611fbca9aa17405faa87f643f1f2b76f06a109f7e5a2f9c04f04be8473b378a58bc85622f59cb33929ddaaaf41e1cf90685b213b1b7e39c3d1761a8a0f447c645f4f871969c36cba117db5304ed17eaac23ebbb030a3e52cf844b689ac38f3acd1a6818bddccce25331921a19b9a7629f292de2f0267226ade85a0e9a15f48891e9186f0a44ee4445f0640ca83ad9149ab4080ba26a5504b509764f8132d754ba69fccaf39ef6480c8f06b12139a56dab319c8664b08f4195a0f4fda136952d49ed51820eb5d30e28bde7acaf3a1cd7f62cab3ddad15ee434e9b182dfa378bf8995513a866811f7b269f2b5f40297b932f8584f05d4224b4b9f95cddc979adbb3d44fd05af7068894a95027b927bcfda097b7c29f8b906367e18801a2a1536755847a51e485cbc51d9e77f9592ff56168d2bcee5f133dc76ec38df54ad0ec85f566ebe9bd18b2a58adbc3b8dc29f5471d4234ba8cd16b906a3994c22ce3ed5f35bb9d9ac6ccdbd1cf584b5028edbc2a428b9886575947a32437e0e6138b71c1e796950eb7a2f009e55e3a7b46398a0092298ea8f4f9126b4d1f4efcb890325ed2bd136b78c36b1081b8bb2058bc8f0dbf899f4b92b6bf5c591fff579de59b33b60bd19e73dacf0698dc2a3c0e94d524f80e930fa686cdb1581a498248aa981879688455835d64011ed6a9598cf62f245a279d46553967cb5e8cbde76fdd75dca22317319905c0c102171cbee351d81273778785ed55525648367acded3e3fcc9432aac58e0a5859f2dc26513aa3bbafae4162cdd17709e5da140eded8d009181e8e0eaa0bd3c735b4d9465605b05b85d13db184e1299324948b6e1a5c8759eb6082def29b5bf2e04b1fb54cffff050d0e5a25ec88ef222b3d16ba91e542ac2676938b563bb5d337c9c52a6a8f176126c555976a13dc276c1d8e66612b70a34e89aa342f8ca1350dc71a115b6cc163968e624286e318a99061c6961efdd41c55082439a6c6efc08aa8a85bf6fb5e053196fb3cf67d7c2f161e09fd4314a062fbb48f7e94af1e5a140322962770a4032d704e9e2868396dd401e72cac73c748026f06a391b5ad3259f954e81da2557a8d2a892b0aad8dc6622ae2ca1f7ff3b5c8d4b0be55883550bccb9ad31ae2f018bddb608323abd7fb45fab6b4461a0672b7f2e2297e3826f2326c2a7e6e8332e4c866fb6cbfd5eecceba1d0ce3b61f2c972a3e65e82b07c2302ad15b6c1cdafa634f5cc57ae07ab7ac17877291773cf8841615883a18b31ac7e5e1255bf00e65e6ea582e78c95d8c95dd33cd687fbf30c4961dde9e6339c9072f1ba36604e68c9d4928e0f1ffa8df8a1187236565d33c7413c382939","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
