<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00bc2e8c788c0195990fa6178eb82882746489dd467e0f99c8fab0b26ea582dc75423ff71cc0dbb508d51eef8e2f61f145a73b24a87d407f70e56fa12306c24b64ac102bc3f1a1c5232a6c6d65437ac40e6a36b4fccf9055e1b664221cc80c24d0b1a1969b3abe29fe8754144fa703acfc10b4d4ae3f69da0de0f81674c0bfa55b7ba68ab6cc47beb029a28c041d75378181559283b253407d2cb32489f8d8cd3a84a99a5d0a30d867889387875c1493f582a4cbfba94f58206a9597ea54f86389f3a03755852a4ae1f1bf0a6895aabe25bdb9ed15fd6640d8315af241e4336be3831e82a4a78eeb39ce5dd2380d7389104642a8f5ddd24367b5979f828d79703a9882a2f6c1d78c54be75608feae4534ccdc595a74b645e79e91b74870ccb1451dd8ce6c24da591ce4e8c79a585e265856bb7464333dd01a7a382fc867a3f5e9ff17188fc7384f372e27ba479d37e6f1a6675dca19cadb40104b02ab3b5938839d205f9a9b6c72084b75d3514e7e94c1086b62744b2ff75f04bd4313725a043762bfd9bbc8ae43c779bb78d99340c4f12ac5add2f4551c8769fedaf184760b9201b913ff8f08b7638956c9e52178a507b3cbc6a16ee5d4d86a8f9572e1d3eb745bffacebb9a01568f1a5427236396acc88c0b9600249722e2b796071846b57d5d55e9f3463b521ca6455221c54225a938cee1062288e2f6c37ee3af95aa07df26443ba3b2a6b1f882ee7c1e8dfb5880c0670622e882dd9f118d9fd6194509ca7aab8e9bb5c4d97e31d0d981c7ddadba85e571009e1af32d89a106ccd512866fdc2520208ea542b9467632f836367d163ab76ee44128c6945b8a6c6b6d30b91d3eeeefccce00e48c72824e6690a2a6ec8cfd41872f889c8e595daec3fa1d9a198fd9203338726af50c47d49be2738bc44ed136117603a900ceeae3191cc26ecc8c38b39a61c272fdb2d5f9bbb5675a8b31cb5eaae8f62b5fe8d57f812a82c7ac92f69b2945d01c91cba271e455f336ab9fde53642adcfb8d5270c3ba0abb9f944974cbac38b2418b89fec7e8df5aa39500afd4a624476ea3e4be23c27bb25e4b3b1ba34d0bced830f34cb3bc595e3201bfe0a58de77da24cffe3cbbda169cd1b4671172e0af7130256f18afc27794445adfe3d40d7334827a7060e773430ea806bc5a1a1debc1bc6d4f81cd6c15a1ad9257b0131c8dfa643de54e4fdf45f4aa074073423fdbae44f70aa1531a24fd487d0bd39eb98b7f5f431a899fdefe12b64884d242185ebd1771b6bd8cc23d366e0d4fccea701371ce65d5064582bce01109e2da44abf578af04f8462db34cfe0b165d022577c6b9b47949a568337617af98f8d3e254240eb80100e7269b71c58b9675e470707655c516c3b86484dcb0b82f042ed0d2aafc735f4fa01cb108eb64ab09596c1cd0390c3a455e6aaf7e68200bf7b4eef57717664288fe18e07ae4dcfe2a0bd7682dcbb123439df9c1906f58db631e867153427e57723cf738c5264280b9e5d4a9402f2778cc5594a7626fe9b626539d5f4a7d6f282cf930b65933873c8c46a195571ba0d80566424b6b2a8c7fa6c6545709d6b0a74d2c7a4b6b01d7e17ccf366b5bcb0cdc7e1983dd15152e3cbe17aa09e1ccaf44b088a9f7ff31c64d0e58a44d9c15f9971721e00939da9817a9383797349e2f30dd8f38b8defe73b8a03b30418eca43e382ed51f3d84b434f6c3884ffe9f79df104e2bde6b64863a35cdf13644841df39e1d93c79c8a65eea47fd95a938677693b9d338a88e1ccf840cce3dc722b76e82ce76a5f49769d7ce70099255af1ac786c3d3d8e78081265c48b62e5c13cb222b80abc005cb591c3a828a025bde083ba1a3b0bcadc2784d30ab527c23513e3cc0800fe7e0fb3ddf4ae04f77f6fe6c5a1b13fb88abfd9e44b41a65c8f42cbc296327d35f0ec88ce99030bfd4b1dfa9bff15359820b7c71a3cbc2fabc043f3ef93defbeaf223de521c3765f100cb516da6a8f891283518ee063f1342dd61d8703cbcfea51fdd73d6364ac92ea671bf27db60800f4c9f0cdb99bde8277e0f47fa71db06320c63daa1254df3159274b481758d6604a5b7c2c059eea30ee5adb33344265c0c01692de15eec70f02500dde1a53729303139af2fdd7d5793c40cef51c50fd88ceeb55ca4d82e67ae550f40d1577ff58ca246d2c274d05ee0b9e5c8e624d9f511002f226675fa92c406ff82e5a8bc315b5c764f845233ed856b39ae1ca2c92e4a4fc2aacb14e6cd0870b9f33f94918d8b307ec0a33d124ec0e019bedd3e77c19df6383597d8bea23723cf6a201d77ca60bc7923c5da7e9d0feb6c74c98735cb70d3e41b193873d3e643643f93eca0ac4207df7eeac5cee6a4acdf019b4e9b20605ef38d654b4d508ed3273f2fd5a79b8fe079d6e13bbef1b4dfe39247ac554b55b4c41f8ce8d3ca49e344897ee0d40287f1b1a9ccc202e4b05b5c05a6612d79d857e2ea49523df33221032d8a1f1e0a9ef00d7eff05514ef50326ca0c1a2beb99fdfb1f290b357894accb21f408c02982a59f63e437922a2a7b425bf48984b4ce310bb53c2634eca077798b1addd79531accd2dd9a07ea3aa167df7494092a5a8f6e9ea3979fff12e118b956e89ba53efdfef666c5eb70f0a5baa433334a457acc8daa708ac552a6ae8d098a6e9d500a944308ee5e6fcf98fbf7e417a6534883a1d1567f76c485e996d3478e3ff53b5eb68a5d224a93f426010b1eeb28e9b1ab2fc9ce5a0f24c2b77e24d36717cb0e3b4b2c42a9ae447c58a386e45a5cd31c93be747b0fb741a674e58af353ba3dc34f8fa2d66f6f2872765dbf46595c2d92a6b036246d62e9880025f08208e610952bc0bf0c456b16d54a3b510477378da4d69f964c6e9132298410d713729cb8eb6c67dbb09e0ed5c42356c9643262459e862e1902cff71067932f07decaa89b39c7dda4bcf131c2189f26d9840fa3d088498339da857bb22dff80d75b8f2640643d3e575bed2591b74fb4f00ec7845921b437826e51f8db0072d08f2354c5d6856b1789dd5973e7295ed25ff511e798bb4f38a88803da3f9e876a87bccde3611a95a4959420180f0ef51fbaab0d907f5432187078454e98f8958c7002b33c9fb10986838ef2975954e74d5db57b9b97dfefc6cb5750fa79e54238f1653127153ac3eb8885d23de1b265f9c6260aea2d13639038c423794187cfaecc445e9196793cf6c81c09953a1588ef51cfd2a9bc348109646ca38849aa1ca2b817bcfa664e4debdd9048bfaf02d7c9955ae1a8694a24c78ad38803b24f33493898846a6fc6827972466c26322a82c1015e1748ab6b13136d1ce52786406e845b69f5428c39268ca9fdd82c2311b8fbc6ffcd6322a7c34c263e39ed89696af4145735e778a9d5369f0f4f19d80c8cb088f7ac0636ee66ed57f5d4ffc20f2f6ab32e3c10f956c07402a447e931aa3280c9fce86402cd5808fb209096d61252eb4e3889b6196045665777bc04e1ecc968830787c8d211c5fe3678f1318711b6a57f1b6f7f0022dc334a4baee3b4f050aa4fbb4a76e5a1d46e9dc7964a67d81e906e419e0ba831b9ae3d5797648c121fb533ade58140e6dfd7556431a863241e3f6725b01544097cb8b3ecd420b0a68d39d416df3265acf0f64c834cbca852a64a0c099b9f999f7775701ce426479f72f036d3230e49bcaf456e80eac0ce257b5bc0dbd44048c61ac01c27acf43307461d6d0db33600e663b6a36d23acb1076a05cb7403b6b791893434a2da84d39c96bdceba51d30b85e0701f6032edb0a1a79c28ab0e91dd5ecbed89b6fb184b7827158169073aab8a1c4be8aa836ae79020529e946cad8ff513629326d0b6a04449f80fbde5f3c015fd7131c0e1262c977f6085ac98d9809ceaa7ec02f1fbe491ebf2d50a87e46afa2a0f90195ba4ecd541edd66ba82cb94b597c0c8764cf299d588ad18d9fb0be634048b520dfb75d4f0b0e5db4d72055661ed596bb4b9bab00178006650fb11616ae47772b3c3fee23b3e50014b550ffab56da6fa168f46364aadc574ea01cce80e87c40d7dc865c2ed863bdf05be90f3cb78f147696378c1d5ce160f203a98621eebcb3323f54e46137f61a5892a220e0ab023716eba8d5ba23ec9464b45d8900168265296443e4120d8d87717255475ccce86542466767248b8555aa080ebd09b1afd66a215503233b85c39e7ae0e5a8a85f0a8a0dfe557eec70e65a20c3677a2453f5ec579743900786f95e8ebf3d6a642f2575b7dc9e2f963a00eb051560c27d2c47e47850de0c0e43c4fe6cd9896e5fa979854e6690fe4cf9ddd02044354bbbf9abf9213167afc92cfd1b2dbd470f8b3eaad0a6577abe71279d4a65345c312bcc9635f779f1d1d9ff959546a720ab11a176ca2e97411d102d65a5500d356bd7b6689cd80ac706c7ab26d4dee989d81f34e3489248726a193b4ed1e2f38c0c4a4fe12510c635c819edae46d826d359a0d713e81b66711872f11123d5538903ec9d4b2b9e320b51fbdda0b146f292a7d55427044ddbb3750a87733c5548c134691476eb0b86dc26f2e307fcbf81dde66ecde046f045e087ac6f4db3df4ae39ae4da9451b413e846f6f6e65b8ef7f0f13d2c9bbbc654cb8838be612991ab73ff8b05d6d06716e96267f1fbab5f5a71a4b72a2a9d799e244c458998f4398c31531bc661ebbc82a8771b66160a809530beb0809a2047f716e79796d799de2e82f80f137f241279c72b00c13de732988595838cb3b6e84a1491e93f4ba27680e6b6784a2ecfff08fce8b53670549d1c60f999cf1377a53657eff3dae475a8c439afd608d1989f5fa90a99be6fae8715a02976fef2153eafae83339345de6845e373822b61404a275779d58558701d248df81178356f19a08d0f9a7b3de5bd4ccc94aabe3540b14a3848317f216f084fda3dc0fd1ada44bce7a2428e7bbb446934693cf6b837c0f399a527ffdc571fe9e76b5c2a884ea450e7f2a6dcf89e473312e0aa2e94f78bd13ad1ba9cd654cdd1cfeb5786f86a2e8ca895a4f287a3114e19868f6dc318f1b5eace3ecf134cc84f164146365bc2ff05654e8916120f1e49437854c64d3256984d438c17bb89b75f29c5f71f1f6d6b1b9673cb58f6fbc20e4e6afaa58b770e9a29235d100f92121bf771616d1d40a09f7a825b05fd34f99984386d788638410a6b26436a940a785e13d7f7d97d6a0b95766006798266be457c84b001e813a51537d00112af1277ab3eef04909f69ca749f4d7eac95c52508501dcab6a92e17b046a866c6c49284e887bff8e2b018efc6f473369d80c4fe36851262913e1a2730a30499f0cd2b209027cfc10fb0768183f2bfa856ca2321daaaed60040f9c5477688ed6b08d5d858dd6db0c33c37926f9473192b79fa82ac1c0fe6f002f5a086d7155f693613aefe06ad30a8708b5409b64e3ab0c667ba4a69673dd6f0521254daa573ae877a61416f351a886ef776ac8053a43022f43ca2ec599619a943011bc6aa23f865096151368bb6316859ebff4f5749eb0e64838496a80a59fb91b797b19b6ac00a9fd727b4e037e2ede5247b87e53b8c2edf3def21e2a65b6487784f882b58ac24a9c5cd064d8096315f994ad772539c25b05dd4782b2414f9111c09103a9ddd61a3040e861e8e8fa2bef2957001fa5b1068a6263bbd382864efdb78918043fc56c1f6baa3153bd346feb77cf74591c1a9dd36badb8fcd16580fdfc1cb43afa21d20ed28adf0d0fe7d40b60afeda5732bd649ad003ddab75d6c25ec7be92e243b597a8d15956b69abf7fbd2dd25709889414a1ef8638894efbd0057607a8d304b8feb11cd4ad702a9d5e6bdf2496cb5937f580fbe096fef00e1fc9b93b3f4c187975ee38594bf8daa64e2dfca6bb5f22f834583c75ed132cc651007684cbf3f660f10cbf851a4503edaf68c18f398fbfbf36bf0244c50abff4f2ede174d452cc51933aa068854c3e65f060d2551d4feb72f519c53279f3975208e704a18ca360e0bc9c873f23ee00e0bb6cb44aa67da59408faa5ced400f6a8fc15a4a187970abef69f49bd02d367e562a43f0a868d4a78adbe5f72cba6f2f1e92b9ea59eeabdad1d577c5d83257195574e7970c8127096d1e9c5ef4d2372ce09e0007c29eb10d7a5a11cb9261ad85ad13077b2990846c2c54f6153871ef4aafbddf20374c3c3efc031c475cf12c08a99a72c856b9222a2cf67c42fc552413388593ac318356328fbbee355e39cb07888f942267c30c7e464ceff3532222521cfa17bad2c34a0c5d21de108dbe0b04e9f435ead3834b3e5cded3af009df8a97ce47e8c4a7b30fadfddee86be55e4a7419b70ce047a831ff81fd97f517c201681821e8a8c24e4fadab942e2fbefbaff7e4d11d4bb7aff0ff091efaf70c79eb6309e05f3a8b48f9cbe3cf1b125150943509d1691365842f6f58137c9fb4d0c253a74f8da23a530fc17917dfc0713178fb87c2899261e4aeb8dde98d48acb7d827876c0f6da5e82a0bf469c7cbebf2d8d60e820a1eaf97d9acf80a0139c2821a52d38ebb4896d73910708fa1eebe270f7238d2493f69f5515fb1cbfa71050a6bf3eb694ef1b2c4bd1b43a0af7b04d0e34afe7702c67383924d1b4c9c2c2ebd0500bc7e1b58ad66adefc1e2cdda977ed9e524754abbf71cf123016e145645ddc619df11f7f6366d113e7b1f14119541f9c2e8f19b2519988b5c33bebcf0e3910b5986cc89fca9dd109f368a527df022e5dffa27ab1f423dd0f2676440f7dfd1e4d1aae22ae51bbb64fb0a42c757b0b1029814cdcbf06d4c3e3bb50acca5058d52b99c721369c004f22ab16623e66412d063e9d7892976694a8d3c608769eb863e541bd72927593e23277c9a821483c51f615904e02bd40acddd5994f917323d89f0279c45138fadedc635d56505177099df04030063228422b1291597689693f61dbb2032fa0b817fa1dd20e4022f0f898905eda657b4e0d7236b09110dbe6a7eabded6a3beae948465ba66fcc133bc42bcb6713d2878a614b010b036e240cfea2c4333658bad0c42aac180f630a2b8fc2648d0d25c09efd5c3881a5f507ec8193d661e36c003ab271af2d79392c8c32c3119732cbf66c341c89884d4950d594a799f7f26cd83961c9619248531a405b0ac19273dd371643ac3229029d7b908d34643c275c3e1426cfb065937f428c39b5ec5489822788de120677f25448ed59b9b640c779fc0615ff85459cf5300d7f40fb45c0e46dcb7614b6fc342556cc722305e8d0e2b94287d70cfb67b6abd96f441288005b1bbd6f339c82c770d4039c4a47740bc7a7563c8417ae2ce53f2e85a743206bec95914c394ec5ee6b531c961993bc8b278c6b0084bd84f6722fb01bd3a8f82a7e6730da841bbd449518b6e4b24857bfb2f321b43a794f8af39370a6323bbfbaef54710e9243a7bd7e1416a50d9cc0906e62ffa988ab86d125993f1c0c6cdf2ac8ad519cda26127913c15fca6af799ace391381a6e8dc8f3af15f0b2abd03f3601235aa90ea188f77fe07c5115f89a782bd69872a291d13c405e209cb65dfe78653d83fba1816859c4c9fc51b708ecdc6f76c08fa8219d48ff56eef77a484d46e3ad19ae21a04cd641ddf05fa13df079db358a7048838b4ecc480892e66cc0b8fe334833bbdfc5d52665c71fe3e1f598d839ee021015f7c6b53b57d9a56b4224ecbf225e753ef6cce444ba50f088db5928557c665f988d44fb9e93a49dcd6e9216ec1fa88b5a2080da1f7a9235f443af6304e427c6ada8edfd34a724dac660414612d6466f0857cf44c87d4944ed4f4e01b6dbc8ed3fa6725a597d7b538c7144329a257825dd5a16814bb377f1e95811dc5a64003a7cf570db877f9fcaa876fb05029f9bdc34e26889543efb9e552b735c2fef1b1476c8c6aa8b0efccfd420d83762a34ad65899e4962865fde59d9f47596944f136c5214d4b5c21a2673ee77039245965f203655a4e0d0374722ab1bf34e7c0b1d8ce91dc26ec01afe55b7483d51c30f5396001cff226cdfd9ca263cdb6a777399c95ae781fa99d75c65ca29d05fbfbfcdfbd9e7524b733ab33cb9296f8aa7eccabf1ac2c54c0d9e922f06ddd193f3a0cbece303d0167a782814a06556a04902a68a4361af63d7b4196ae9c137e326f5a8aa3e27e3854379d4dcbcc855cfefea6992083c2fedc657c2ff7c5f3fcb7f4b6fa3823a4abe4deca7a274a933bb9d7e4c1ecaf61ad40ffb5316b1e1ae63c944b6f3eb0da268d67846ffaa001e35b497e8bf3f3b07620780799d6e5b76f1af9fa185b878db24b161300e761a041617c0bc7fc0c776cc6a6459e7864c7e4de103d6b1adb51d4aedf8d50734c0c59e7d1a619bd96b85c844d87a3ce6f638af00bfa404d5d2cc72d37a72e56b6cb3318fb03cb71df964ab872f8e4eae39ac494b3a28b6582909ac8d448fd6e8d5b58010198cd168004ef3d17996061352eed4139cc0c95054a1c11c1be902e840cffffe0564e48a5dd643e74eec8a02a6602515dbff30df41290dc3928c53e9a5614b7ad5050652819d9dbba4d981c312c62838093cc8f4753eec5bdede21b64ca7816e19bb9f7132d29d94c0c4161fc3189e5df0837c8a98396cbf752a15fff64d0372557a932dad8f9147a2bf9cf6ef3f6a6f304fc256913696ea62885e5b7d946824450f8d9d4e60e9b7a9e3c31054e23463764f379afaf1ac9f1c1832e68314a87a232b112d9bd024ecb55cf89e654053b485ce07b211054031d2d791f49a7590202ac8a07ed58ba8319ad36af30edf8546d5aa718f2a42165dac5bffd99d1ec11ff81e344a3e2319952b4c9f7c7fde5331aac8e36c8d388afa8b3f34d2c90d1ed5113aa8915226985be666a51f91c5e0773e6d4035381b3b059ccab86886e6cc6f985f33113fdc9577feb20cba7ef57a1ebdb57d3d4215dca106c3557c71a0c5b583a16bf78645acaf29ce4af39122e57f517d5d76eb0963b20fe03d64e08eb1c490359e166f42fa6b4ae89638fb5bfe139be616056fa88fe80169fc9bc04363e25333139a2c70a9d112304addf93723c758119f87df551727b3e0d30c63c64059977f0e3226eeb99c8e4c2faafb75bea1d47c28fa3910a2ca630afbfc37e8d5a4f811456d7a73f2e8f435e599e3d338b2b7fd634c99f8b0a117310f815093a077eb52b000a2ed1b3bb304a346a914c678b2a57efcdb2dbb1f9f8b07fce5c3c7ea3a44f48c9e60db51273eea52a91d421d37745097988c735cb347d33565b5fe9314b10f05a5a97f9e51a40a57a84a1da5b164637a4e2447891f64edb191e98b15803f997069195150e649246e196a9b8de0a1342bde345970f54d0c9efaa110046d70146e272d0688ad3fb7f2cde027dd4ba1d6732b210296b8a9040fb75565dd7f4f842d5f776e9b850361952f67828edb2574e72e1bc04a495653027aa731935215761ab878940e23686a4b730fad098f9f88208efc2f8e03819cef667cf49e42b5901376c241d61c8cac8c20318a780d0d0e202b63bb0bb37ebfc59de13130f17d681345970c44917175ff05226f350f4c4cd37f8fe542f0d61cec1ae355fb1013cd9b4f25bbfbde7cb413c929801aea48b59d63d12bad58f4d31298c2b8d643ad22cb65993a07e7aff3eadd930a21339e9bbcbe750bd9d560fa515308ab20a9431370770fcd2c981b5ff9014eca9e64e7eac97c0203895b90289ee5e7780b5607186bf5ea52ee00f11e34324a4309a1f7cdeaaeab759332fa2080000df6369383a98b1550264c907d9b8f6871e0514a03f17f7c39b983043ec97fd3a1d7c9193364cce3a62351f18599bfb6cee3fc64575988c5af0dc7a8c85161b6eb95a95e94eee051844d831c77518969d7cd96ee4e52e9c20b6a79075227dc3957c21cb836861ffee27b94784ce2f22881b1ccad74afd50e09ab39adaa6446f3e855c3a11425275b2ebfff3ef53f396d690c0e9788b89c41b8bf9fb7e97eab2d7dcd63eec243892087789eeddd8b7c64394a1b3e1636195bbb24295672acd01a061a0dc64bc8e0e8a0f32299b37c914f2ca0e820dd9eda7df26975d7e3fb4f49712629721cb96e155b2ce39c2ab732d165be89468460c47aae3cfcd96afb075bb2278893beb65fa9bdceb324d67af9b9dafef16767af693fafa053f1d25295c7b5f7bf0f8abbbb98f2003a9886054d3f9701031cbfd1abf1024d07641efdaebae6ecf727cc4f96666a44708c6b27cd8b9d4c07a1177c50bdf151122f3cd1f7dad22665e22b1a38b04e725fad78fe6fdd40d39f809755527e6afb80e34ef56d040b469b88f68bbdbb3bd38c967b07a31a85665b5b4091e179ff81efc3b2928d7364d1a14f18fd5048667d174a10678437f8e42224ed097cff45d82cbbd88ce42a69f423f49407307debe2fcdb7d1952cb49caf87013a9f216d50dcc60dd38a6a980735adfa371e3cb577c5fe3984131aa6c4b8d8f95ecc09a24d857de17ca66c7968e121ced5fe4af69b552c153a5273b73ef15f2fd2c8a627c277c153508ea3645ec54c43d46c74f03d5fb8ebefdbb13ae3fdd8e2c7151dc1e76cfea2225e47a3695732b78aadd576332d0c9e07a43ba7139cd51245d194267e2b9b819627868c13bc52544d652d394aa4855d81c03ff51ed2e4904c86f75c6bbb5beec73095aaa0f914e519403d45e1cf4a995992f21c6cd36d0adafa01f1a9e437da636eb1762024d6e8a1e2e563c18dfac5d311edb0f333ae8b41a563188c63e62dd9398de9c47bc01cf45b047203ca0133258cd2740788d27e1cacd24af9c8642f3c4f6bd4c0bcc74a270991e5f728a969f61eb4c2db2c225e6b172c89fb831628fe4450c980161d2b7bc2550b78cf6d82e36be5b5425f46fe7df33f1548cc5f74faa9c57a033e66df30ced0eebc64247139aed8a9aac4a1c3a9101cbdfdf6c29856e970523acd999968e2cc4cca885fe8e8661d0d3d9c1d0067ee808178cbe50738ad1be9819304896a8e3cd20fa9a39c689ad49fe2b44210c5a2314ad0d63437670f1f263e872f8d0d09bf79da8f919e31296d702fdba63aa6411f1e00b4752cf1afb1fb3497d5c9f6dd74f1622750dc7c909300a0329fb48ffb1bf61a1f303141929a0a531ed5fe9b3e3ee7616564413ae893ffea8bea0fc6fa75f8e49ee8fe3199f43cde3bd30e65b067bc2ef34d1abe71e91fd402bba87b510d43bf352dac5a4bb57b2614e9afec0ff828c020d5fd16a4c6d1e8de97a4e7196b99d7f16bf2e5add6d70f038bf81a1b120cb1fca62d7e8525ecdbef286f2d5b834b71a33967d68492ea49ea0b040abbab4279cd503ea6a9bf2628dba6adccb05a36591ff3ddc82d79e1a2103011f40d8e1488267b2410e3229e39151633a6e2773d1a4a036f2897ed8094137ec3b8e3e7f2ab16dc42973a7ed4ed3435db34c1e4546f336f631949067a8a7604dbb82f8a4449192eaaecbbe45be8c62f4e9a47b4286fd078de985161b8fc7965f3c72cb4397e4587453d66e3a655176ef15a50f507f0e8a8d39aed952bba36b26fbd89e0b71309e956ef0dc4ffaececc97369354c7b2ecbe47e004e580c0ae16a4583277b18df82b50ddcd8c6a046ea44e240ffd5d4db930b9fdf6f9a8a3443b89c45f6ed46ec7a1e1caa2a8d5e3cd0e2d1eb3ea8c543d70e950d893004ff8fbe1e37130fbbbde667e643ef105eb366ea98f54ce40d58657cd5ea69a762817066bfa5a4a77809eb520a260f25ba56d113408a6e8ba6126bac300e429da4f4d87c4204fe239f2b859738299c850a846f93b5e1a6cfaafc382b5a95ee59d065b0f3a2b1bb408bbb4ee17d917b02f42a65510dd7a74b44591ea3e8bd63bf57a499c590bd959ca47d6acc1a34daeb50739c4a63939324f5f32e33d63034e836e45538b02756a8b4b1d8022d9a7dc733edbeda562baf657ddbcbac9a731ce3c9f71df61f704f19b801c02129888bafe3520e96cacf919b49f114107b097bcb9cc9416f13567cc54cd597029ab69aafaacb62db3031216100b832e21c8901cc1ca2a424e8b073b582935205e70121de6b24ee73b37855bef9385db8ad22c15cf5a019dd9b713c25b912fc740bde632b19ada0f87bd1ae8481f1e968f1f1743bcc6ea10716adb4caa3fa24851733f19b3ba682ecd3a3c874deba5eb50936fc39864d9fd6b7c802dc5ec6c0a3e796a06aa1921ad028b61630970d980d463b1095bc30c1b0b49a3bccb8ff8e474cd43afcdef4913c02ec28d241a5559144ccf2366aa85f4140f2ad72ff6f09c231a72a159f043c2a919a891597a299b47ee4f6b43d0469c84ebdb58f87ce0586f5550c7f0bb4dbfd5204d296ad1bcd03fb9559e1e6567b3da10c2a0f2850b49f6c4f0a21a336d238d5a2090da74dc5e0974182e226a464619c31762f47962d738784271653a4f7feea1ce6248d273d8983e25b0114aaf4b8e548b5e7c51d8e663132391f44a75c1817158267d8a2b2840cf508d30c87002d496edf734affec5183639c4510fbc52efe7f3ba607772c9f48fc542d45b44ab68d328a3c7c36bddd40a463aa95cbbb03bdce11b018869694daccff0658abeba43b5b0cf597d2265f7ccb17c01713","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
