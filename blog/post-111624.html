<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc90f365aa6bf19d0a289aeaf2f7e3d3d70d8caab9411e3c46d693b3854443d7dd1a3fa7a4e0dc432299208348037679af1d42ef7d6d45a0e97764cf2f64fec4b3b80f1e6bc85c91d71ff82d0f2831e5e9c75339e68876ea8e5852a3e72dfa3f9cd0564dff5d1171ea33798522b33cc6eaf6bdf0a18004c7c00508a8dbafade2a5d1ea1552b800d5a8bb095d052b392947e8b62a14accbacb6b8755a334c2808925b592126e449c2af59b28fd10196462df65f4f5a0afb1acddb82f7624ef0bf9527cc24eba3b8783b8a14a45e62dc833cc098eb4671188cf33a1f172a5bb8cf7f14c54b42fb0830099fe5d8adc6f9456b5f29401e387a73b57f99a1c8815febb23a029850c7adbee104727cb585ac4032a76facc496802826627c0574fa0bef49e3bf32301e76e25e4763375174c6c9f53943d41d80c6f55379b8f8505295c548358e917ca8cfc8d60278dc92db4ecaa60f75bb71d787ed9e243bfbafb3ea2b83c469b81ce08983956698df7d86fe66c80cd3b38dc500294e009b95358e340a09bbb35f4e991eb66619e8393af4ecd148e3fba9a9a2258d846cd474bdcfd38556501caa5362f0b9a8f6f4610340f1883b50933c50e50fb4f730c07da51beb1e1199949afac5eee16ddde84778c55b1ac36c0eda316928ad935b698ba11462641102aee73ae9590db502048f770535193b6955b791ee03469af2868bdd05c77b089ab90fe5402ad33dfd655a551d08cca6ed7aec61f7e3c58ff4db540625546c7d22565ca72e3f86b5bc4d741982f624690c628a7893ec6925f27f3a5f97ecdd74fb97057a8846eaf8a34e3428e6f03837878db940fd97db081d47cde3f9e36f57c1b2ee209e17bb1733d90bdcc79f6b49d0eb2b18b1eda1fc6cdc6d489c992227a1d07dc806ec062e40b8d32e431a1d90a1b1b9c8a35fe4965de918232868a1f63440ef90f54935221f695d03675534800e9edd03d2b72ac1f653f8407ac9ffa6d6c40468a1699e6370c316ce77a4b2b5352d02158cfd29d900c9e24730fd6f4beb7eec1168db9562975b968aa7c5f9faf8e0072ef8971ae673b61eea2a30a2654889b2f2821cbd9828acafdfd442adcf7d045b96e0d69eb1388cdbfe216897fdc73a599484f22246b495635367ec949c8ff6069afaaaa940ae59d70ce56fcf521adfe279df8f619ed454daa2aa953bbf888870db0f0f9f00f82e52dddf7c88f60d1a1dc7c351504f4f4bbc8d1b0fa49353df04749a73c1ff3e687a39215fa6949ff9de277594cf7abf5ac24503c685e9f2d08212b5abb3348624c3bd04b9935a75a3907b3509c2b0932129587469e4cbfc56142a3e9fe2cfe854d48aeeb8693bec1846f5e619c682c02fc414970d88f8999801de43a0a9f0e8e913380ed2613c7c495257b2aab7e9008005ba7e981f829ee7a8f904765f0761796f8ec8b9c9f05fd3963fa9baeba2e1c3b9a1eac4304180123fb495b965bd20005d7828f0749dbaf19e08a498bfe0d47d7fbba6081a8a6ad82c0816885acabd88bd662500e807e35407f53a025e5a24120543ef5f50015abc279fa4f1ef66f4258b47ebf79bf79212f7d4b466a77fde767d442c3fd8e6b7b8c5525880a2138d41b82dded23c6eca76d5518553032caae043308d507b0efe10b4c5f2aa5bbde27372f42626b01f32da6cce739cb439c44c6d369a0b08e4900c04c038bc9c65f8dea12f5116f0606ff5357271f336ad043e0b12dd20c443aab0ea24a94201696e7c92fe70468e0ff97772bf597cc28cba1913ef2f749d69924e3d1796fe5a91cfb41f8950e981f7f483ec77129334b43aa08f6a448d9bbaf28f6457da2003cc4da4756b203000dde234097716060e07136c312dd87998168673b4718450235ca950bac0e6a325e863b8e7fd10c276f1e90ef4b3a8e720306ac4bdf8726343b9ef13d525ef793cf2ded29e1052de22fbe824da1b83e34f0454385cb602a46db62887b20c195a9c6dd7e8b408eeacb6160028d46d9877d194ca1f21040f180cfe006b96f27b491a57b17e3c51a222774529d76e9188d70747bd124bbec92a04720a377e80192cca2846a127300421298a6f87b1e134c330e7fbee7f18f64820a0969cab8ee34e09d3cf1d6ae444c471707371fb90c273fe3200e3fccf071f7d9c5f5b21ad3624e3e1a377da7038236976494aa547fd52fd47e22a2ecf656d4044e498cbdf157b86e896ea57fb5eca461f3cd1c0059064620a3d4c3019209f2e01891f184fb3bb85b064aaacb8c69f16d34fcb0a333cabf4c551c3e9e4e37b32db9fc9ec6d337ab12dc6ae57ce09a8096511a150efc48e249b0d9675fb5c97da6cf88c863a08b2646169a59a1393979772b3c533e536b4064b12409579c50d05388b62c8c90b90592e3b0e3d42cf18cd88e7f47dfb437aab4ab5054f0db199979b737aae423a57cce957e21a9c44fd7caeafb5d2a298f58f935546c8396c62ee57b895cc10ed6f6d602924e3cd4939eb97df294f179ffb8bfa8ace5c9977e138211dc199f4608c9bb12f58e19609fd55190b3d5922cb88479f7b5704add05d050cd80593f2fc2cf44d67b0ddc6a5ae01a78df8f3dc1e6f2da387c18f894eca62e2fdd6f18e0b41067092567ade8a5b2a85407980ee18bc41cc5a82d792ea3c1642a6e4f23c9c9c43eee1c73799b8765d8316873975ecf2d630fce927972161834be1cc318e0e3a7059dd2b07706d898ff6fe7507c405b23d036eb2ac06fd916348266af116ae8c374f120b42bb5e5003554159547719ceac55951dc295bd49a16a5f22131b1d00a85268125133a56bd33aecdbd4f2feb0c8e795848bf6b000aa6af7567e3a846799c1ea8d4a6a43aa93bec6ae76d30890ad26032bcca827f3aa9680b2c7de771a18a7f1214718fed66c08189a3203c5b584e12f28f5de8f7fd1127a7a6ae467f28219d925e2adb6486d8e2b7496d8fd11b2b5a4cf27df651f66b23a6fc04cc0403530cec0309847ac0c2dddcb0833a2c6bd75f9c54534dc7273a2afe051f03344a115de02b3d9f0e677245c337a0bee5cf472ec94e5c5bf828be1964aa3a4cada27b8413543d8d25617271bb0f03cc168963a3deadb89d1d591966f334ef83356d3499173c844fe390d53af5a7a32d6ac10450c87e31f4677bd455262ee5ba8aac50be73b1ceba7f57efa7d54e9a96051c7dfacbc09bdbca6b89c585c434076ce8da12baeed8fa219db4fa4bf5e2ba8d9af85eebfff69b37e3d725c1f0d8f485f6c439f741007a0a0853e40e214d0ee8771fec170f3fc327c1e0c613e75d5902cd6f21c20db678058e6ba58fef907d313a57c927a7c30e070db7b26d90123c7f2addf890467529798d490681d5dcc38d397f09b833fd5c212de842b0cc2e8a02abcdea153f18ad26e78384c35689a9e6025ec462b3485d22733e8293f0136fa018037ba9d80057957e14ceb3beebe33fdc5fa40122cb05de5d8c1b6eaba3a253b977aa1f538e8093b07e3ad36540ab91b6183eaea2250e432e5da38f28c609d7dafc58093112ed03dd3fb9397f5c3baf6e6a98b88ec573b87cb0ce9649eaaea20fa5a6e6bff44319b06c91ef26474a271a864f82a752a6398df1242264a8304221ef3394560ae916d62fc2c76969e4aaa8c8f51cfccfd846b01e38231af369e75962fbc94780b54c5272c79c029ec3f3abadee31208bea7ef196f75769d976dbb93518097d529b92e8f2a9d91dc2e87ed418f9cd0c6ffae72ac800bef4f4e5672cd8bf379f8725c91a7063ebeacdb1b85f9acafeb11a5506c99a8ba3b9c4e60e6c04bebf6051538f849c4ee973b5d0742953b277c7dfb7647ec909d4508ad0649285b6c31ab5fd26692eb9b00abbd236fc5ab8e8fdc7c18ab722446b33d8143c7079f28a4b923d19dfb05c229f05b24f9cf60794e6cc06291c72259fc5cd071e6bac8eefb596bd3b8ebb29d08846783251f1ad65001f15b206e24e5577252ecb1a1004ab2c5f2d7e75e98644598dee5f298f90ea1db73bcfa00eadd498bc3bff92913261958478e29f11fc4a5b2a0d9b6ffc23f0be9b289833cdee5f28261d5e2a03981b14085a6481274b6d0d7e2bd6d4877a91b169f50e631beb52cd1c7fc5d4661b161dc0142c0644cca7e615569ac96c8be359154cb5c677624b34a23d0ed43fed55d2095b0a2e754636914e964877151a6d3515c18755027151ccd3bdcb9513c817919b297ce50e38b72c8fdd20be5034b9718a27d3977f1aa676f28eea629a81a1bcdd79dfdbf7839662ffdb84c011e082c0e2fd64f12d8a36756224f89207c5713dbd0636c3658f2e82c16ed2a7a229d41d6d4ea6d4f5d9246d0c04dfaba06d6f39886f5aebeee9865751eaed30f6d0df472da942de45ca227993766622233f978c4e8cfeb4aa07c530876b4b39a43fcaadba5cc778794558aa6a11924245f060a40eb68e7e5b5c154ff62f9f6f937de6d24e8157a10b20df1ae6713ff86ddc5d68f1df05f7d7901e88560bf1731b540a5cf983c08adc79728f4f310446b130f8b7b13ba5b6bcec43c15d4d16eb82460bb28e088f74f645031cb673c5665b8899aa953c372e23e21592e20f9a4bd952aaae87c462ff0788dd37f9df23c0584f17b9f207a40c48da45f5cb5ef6faed83a62e3ed4a6f46efc5169c043147f5e4575e2dcdf628bf4f96965a90d43aef426d9513481487420ec471addc722b06d141dca72fbd825abe4aa17735914566e56e640f44cd118907a7993ee2e1f550af14d5448667d7807acabdecad991b09789854a58ee07868634473b9207608edf2822be7f5010fd58aa60d58c8ff1e222cc5ad728278a248ec16363704f553ce3d7e00911128dc1c2218c6f471ebd9b580673a6aa00d6ee5fb0dd44afd898143c0291450dfc425382c69ce992e5559f167d7989ddbe1b6af17a7fee9bf1516bcf71ebfdd4ece00d59e6dea5b67bcadae3b376ee315a85cb85af27d284391939c50a781fd7c60cf4940dd295dfa9f6908772509e83669e8468d660a7e19b0057f713b15234b570d1e4c93a11f70db9c74741fcc9522fe54b175d9b09cbb56545b7184a8c5be553d29a969bb502315eb55a6ba5c1284f315f72981a97b02fd4eac36c0b8a2d09e7a199e781dfb5e4cfb40a697cf983d3509ec86de3b561c7bfd8e1b9059a11d08b80cdb46fda1b17e745bf1f55baacfc6caa208ad6fe348387c89f41e5cac8aa0410bf82830da5b2d3b837091ada8b6d9a91cac3500a69a877810fe7e302dc4f8d8d804f060958eca92806cc60faac6e1a63fd8caf84f54c33ee2215a0edc802962715c81be416c67cb245bbc79865ab56d9102192e70def1733fd25bdeeb29cf32a15fbf34aca10b17eeb66947f2b693ece37faf843ff2717cf83d5769952a2fccc62713d576a6ac54adf17be8abac123b798ec189ba3793930e298707c6609ebe0aca2e22f63233a9e47e9fe52d242da3ce95961d488cf6774cb8c2978899253921a4d9a3a8b0faa2946a538229837a70fa9e6c6a5e1de5b8bb8cbf7b1df3e1b70afe61177372e350038e5857aab3f37da8db26f7b867730c56e6f944d863436109e1f7a1bd8a4c85abff2847a8cc525e22fef05e9633094c9f5f6f23c6d34edf13f70c0e1e7c75382ab60908cce74abc47ab405cf8e6b1873d2e733c5ec2f86810c245cd4721ce1f1537344a412d157480eea96c9e7ce9c44a33a200e0239071cab42e3fe1b6b633e7ecee57b8b32dfbf677956589bdb2dfa4f1c51647da755738e6088c9f365b6ac05685c6722b7fd15eaa0f79ad99d2a14dd55a839c4deb5cfb2572b79e221514897fc2540296edd1b12c918f54defb31bb02888ff29d735abfa05a49edb379b9ab7610a553e87505d7798059ef28daf1373994c93cb2e3728be11206044d4ddaaec44d3cd03e7061361f58825cadc43a0eab55ec27406152b3e08d63503ecff83a68422cbd21949f2fd78375a549ddc751d63f5b067c1153ff8c2aca1726c73fa681327096f4b3ff5087aae3516d318b478ed62f865721c9eeb646f56ff8efb79e38830067ee1786c1cd53566a2cad31ec46be98d32475812df2d87037d9891ecfd77f07ffb03ee81b93863e0547ed3f96782afc8823ac0643307e1db0f94c03c29e7a61523b6e6e353ea5fdb15329b588750374b01b79bfeeac75832dbff2ac8dd9c916c89a7aee09f3f92291e5e732774780a92b304fcc9b8b24a7ba5888415eaafaa5555bfd38f602f12cd3270e25fdc12ed784ec89e987b3f347f4e9b3d5b0125a528861623c841dd35be9f2abddce1bf644c6fcfa8663a47f89bf64d62f029b3b4f315511059e8edd551e1c3f1d2b2a3013927381489bd829a9d735848d2f3fbba4880639dd3d66001fe9d05a79262cb822e603229f1f508c58eaaa8bbb0663d54d130a833fd57085b0d2f801faa911ef891f22b89fb7c398f519857da22a1a11e0fbcc1f5ec416dad79068877df03fda330c04e2d950ef9c397f6722ecc86dffac1e984b5040d118bf32a0d5956394ed1f9b82a58ce5ff2a0ab904d68e055adb33f92330268819fc0b078083272bd4194a415b2a11f9a3a730fe2324cde5b451bf1e46cfdafff7690cd43fe86d992c3bc0fd2608f146971f907e4a7612d2ea01c0881b6387c691573e874a9eb187c36ba7404b454c1e7ba2df54e709a1c4ec32369fbfa6c6ef5d9a531cf9906e8d286f0fcf336ba39e5719ba137473435df2f6d4c35a424c00f8ad8f82ee1c28d009110c4da8dcb76bf97816df0addf1352b97fd8fd355eb73dbbdd851d5bef09f5a065a799da4e109adac736896d5eaec510699db00b2fbdfba8bf74507496d5170ce2c84b581c61abb02484d30a6455341d6040c3f17d818baedde54ba394aaa27736daa98b1f943da17e9d58b317ce39149214eef2ad1a00f1080984eb2d3061ba4f4e5b3b12f6e19cd2ea645ea0f150964ed4d44f7bdb5b8aa86dde76ef21dd9e20e52a6f8a274a00969a69c6e4b203e25ef6e007e0fcb0900cfbeed25693b871461eedf3f4dfdc68f4506e49179f7466e6c0fbf0a61db58d489cb8e65b469da6349c1e796068c317343108b1001853676522f7cad02cd8e5db34aeca307083e8098df0b4a4444dfe308bd049583d07577ad414dbf30ec22ee4cc9ebb8dec9b9a3cf5668c10bba93e468be9421023f07cef07e200a5f49573a9cf6e6d335850b04adbf72bf16c99d3751885ed3bdd750d496765b66c405a73c9e2a4d9d84b7129197491b71193d13a8222e70cd695a3dce097b3104fac28881a9f47ed4291571645a701a0b2890f461565bff1ccd37def61ed01931c7b6abfa98a7e7ee5c5e24237f4b78f6fd004ba5b7d0092c9dea9d852926e2a4c911c89fc11497873d481cce745fbd047f4dad6014559c17f6b41274fa3428b3ef1287f16b3034d3243252fea764af044e5932f7c9514e7fc007d302526321cee61eca5998c46f426959584aedeaa4624d00923456fdbef11a88fcd4128a0894241997b1f090404b40e6aa5232f0cab4be697bdd9e5997c5c05e0bbe5140a7fa9c15f2b81c8d71809fcb09f02e008e9665f6a7e57d670ca110163e3404c55e4e0f4b211efb5095e811b9fde8533e633920faea0a755b0ae02b04d922bd043c974ac277f143fa719e9bf4ead42c52a50d08759f588b6d0abde42ba64ac072946da4660fb3ca6e394837fb3887fa548ac8fe42546c9f4f6b616892a7b9840190734a2cb1a76bf9f2d4b0631d16af0e688dd6225679dcaa6785c8425fce6b7afb465c6d86cbfa14cdcab6297b88419f4ef3babf981ad1a7301ff3111996e267d252e44e03ffee0315ebd2e1ec2db2f97a5cf4933c7541c9a2d5ef423faeb9299f0f6130a3bc17bf79626871c317a222ddd7ec0d545399a34389bb07ca7e025021ccd1b0e15fb13a94bd54ac231cab0341f0ac39c38f044345b8935cb25c4fe56e8c4bbd5d855e3c2ec1f78e0fd1815c802dbdc87d97f8972583f56c996f7c278b610b5735307173585c68abd7614f44738cdf4f941c4c3bcb7d23629251fba28a413e438b06970492ee9735887678e25813722e2fcd6dda7270d08448b3806cd7a15c3a0518b1f205177c5a092d540228477e1081e7c3370e72ed04cfe38f8ae05493a79de3d817603d9854054ab73ae6abb87d6a292fa097fa3db9bc33efe581b3e0eef0aa0c560ff0fa3bbdf87d8487bba26ae8bbfa68d20c838f59cd0537fc6acf76a666e62380813e6f56a8d74851e8299225a18b61c01954cd946c75561f3687d99f455f6ca864f4fd389f2521a8cb90921b4994c93f9d94f19790dcfc159a5ae1586dfbafa1c4196243361909f4416d818dd386b2175c70dbf13358ac5743a79af1f130fe790759211b4031506ee33dd30fad3ac5d10190c960b909168ae6c07e8a0e58cb10e2ac896460bc19b43743583e25491a0dbbd44249cafa138ca07a1870a589377d1421b21d20547c2ac356a2d1726b07201ba9c24449b71799bc53edef8bd4550b42afeae84f8d2bd837b499956016d66b9fd8689e754803068b61f6cd5382b8cf8a10dc4e5424f298fe51a1a183e24c64fd2180929f94e948a0c2d439f3442543d94febdfe278a076bd67427d4b91899aa76c733db1b608eead17812b6a5c42229d60345de2f2e286d1dc5ef7d687a6f22ff319c9571fbc9ad1925150130682d761703e12bb2a19c22c46715b8299adccb26f730f42d59d30fa12c37975da1fbdb822474e9bbe0ac4b6ac02bd62e3d89339379e0265a8535951e319f5bfa47bebe0e857e11560b2ddd285a36075101c38d262b163238f30cdb07ccdd611d75a7fdd8a6539adb106d2575afa2dea64e07e26360e4f3a93401a99dd3617951e171a95e22503a9ed3005526cc737586157bf96f4f25832c95211aff0be63b51b9e125c75530770fd6caac7b8dcd808371ea6763d65f275edbb858dbd40f2510ae7bacea6d520081577b287ba43d7d93eab796916323f5f4f72afdd55eea5df37630906d6ad1f54016a980b718e6d57dd80fd905eccf7a0f904d8c2b58a2b515ca918301ea2391fbb80c6d1f0b6210d2896117d235de2efd32b59d3dbb4636805fe94f4f298b25a5ea95648fa4ce0e8e7ed540632e80ce3ad29fcd2af00e537f50286ca1f2fd2bd6f5a2b2d383bbe8408772aec54ee48540d2a596dd350275a276ef293753342677d357d52d5791e021430dffe3e1a268d1ae4d57dd8b25721230dfa4f94578ee9b9df054809e602db933c3a2a20871d560ca417a127e32e3cb0d5a236ccc19100d76ea383b947fd3abb9c57594805f05886749c5a78816cd0015ce28054095ebed58e117fc235da69b60261e7967b5383b7f8ef15bc19a752c2a1d4c584f5992b86473da939331bce5da00659550970cbecc8e5f0958762a0dcd485ad21f7cd9ba42ae08b1f4721924cab81d822b051ee64b166f101f548e57aee8744c092769043e1437228c802bdf44c0e955a544d7eeea9081aece47e302bd5795aee676a9203d3d3d420c72d62772f5a6f7d81f420bd713794a48254101ff361b13a99e1f20b143cce48cac68b41328166ff2fe717c3591c45db7fe59a264fccff1066d2baeceb28e9006f5a4960a95d204c3e6d0175dcc80633a6a28deeeef69639eff3be3c746aaf9097850231f4ca74b8001ac273950ffb2cae5bab308e0da7b219bedd57bd96186d457735fc0065bb723a27d328b1e90b47ee1f1050ba088d215238502f76ac804d982cb1a643fdb41ad4f43dfe272c3564cb9b8050ea25c919533f1c9b5f222a8795f6212753189ee02e60e7f885b2d831f57b7a4d21be4972dda2f54add4718a45f841709cdf1d71fff5ef904de8c405e18697a7f0fd0aa9a57e9511cc5819f34ad36674610908a8e07651e967f440df10b7823df1701be09cfe76f1e1e0272d26371f9b1d8b647e6d7e15ebc970004ec10d07cd4cae11ac5fa7bcfaa340240f9a36330a3a2eaa0baa08b3acb9fc612cd8dea44edaa1cbc7fa98dcf2e55f5ab8343091b77d7790ff424460d16ffeff3e9a01bf6a02556fbd502446da688e92bae457d40cc02bdd2be6b28c1f0a7f3155e67ccfb2e611950faaecb86838e2126affbe2a56b0ea837e8b132323ce82f865919026f795ead92a573a97f31523429111bcf2add57a5efa719c9b78c9ce4423536bbb9ba8e1c09d55be7d8e1634fa5b524d6ba5f1f6eec6e0b06a821b46ac613bbf047e5c145e333f174b30ba8d1faa9cbac2abb15bea27f626d39f5d785d0e240f4ada2db5336f9ee8a369d44309171010339df8452871709110cd5068fef5dc7b773fc2eff1786df8619294cfee83e4e882c9ceed40030f643a282aa3a407cca8e4e6780da49a83dc127c57bfb6e611765f11ba1954d25450ebe21f4b2b9ccfc3cba907fb050e30e341703de9468e0f75685e61a63a04da96891ecc8efd39b832a95d5ad09a26f3eaa73f7309f8fca59e059640bf299fa4ce140e3e5e102fe99a91ad61cb9a5c27d970dfd6aa49d907d1411125fae58f9da01468b6c2378dfc56f6cf509f0989ba9e23c78466885281b6df3dec4afc4eb78fea42843e43f23b65f2a953e47335de19d3e204e203db80e89eec3396d041c56f62eb83ba3b7d6b618a3162a5afa81ffd59508f9ce54c83ae30396224f5f8596e86ed4fb473cef8f3124881d6d04396427e6248936e1f99522a81ad8bdfbaba3671e336da4d2065e3c15e45635a95a1d8c4047c6e1bdf9d652595aa8ae796b3f3e545614ed66ce8332e1f9d1275ab406df0823f07d107cc9ddcd107fab51d604e82853ac2995d238ebd80afa041a17a58d46bfedb85afa91cf29875485312530eb8f3e9ffa7e029ee61941f8e77c6917edb66bfaaaac7f00a50a2df95adcda5b4137d6f8469519a64cfc40d2ef8991ac5afc07bbd8572856064abee2d0ce6f4844002a5d612e65a8aff4058dd98d7edda2dd2b5ef8405ad505e1ac7e8cade43123a4ec4faff55d3b0d4af295e8b20fc75198388960aa37b4948f2187a9324b39bcfd5ee794a7cc754c2ad657bf1eff282a1780093a33c3fb11893a6c38db27735ebe5ba5eb29cf90f153a8d5078f1206d2f7e178d4cfbc961940238119f3afdd16dd6c5176160cc53fbdc8dd561841a6ce27719c6d24b6c3580ee37ef43e5c8ba2afefcd5375cf4d6c14042d84ae8edc3a7742ae792d44ca068d83d27653683157227779d4d959e8f66fa02d1d04fcaf2bf72b4b5d67e887b4415909b0d3d627d6aef8ea2c59251742a079979213daab9cd23852f5dcdedf9e8a236b0801b6cb641edea7acf8ff6f3b4509877a777bb593055c1d724c2924eeb5286a53e563b116f1ce6df2e9cb08894473189d8c1aa19f374b61f82b047f44cc4a7696afe2a6f480aabced5804a9093da5abdd5b81863b61a275676000dde8fc4353aceb25fafa3b1213d373e0529c567ab9e42e0275ff27c9982c8196ca15672f1ef1f32740b4d33a6a2798ca7fb58df3496a560a4341fb4cdebda03969db8671dad011ce003e270b9d3ef38a9b1f40963ee56b1d4d61ef249244998671f039c9545c9bc45d9de4317e46bce2269d4bd8b721e0decd096759e779aa30ae18b3391e39099f07b96e767fe500ddbf85bba8c7628780347d3e067454f7b389421f501017770529b8263cad9daa998e0eed991589e8d531ddba5682254af670334b0534fb4f9c50d37bc3e06e919f9ad383c2289a31d9c765cc554d91c412d9cb4748ffb0a513b7377b73dbcf8b179e678807ee029f39e415297432889563af90e1f9f5d6232b6f11dbe430a93182fc918b43f635aa1bcf7458bd20ef08fab38f79a17d8550bc0d626609bdfcf024f8b16ffcdcda5c58c4422a4caea1515e83a1bfd249f20bd661fc52f222c33dfdfab87d93ece1964ed198965290de86e5129e23b78981d95037ac683e889e3fd8da638e4dee8bb73b4de47c73b00272a256348bf6484f473ac2ca5bea7183144433861313dd0863e5e4da0a255538cd81b0107312ede99c61a1fa77cbb8d7ee5266e7e6ac3b8f72a850eb2c47caee7389b37692066180bd34cea907a1707e7a44a35be01c3b30242a78feb13646680ae6daf93fed2ea2e19cd7709588b8966897345e0bc1234759bdac35f294756829059e1f7a759b1e916098ffe8cfe061b3b63401e37729e41e1d7b53601cb911cafd64e5daa519fa907b75a4ccaaf86a2accd2683c828e1beee4c781024e059b46f8d134a536f30046ffcd2c468ddc52686e8ae0fd977ef47744b5579626e774061774cf632c7b21d6f5f58abc4547a974fb4f545aaeb22bd3eb477d8ed5f2229cf9711f87ad23354639ae9aa8867f0cae2e270c5fa0ad40e932938ec860d7ed9e4e5bbe9728559ee18479e1dd8708df5ee206eb221d1b0aff85d7a8ab982ad15a634b9b9a93e70384183900b23f04be11af22bd60d341d649525d71b07f82ef4f72822d99ecc74d0bf565","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
