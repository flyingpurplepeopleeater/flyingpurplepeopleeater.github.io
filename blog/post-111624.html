<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../css/style.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="..">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            window.location.href = "../";
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36685c10345d093aeff007618ad79f82f7868a0eebb521777666bc6efd776f4973e9dffd2606d4ad2540c3753327eb7132bafb080ecb9d5900ea41c4a70094044f6b966a2abebc1f5beacd515f43144e6e144b86455a6e1f047cbeace89b22f8ba51798f2372f9fbe71c9f292dc471884ff527f73ab27a427e0e47c6b229cc52a0adb78111eab7d1759e6424374a6d672b4c3f8a4e306172278de8a0180a7ba9e5485ed18e834caf89dd4e588c062087e16a8d8ed9b29593b8fee31f215f8fa4519614b30b7bfc74b7d2deadb09d82b0620c3beedaae7bcdc6402d094da0874bce6d662a1fe9fc32f516c4764250c75c1eb18f3dff4e28812e64a38372060af79bfcc93c29d668f29034c81ec9157881d4e4373b595dd82a810b66460f0372cdcc44bddf126f3a27bac9edf1d64855415cc8448a8a9fa649105fab533148d8870ede73916e49ea515a1e5c844452dacd213b92ee96516c024a5e2396a372ae035c89de8c72776ac34bde7aff54e50431ec242e6ae537a58214d6933da33052768dc5063d1454caac26792c18bdbad63d6910b580aef7e11efd8c854b8cfcda8a407f561d8ed4228699101c16b67d9a6506b25321c75b7053fa68bb356e7a1b7a0959d14e12db450477e5568411cf780e5a3a942acb79da204b9e77b0ee0e39e0345d6f8a5bd4a0f18683fee53c2aa595467e6722b821cd7a17bd46fb2cbac0d64d3eaf016560475500d94054cfbab5864aa2168ca4b3826c25291a448e48a48e7a5ae70201a8cc62d86a33caa7b3da3968f46e47bf5156e6762d5b138ea5dac291ca97a7ba6afa9d5c25c3e8c4f3d0bbd803ebd1e87251f758abeec07bc0a2c410e19f42b4956f48bba6e19a02f058e46a84f388a3d5c035c5b28eae02997f5620ae86471f7ec48a8183fb4902b0a3c69831187e4435b84bca441b9421151e8e1a7ca05d9f85e32281605f753dd7926c88f7c8557d9932c5bafbdd18d755d02faea29270f35cd3b76af225792376fad9fa508d7353126687cded96802157388b755b644e8e685b159dd780f92c005f63a85eba9eb465705ebe4e2d1aba2028b26307315e49c2384de11ccf1f78b41336115769fed462d6329e185f388fe0340f5ef966bf17d85e68a8128d5b16ba48d13d8043a9c17ac6aca17a4009f6549b54663e3b9bea1a6970d6de0d076112ba1dad84459f5e4221ad0ef98f6ac211bd4b409b8e18d3bdc048af749c7cb1bb13a6a7d2f090fd2b6ab45b1fe0755655732dc6dea7ca67c31cdb38387dcde16f79a8644b087df3b48b5c0a98d2e0657d84db06f71c36e91d4c60e96f586a1d16ac3ca6b7504bfbaa1cbe01c65ec6e9fffbd92721320700c6caef413e771035f351c65a637c701771bbbf037e6ce2930af027088cda089cc6477f97288010bbc0e528c7697baf8cac21eb1f9ec3e0d32160a9975eea546c27d961f90e52ce181662a08373043bf89b93e239d2f2ef0130f1f46b21dc1b81c0049b8f2d51099402f942f078542d6ae65931a0e77abf10e48a76bf068a0400cfa7fa76864dff08055dc795e80311020a91811e1db22ac3db8ffd49660c8d796c0579faccfb2bb1f530d029b75f16f6df2a7c695481ee4fccccffc93c763e0d1bb3d424808cdef13d81a5ef39cd68be0b591c5fc192da6e3ce18a38a19d5cebe0c29bc3cfc49284df0fbf8975d09fac093b1e16416e26c00f422f1450c74510f9fefc193e980191c295726bc83456fbdf15fbc1a5d9f2234b821e94973d863c9fac1097fdd6d9be397cb41740725e10e3191d46191f586e556e6441a980ffb943bc8876bdd5de163d13d392b8fae2b1751f0033210649b8935233d8ef84b4b6e918b9f316421b0d3c875742c04d4c17e40edf51e1f1f93a5cd2e549574ecfeee5a028edbc949e299148da7b04f0c436049ad8f3852bcb60bc1222b3285ed6656f768e33f7cfc6fad1bee220f247a7526578f84a66d6504018b304c7b1034645f4b796f4571566183229f8b1aaf68677f0309a745817d9512ac6b84b38c2de840c268e642b687245bdd975a779de09f112501448ed6773f0fedeeefe4ece5a84af3fc163e91479570a6d8ee99b8c8806208569d259f9c36da6f822d634a69c2af575848953165a95cd2f03e945c9319a0810ef46fd7f4d6af70ba3dec995e52825b7d5a33c14392fd4721746adc0807b72a0d9fe4cd9dd8bdfdcc340e8f594f5c8c1d3975d20b32f380e72dcf3d94cede1843e5594a264c345bc707da566c0e9f26fa8e1edc82ed296c4ea4a64246ae2d74e89bfbcf4d200ac27727ed843b4529461146da48ef0f8fd6037efb0cc23ea3b66a34f361d9542f820442624ea3d6c0b82dd60b4256cd785929b549287de6e218a3c6fd8ee45dfdee5a09191702d795fe033a660a110ce635e7772826278d6fb09c379e864f62d09b56529cf395574f1013b90f5ef4411b61c2c9a1033be16921b7f1137c46542aaa0d9d5731346691504a166d7d987b377c1bdd5fb6a2e345d1ba8d77c85d402f30bcc807406918a14f598d34bcbe44619145a5fe812bd095ae04e2cabec02bd296f785dfdce16cb57d6c285ff23733d9bc09e1c27a60290edf440fc9db4d40b853dc684582edd285518f93bb6d266441d6e9932dbdbbef81c6e8ed2b6ce45b8935b3300afc78f3d318ba4406bcbb27d6b70a3ff6310f48d85f2a34a9c1e9985b6287504b2f020fb171f3a82ac6664dd7b87fe7d7463dd1cb194770a130bca9c4989a86eca8ac7f1e02c4ace2352f9090c7681f2e355b4f3a19beda83c83e322cd733c6488342d77a82798da205e099fdbee290573b97d7ac6a6f3a2757e1e9b6e5aa88bca58e8b00cc7c5e12e0721363f64e038c38bcbde5b135418a5b16f12be81041ce6b403403304272473abbe7afb60a91f32d2f296d9fbac9f17be21ce282e6f552588406a2ff24ec51172c853342e4c4d6cf72f71538cda239503473610f1809d84b2b4d3f9a462e8511f70b028045ce9dbd02f399bf7f683b261545669fa6114b339b18dab3b6b0e092f8807b1d4a2fd4dcfc4bbc064c94ba5a85a693b23af710d5f3e43391ff77de26afc443b351f08c26300a2ddf9760c50377b664a58657c8c618e1ff72608cf339bfccb3d43c4c9a6072654af16304ad66ee427f596b74994cfcafddac051c3faac1e1c4607865ab759a71617e8167857278b5960451c9a9515cc8b908f848028574f12ce82ec8ef31249701d3631fd045d6746c8df82721fbf0bff78b260a28dcf8dedacddb9373ba0ddde74e85a3e5c5da8e1bc9bd2948b23256b177f600a3ba50dc2c3cc15f12c1695b12fcfd91333717c8015bd4d983519662d48690e9d8dfc3d180892a879d928317511a0a5c5fc7632860a05096bed9fbfadbcf33f198312807577ce18ab9ad0a4577eda2cd5503df7effd8911ab20015f32461d9e5ae2b9dd478a4cbbdd74d8c6a6807006936d5dccfd8d64153a7ac460247f816a7ed082db21d2e215a95881d0622e5e46930cb3e5ca95c0a62184fdc43800a1cf1bb55bb4209506b9e1105ac6cbc6e6a5b06885b0acbe13f4b3f1b9cfd054d64c20e898d652b071498a332e0efdca564b5bf57a7484b0f53fd40120bb7138b78a36edafa42ed96e8549d334e87ab0b82e91deb38d093aa42f8b047fa9b6b1299fc3e549f4ef8a56722e6b9f3a6da0b18963cafb247c27ac8d2d07ff64ca88e1c59ab39d58f4da59c6f8fadbe1dcece5ebd44baff2d4fe1ca93cba42781d1fce9bcb4f496fd301d7804df66612ab347b0fe5d4721c36bf31ce39051dd0ee85239c922b4eb4288ec337bdb2683fe7f552362042ec0f037ba14ce09c6bc85f285d9c68146c14dd72231f4004277ee59cfcd6967614c0c8aac9e5344aa3d451d9aea5f5405e827a604019a46d7cb7a94ff00cee2c1277209a6cca04965f211cfac1e85afd204e800207135552fd813ac0689db9684fe12a4697609990d2761e2a64029889f1a28e7a52aba127333ebc261db5e7a567d551a1ba5649a1d764ce022d01473809f3ad5fdf08ad0dbea9fbdbbe5359ac8d6953625af625e3d5767f1b1034598e063294cefaec89ebf5051fd3e3ca262744ed8cd78d207fa3d36838c12ca0dac4e91761e2006ab8d05447f48eff89cac912871930ed4c270a698b384b2025d3193b3a6f23306c5879faebe615a9e4793d6254a3b4baeeea08e75ecec2f5dc02a6f38c0321a52270176f86a1d26c4fa8d5d9b7217e486edce663c2d4e6e9894c616a506be37b19f4e343af30baca375ff0bab2523ddd765ed301b3dd214c905395500f8dd8af4b9f405bd27f1228cf6cdf447851bb654d2b011ae9d80e6a33811620f8f17de0a82d0c37eda8c20f467caba81178c98444a90e2e219c1c0fd9be207c8cde65a84ecb2dc9711f07fcfc4adb924c9238a4103599b73e636e9a69cace7f92ca967ea2874850e333c725e2ecdc77f3c38905a6308b633159cd9f22f628fcd75f4cfae8c96c81a2d54185e284b8acf41685552bbe0f5f6864b45323f77f9cb28163db268c14b88cbfd725a2428cf3c3d8eea3ae7d1d43cbc7fc97b68d0ac7aa53702a51959e16df9add7741776be5325c66f852e5e808b19a1646d94afaa1e9da72f6bf0c986977a0e1f5a1e1ac7e1225e2b1e76287f74c0af6528853e3f183b34aeb6650528f3df4b4f96dac9990e940153cbaaa616460740634dc340ab5724bc64d1a49e287cd0b45cdc9966fb37d02e7e961c19977ef0035fb5c2bad6f8a049b2c98985424eade185bc164e85dd94e40d9d309b75f435050529983e66870500ab84c5fbab0b6069f22c9934320d12ae736bf857daa373189b1af1f22db0a7b97fd1af6880bc02b6afa3f92102c026c3ce2868bab58d76690656bf17200156e12bab6c0e1e4954a9189c7a291c680b3e5d79c3481dd2c996ac8190e8f15a3b11ed22ac69359f39360085e92cc6a5e28a87e5252a8db79df312d7e395352ef5abd0574dffcfd1121310679f6e44ccd7a6377287de194823e4a7c457099620e4a5524a24926cc9bf8109bbde952dfc472b2166db899c8227585a8d370f19b0b8b56f5b38a4bf5ad944b81717723037ff430e323b0d69f40869c6811f00ac91aa2812807755ff72b98e4c045a88bd4e6fa6a1229585dd5d8aa7835e5a96be7a5616c0fe766a3a090925d0f554384102650cba201be2a4985ad6aae3e820002d169bc7e07fa3ed35dd194a2817abfb9e1af204787f7a062c8ca2de7283a26062836077144d12b5eeeeb68227c684ccc19a747614da4375f32d3a1e67f64ee456e099a61ec49309eabf9631c15547e44c6e39e60f96b8d4a36c0332b3b9e30304bc4ef2c7e00d20c4430ea5ce06186ea63db962a05ba6561487fdb54c51c330ee096503e42ed36cb4fdb75a3b9eecf9912b01dc119aff0fbd93945bab6b059f1052dd449000cdd5fdbb111c826c371f7af6c45b3d17a769c103d78a7df3c4a6d6084f351a26c544187a8aa37d07761798dbb1639344f3e093cfbeb19a98425bd174258a3bf868c6386920ad50c843ac692b179b8cd629ef137b09aa41bdc9a7e4e57d84d40699adc9db271014de39ce85936dffd522852727da1b683f1259f8ae2d4ca84cdd5110544f5048f08d9c8ce72cbb81fbdbd4fd33a5803d926efb7cdf183c15a9339559ba737271995122c6aa286f80e9eb332e9c03f38308a80899d8f15184d5057090a125ac529aabdd13e416dc4dad21fdaccb99709472dc730f310195b485b3546f4e7629d2640ac1a8a7a6db2e191416723f234eb3543bf6d605f87ede1c03bf93c55e698a1454b153db374a8d947a8612e3b462b6a8b94b7683aa37284c05e752ae8adbe125a1c99887e862aa186da20c76e45d1ac615163ae6987a26e8ce122b647e6c0c927aa173e9fc93cf887a74fd87c331e06176ade22ee913b51d1f114a96ba084d4d3ca192f636c5ca69fe227d04be00a8d77ac2b400f76ef3a90803afa503a6f7ea3e4bb4854b6a1a15d2bb099da7feac8a8b879c80b64bcf082cbfd7375ae31397589c963646994374f787dd747465ca4a0ae6035b079468848d53a88da210a761029690db1bf8bdfe8bb1f6f1915f6fe51176248462e157a01c920931bff951214dc0d7ffc924617829b77e55118a0a7f05e6c8d82eb6f68aa14155512742a38e0f35c08cc8e15c0bd3967563f06f0cba293c5d2523651d432d2168d253735f917e2b249343746fbef47f77820cc054fa3ec39c7bd659ff932456f9e42b76d6669e7d10b47745aa3924745eb8bd648b719a4e6da7b871478a269cc928ca8879dc018141cc0585c31b64635251c29e149a01f043a2be8708f9f6c49d1eede9b5c944e62c6493a6676f68071a85fca29f035ee12d7be18b435d83a9994b31e2a0a31c7a6cea4693eb44ebe8d649ca4e65daf5689b2eb0c5cd0b53ea1d70dc59c1bb420ed1f6b00b63b2bfe6c4fc792e3611f84301b4b5a80e115e4565b681e7733bbf8500aaf2f1eacfb78e5a03cf2bf67a912c14baf8ece3a3e87c356b9c6d33f55556a44dc721ae672331170fc495a552f38b098babd128fdbde936256066241548bf3bce9504aedfeef32068285378510d6bc89b29282c8b32ca53d8f7f8d5ee1a1d526812906a4c4fedee9ff6ecab740b8e06320efce55850d75c9af94b706c8a64c06f7031bb252f9f8ad4659f949d1799caced0067d799b77e7d3a4155c944259b60672d9ceff4465299d8df9d705aa62380775583951119d579379affa9cea89bd75f2cf9f31fcce865cd31587095d9032672b6819cdf8d4799b5bfbcd0967154e10dd12e1473a230ef22e8a8ae24cc79a39eaf9464e818e701e262056a04275e7e9d9883186db1af4a11685895bdaecc6b9ffb8835f0e85188a5dd8d20081b9119feee560e68293fcf4b5e5ca407a16b6e7e28780384c15dc6c520b754d41f3656763a9c95331a0fa9029859f2e84f40a2bf2cd00b2d32ed87db34d27ea237aa5c7ec6599837592cdeab628cdc47ab990d6ac31cfe10d8423e7bd2b07c5c2baca2fa94cc850dfd4257907766b21b17f6523bd98768dcc7c999a060b10acc0892e8127f9e85ef71c269d908d1ceb0105f882b3e10492fd64d84ee37abf0e823a9bd303f73614aec6c9abcc14bcd550112c820fa82913d4fa350eb14bf661c02cb2535338aa453a760eb18d0c816bde9b7fadc17ec710d34a2ee8800f225bffd0b0c4e4f15eba839be8a8258629b219bf552a33b1df27865d16baeac9386776609a424f91aea1e47b92c501be0c8adb324b830b6b5f84ea681c8fa97e0d6c89fb85e8e0c75bd844b9590ba0d00484d4108cfb42bef60b0f4828feb728ae0c4aed1c5c1f03bafb21b55ca60298d50d23215196d7d0d00c8f4a7c7666301d5b5553614154f34ce0e30ef955af6f6992b542939c1448302332ea75b6d66d93809c17538655f81f008af776b31c973ce5b0d7ebc55ebe1717af01d7a0841c2585c7d5c52a2a20e5c3461c067f469a82da21a46c5fdae5f24f0504677ec0dbc7d32a048a37276e7d23a59a1f6591a0a8dfc34dc968c5971acc18ff7a7d3e31bed6458d56ec8952192ea6eede3d574b618bcf00a0925034c2abb4d6950768e20a3732ed19542cbce4481dd152674af704d698d5e5987885ae4e61ae64d8c0b4942e0d7f8b1129756c41e9d2b6989b8346036d8f7b2ba815b5e2d608d4e88ea15dd70a549d9691c931f1b4706a0c31741957539d5130dfc6cb0cd9c38e6a54c0da9261be0defeb592d7b66777c9c565961e8ca67ba5a955d3820da61c59f158e84e0a8cdbf906aca6aabac34e47ac362d4190b5f8b976351e5c6b2e4fa6b1a124549396f60eb8fa76723d5ebd37ddf11f7ba7b9698fe38a2189d7ea7bcb7bd1297f2293f2375d4f4415a465079f08ab49114eaf58159e218a20b7381b0046c4534a5884c56948b261e0f8208c590f8673d60163d51c143725a48aa4c4f573bbd9f96f897b1b12a4f0f35a6de49bb77bb9e7a486e786bd3775efd84c4e3452e74246c8c23a4cba9bac4e65d1d0cf63a7713a2d24ff0860e7dd635f58755a92134974933367126a3081e455d7dfbd871c3e36b2d04316bd8f57331363faf1495c03ba5dfb55d926fa246359b0956586868a3a66cb2d4898773723f52fc14ca7f943e61b8b3c0f5a8a25ec5025837fbf15e6c12d4bd07d012dda6ba71f1ab99c7bc31091c80056278050e3902a0340bec13b1ad435466974903c0d7a4ed4498b13e8edefd19071d3d8a3cd2ec64266e229eb989eea394d9534635a148d59af32c2327046c3045528c0ebdd25287c870b455778b9e85ebb08d064f2719660e72e3e759a7915e77771ce52e21899e9da90688275d9ebd9f38694d6858e2fe9a352be47a62ae93bd8848880f5a4836d035207319c44519151725e14ed43109ca306f087c4bc637e9c66c574490ebc5d1e112d33cb294b2caf1f0208f0ff8a2bf85ef9e7ec0e51babe691234f103c5406afd045b50292a1750f503d3d905f5b8faa1be8fa65d044108be91e6f39a900e0ab2aff30aa7a726dde5b7b15633bf8c89307791f585ff153ff9189f78728a7875e2d289ebdcdafc6fdef1d1bf342d5e89e4fc69860c4edbb332d919309520bd8b1ee317da6a0b4d980e555e31aadc1d59cff2b4dc6c05a1bb23e34a6611b1438f28f606762d97617b813e3af2748e8a96f57e3261bc26e636d458e5d439976cb460fb1ac755e12b9de7632e3071c4e8a7231aa986ebffd41b2ba81509ea071b2a0d93046792b3ab012554076b6ddd9c237d336032e4d4462de865e3b4ed1cdb0fa664755a7ff3951bd4e4bdd7da7445ef8696ac72110e65353b11605c5065a53cebe38e925107efb760c45c1ec6ee530a7ed10c803c83e162790a87d82fec02dc78848ae942d17197e1d08dcceaa0e8251f8ca72eb3c2e1b50e99d5d63a57d920e8b3213c3fae4c6c69aabc64361323afd37ac8622c82fe9c482bef581f854209f1e1dff4863cfb515dbb2e2c1d3c9e9380391aa75fbe32417c5a398c038d0d9b95b8f1a24c21156fdb1d895edf539c4be6ae1db1942fd6561af8cd352133f5454cada17121f7efb87893f6728c5acc9ab6cec2b3d6c88408e46e2f1e8189b47df09bd79d1cec783589c484986658cd4f87976a432f8ab9ce9afeb3ba89a748329e977d4ade80d0a5b321a9112a45f1aadd03d8027698d43c84a0512cd77dca06b619bbde89e4325d80e5dd15c7ab9d313e62c0ed460652ec3359e871c9ee3f78bf94561f024bbb795ee7e9c3d2f1038b6a0667accc08dfe9197228bf29c44c43cdadf24cb00a563a51b3cf5e5f3de0802e1e189575b0293ef5d69038c65ecd0b33b6068391b966438d8dbfdd1104493d858c7f1e2bb16ecf29f99d019294028c23b747a108a148373a40dd67a93eb1f674baae110efa7f89cd8e491639c1deea99b4be4ac1f19a848b22f957a46bfdc6783268590384922bee59d2a0b9f285e00a953ca799433f52da717f142569e9e6e37544737873587691c2f6b27082d92c6498e96c759113f679aef3bc96b65d11c959e798edc4eb854c79d1be927218f99175c70cb0d2a208c3217c0b74b16d6b5ee73186ee87ad3650a40d406a07a6392f784bf1f0d017878556efb1e988f5a7dcf8b35e3d02d4d7843f63a11f9f593d0933d197e82efe7401239da53bd66c308fddff3ec4f5c655dbb9d346352afbe900fec12179c39bb0f79d37cdddcad0f105897fa0d5b38241890cfa98610d28655d5327986d0ba8648dfc7852c0354db637f05bc2d99d908db05270dbf3f517c30374b3b510735e2ee8d86eece07ea415947171317675b37a213014c65fbcd840d2e4eb71b5c614606a327d4997c16f0f905fed0d54933171db4ab3261fb1c97d3574b6a2ee349fb04a5cdacb273d1d0c8f65e1e5b17c7baffc29255612cc5d9fd684e23b0f4601ee51432cb9ea26bdcc859dd94949b4b16d4acb5ff892cddcb673d5a48218ded8342895b9c491608cfc1cc810c90b47f11817a2b4f98746f1e9efa4f004abd4d5cf9d3727feb6c10c0bcbcbbcedf2218d2f431cf3f092aa9745658545e64f19d6ac5c4e0365c8159641a07acec06011b9ab4d796a79d5fc49003be3fde107e5e36304c6e7b8d7e394f55058fd3fc470ce3dc0d98abd4a56ea6799e257411c14b1435c93586329343026559998a47bf5a0f3fcd22d3225211c4e1758acca7abcf28376da264559bcdca9f1616a027ee5416712681308e8e77d3ac6088ceed4aac7cc3f38dd34514bfb2ce29c22dbf589538993475559983485eb722fc1bb98fa91d53cee21b80fa9a199a738496f3e769dc692a14b8edd803a2e2e76f45f13c7f115b50762ff7a374bb64d650b111bdb4082afda30819c04e5407cbb66c0c34285bb383078d4f100efcb6fae91509a8aebff895deff90d4a1bcee147a403d49fec69ede9ed9479f337d4a19895bb19c63de50607d881c9ef18597ee6f129c47f12697077a6034c6159c895b2107bc598645ddeaf9d917859de06a630bae1147e85b5d0a02690b6f5e852de1818450901c4d44930b1cc970394a472f5fe7f7a99a5965b63ff6d1c75f3bbe9e1ac1f908fb9434f0485fb9e0b7a35cc8df5d8beb1f9fde223bfe52f74b170ddfefe4c2142fc6d22cece070655db99e6f620398b92ffc6ff5020fbdc3e0acc7484c0121fea2fe7e8e2666999db17bbea4aca7732ed3673b2842032a1d92d94850f25910094a7218f5424924290b0a9a807a83f97d10176e24411f751d51f44776d75ab5324b64275b4bc5a50c834d1ff0c9551a050a16fef79c97b045079efcc100e70c706b669c69f108cbe8511c0d5d14eab6b14e111ce905165d807f97fa5f929fb7bcb81928190fb341dbc6cc956f7785dd9faa60be06f3b5b8a97b71b7c46841aa19816caa4b20855e0e6bf1d114479732df3609a61d04b8c2c7d489bf6b0679c9fb6217c851f1cc0356e89a0c67382be7da51a0921815db15490f3516a86be3852941b1f7ea99f55c154d2773693810f8389d3197ec79d024ba72a33180285623915ce9ed1dd43ee6fc20feff2d821f748eeffb3e82685dc2f69403fae8ac09b6a15b77f5733627ee62e4edd240a0fea3bf4a3bf722552e25ecc9c4c3dc7203045afc96901e47c060edc2b150914229bdafb3f885d3fcf3b1d86114ab6690e8d407c071ca8c4af0ede71e7dd11fecfab101dc825fff56a3b25be5e467f99bd040e7327f3a7febb0e94f90b1c8233bf1595842b9dde0436d5e3f09b606de1428724acbefd0ba442c02f7392f92538f72e96fe62037764d732ceb6be00fbd99e6b15121d7c5098d6eb299e67e2b98398bf75a5cd0d286fea6b8f01cf9d3233125bd9b70b59f9e98ea86684ead5a78c88dc51109ed4f92b3402d7e1988622d3b7dda3072e3324764c9b1432dde0f4f4e123f4defbb2b10ef5c0a489bf5b599060bf375d4d4fa2993be171193643b7a847edc54d4c12af396de143b2622a6c35203106319cb4268410662abbc96a73b9255d6a28a93c7cf4344b02f192c45672d846c8bf39d1eb216c952baccf7ea4a09bdb050f6775cf79f60c2edb122498979c006e69ce575d4df990f43f35904456888034511b7642cf07538371f28b8707f0f548adcad3737e307310c86d0dbf8331d58662b0e3f7fd4e8b52e66fbd592ad52561d5f654ff52c9541f1aaa35e41e193e1a9d431c40a627fb3ef54459d8e31d9c49d4e9fd07895cf892af9b11b27a8070499cadd405cbb99a91f282aa0fbbc8de2855a66501399fe5b5e6248dcafc6e40330b399baef67e6737d71af1cb0e57f1098f053db9945bca422b89011fddddb25cf8b4c08e8f1a95c0901a3ece7136ee5e3b62488630b2b43866c921d890d8b58af0ac6868b1b06c8f5d2c3fd569962144520ba9c78a33dc0d654638c9e114c08c80496b96fb5c55551d2625afe58ac0d0ab83dff66c9073b02b5d218ef5e1328902371a5035b84680460f0a9fac21fd178f5ba2ca079b3d09746a7228daee5e2f86ea226b1800a1518a96d961107fd88c95f10d0e210adb9b540430df0bc599168542ea0863d5e05c4f5571cd22fcc7453885cdd03a222e305294cf22dd2749484a854e536949b2be5cd1432c2cd15990cb026294d42a33cd1c2ee136b5c00ec6f3ab0a281cc3e4a6cc05684e7c6a0ad0063edf8d1fc2a6987667299e5f663ca0d9dc17ebfdc9ab110852a98dfb5a3cd13c4f8b2f047ffa608f3ec572ad7c7f95522c28070e17328bec2374a26c2d8406ecf512a6917585a7de438f02a7797e91c53c11d87b2e7c4f9fed274de84be21c1b74e8ffb7d0438618e68c15dff87299b31cc6c4815ab12c8b7010e031f7a8e0a532a625314040505bfde6885f73b9c70c93fa7d2ab331e7e1953267f11f579ec2ffb1acc9e861315319e36e12bc785aecea904bb8f78ee23dbf9913761256889ebb3796492fee7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
