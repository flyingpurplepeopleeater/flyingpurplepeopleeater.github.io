<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a6854aeb7b6d24f7cb34a8165165d695d576a36c2d2df0d4e482d8311f2332fa19c88d4a10b4f34fb3a31d053b6674f2477b3d17c87de86ce090a9bd724774047719c95615a6c804fd03305cf3b4d3f630b2c0ee2e309665fc81f45ea6cbba7b18099f827a71ce324f308f3f44f273fdd06e090711fd8cb138c27373cd301c38c20d492928807cee5d5fec792f6653ead76c4ff8f04d7fb4fb22ea2b4814935f1d1f4f1d6bc7488f3b919e7a1d4a47ebaf8ad0863f13644d4c3d524ca6c4172d4c5c429784c5ff2c1b4bfa6ab253c620f19f27084c9f7dc301c9e29d40bdd8c241726cabf93530cf5d206f4387b6e0f0ceba264ae2f8fdf3f27ba02d845764575b9b4259bbbd1e2c7fd2014b26f343e7e78890159ef8b7c6f4c48d56e10bcc7302d58a2fe0d45d8cace363e7638921eff815312c582ff8917042552aa7767474c1581a826866fdc7fd061df0ead2bd957ec69d98597dbe1391b4d8aff7b829c85418f274fdf704038cf86ac0a42353c02097f602bc748f1bc6af6feea87b112f597643e64af87157726232c8fc1ed639fd9c363a4d16f9c839ff36f33ed33148ab52bc05c0fed1d652a7ac0a291a7dfa901adc1401f172d37b5a285364b3fae63901c9aa4d2319590f2156e0b7014cb4b0b8c2ddfa610079ccc4d4e4387f8dd56040ba560d2d2df0db3b2ce75ed0ab7ef9571aad50075bd9acf5c2dca32064e53fe7c8a384ae2e4441ad9a8e8fb0cefb3b11c324feb22d43c883a904a6aa62048ca50a2e7f09c94f88852414c86102c863ac3afe656e102d6a6cddc870ba6555a70936f9da84bbfcd8f4b34a422617a83875d41dece4baa4f653e10336be8c2869be9701c25edf79606cc61070c5184c9ff598389487abdd55cbb5c0b3c9f81aa337f4eabc3589ae42c3967c85dba020c14620bd3611ac13fa687faffc68349fd5c1f615910561ba6b84199a349000e9963c7d67265c6d350a1da6e7f60c4370446aaa56ac37435c72fd8b0276f31125f3edbf8ff51b07c4c319e48a391d539335321c845dfec661c9e757179b02dafe4882c2749c27aaab1be4c177ac1c270d77b4ea5f1a7324ea21a47b82687d0ddfab5e39ab097e950266ab5bb27159acc3d1f0c6f129ebd6641c6958ba97ebc42f79768e6968495ac2552e4c6fb1ea5fe7590a489b5de80328ef8bd6c22d78653d74cac0954dd18c51c5f510a400364d93807443b0055f7e0b98c0e5d30dbf2436b84f142cec7d3fbdefea58c45bbf790c4a3d802e038a73962b148ecc560cd2fa6ea7f2862435a9847d1c83f6f7aaae5bdf65793efa47239daa338116e58c5c52ca4659687b7b0b42c02e3bb99c5db7a3493884ae759b5e1fda01e4a06ea48e0f9440d76668b0b818038b3eca9eac091777a6d9e994effccec6921d61fd6bb794def8766a707fa5f8bb43897f85f8ce20253f2263a57f1f4b369f6e3bda39be59d74af9c84746f920d9b6e006d52aa1ce778de4a176a6ac0c91bf67dd4042e902f0958dc51ab216c6c50a4659256eaa5bd79e9bb241730aa0e3488211f0f94a61ea76819201d35acffcf3f64348cd157bd7e6e0bfda0c61b5a77b12f5440b584bd7183ed5f16727ffc1374789c347b8c2a4ec5d40bc3f95dbe912b9ae2fbdddf0120f67678cac83286ed5c75ec46f6acd28f354d12e71da0d7670cea900e47d646611481a4cfc521b3a8ee62314dc7adc20ff60c1832b16498f6fccfbdcdf90d4a7f2238dfb519e3044c6ae45e3e9bc1353ed961bbe1b4eed04e6d357f1cab36737a2314cd1d6c189da1bdf0cd79160e1f5de28ba58972859c03bda9ab2e9400439e16b6523cb28f9a1105030ade25ffa28c0fdc0db9fb258a45f5147c53d99aa85d020a8128f9ef0a46a295fcd48691dcc737e8f328b73ce5f53ebfc18b792e085b61e65d1a5daa4fd8bd3daee7b3e482505d167532fce3bf4c44153e0b61928ac74c48510c8b91de0d2232cd5fb372cc9b832f4876e3a0bb62061e73987a23c658bf6f76810485ded5766ca3aa78125016a459df6c301e6e06ddfc89afcda65793d8e3e648c736b33d8843cd18f01332acf1ecb3dd13836136a641f67344b8c0f4f018540054fd005768d125e3a0ff381576df7b410568f71d6e44754ca965f06453698863f5fe9b4e52721c0df1ed820b2c89d649bde452c9e0c030a481cfd7a1fbde499fbdb955484dc7410c299ead6600e73f57f7e752ae83e9c1af34483dbff967952610655f53737acb5b93cc1ebf3ee8f8355e6e7c70fdcfc374b432f4f9cdef94e009b40ed9aec26cef208cb2891d6d690e5f05b4033e745008ddd74a800f4711ebdc8de3d00a3936e95d1ee449e51199d22429a42b940d795e1912aafadc55207cb8410785a1451baee4b02bdfe6770a2fd8e7c84c8e07d497391eed5663e0f9fda84e2093ae2caa218bcdcc7b08eaf37da9b0711004197a4b821c803d73a1b72cb7ded62d5982fd1ba0bd7452e6d1ae1410afa1f19af229a7c8bf6381689b9faeed1dd469d76958b3e31f8b65bc876c44d51a8b0a478d55a20cc272942eec4a8b00318da1119a9ba02a988047090e8e15e8a0a88c70828e984b90fbb746d98bdc41b616a8a88536022a58593dfdf4ce2a459391b716868a6279430a82f202dc83c7b823d59e6f195c7ac9d03f07238c63c29843e8a022f2fea46add35e62eb081bfcc32ac5ba873c1f0031ca51b845b00cd8f1fb0538746d45fe64124526c2a1d808e1ec7c2fe17ae86222fc70dd1571c8799419230d6af52658052684138b7848d74ac1d51675981e8c182c1f2e199c99e54c646a2a1cbb38e1718104683530613e2980dc93443cdd0f3626d2cb30559b71cec945694b8d5e18ae6d5b255d3e5a490c85f7a32e1e0d3e8771a032b49456d9a62acbb7f9c19ca5213da053cd211f790bde72bda14756727662bd497df1212391cc6f22285e92ed120d72150216bc50809804db48133fd3471aac4b404f85a5ab978de443cf9ec215a90094daa984bb4c89c6a3aa8475a0c6bd44ce27e7d755c1c5c846aab97dce0f358a4c9d53ef70dd16eb3f2924b77e4dc030d922915fcbd5672db4eb82696e8099a5bc799c642416a16ad01a8f2132796641cc3dbdd770415b5880f7b4fc4e9fe1f48d1f8584976fcdee25a6a5fe326a7ae2f58dea98a14e75b22f0fd4eb25e9ae22da2746ff6f48e9893dddccb3a1501464697ad63f5d5cb8dc7ea085a1cb875c6512347c3acbbd29d00f62d30b364eab1ec2a6348eeabf75b5075fec2f45cf966e0cc61d7ca1acffb23c558b889d3a8c71d76b0c7898b9d9a4fed5207d6c832e896aaef236b4246577eda3c9256da6c3b16d24e602aca122bfda56e04242418609c5c24b53bcfadcbbe2e8872b77324ad0fee4b484f9baf57f563d1542370a72bcb25600c9fdd570762da117f09b3989615be76a5356bec52ba97125f659b5568c1d3c0665d049275199262b21f21fd040b1febf4ce35fb3d814425870885aaf45b8230d4ca8744092248897bead976bd458a6786f8662e5399fae074a9fe2382b04c358ba65c3970e600501a9232a58a44d1fb506e31f8e1130f5a00078d1c6bd308928b555fc5105b5fd91cfa1dfbe7028e2caca60faf1ba2ec38349a40e57c0195bc40e4c520cbebaa59d12611951946952fd2b1bc992a1bfeb20c33ddb03b97fd5abcffab6fed3a07f95938ce87e5e161d91c9a2d3eb5992e8e5837076c67c8b52347eda2df0b2833aef5fe8b4cbe70292db576b8fe0e81a89f5e36d1b328cd3d00caacfb7a3f37d65895bebde89332ca1c3515b49c8ce3993dc3750cf5c7d1a6eae6cfdfd766b06b4ab777dc20fe7cfd21f614cf6ad5046822afb5b52dc457d7d37255e3aefbb33459bc7a6981ad331d664cfe4d3055fa0bb674d84d62ec1b257c447a6a714b4adc9d2298e2ded3f64b70e0adb3765622a9c7cc8a5fb6452ad447b725cb130b7c2c353c19aa2919214ebfb026267e32a717457dd814d07f778c0f07beeb1fddbf3c01d9da7caa42bdb8d341861bddcc61408674e13292d4f37fc781eda30d329bd0ab006e69117a0abf474afc36448a54168db8c532016264d11126fff18d88bacc0c089997b6553d0bf65846fcffce6c6304e4bb29682b8ad5e20c45a0b35659fce83f7848bbec2d615c9971b09552080e6059c9ce9f0a5faa45051e68b47e433262855bbec3ab4506b696fd8c0dad2ebc84f4fd7383965104b56ecad0518118fb146c2a00bf5f3ba457a6898708728e06bd169b0a089399051497a0233eff46c26b9b9b9adb4a09925bfc8cf77f10b5c4c403e25b9213fee102f3716a304931932f410c2936a8359c34f760c0cfa12cb2fc3b167ab9d3c3c837fa87a0d9b3b09117f2e5b5f2d8f4578726a90d63285d21ab5f6b3312834fcf28f1a58d1097cbe47a7a1da318dfd10b6c2bbe47c271db12f0c80365d74a91363ab39f4a2b0fc5f42a234a2212d0177629b4cb64db48481e7db78b87c2b9930bc7462db4db3addc0d2ace9064b30b01d905aaaccfa3045326e3bfc1d4d2d882b867a4da50493558771ab09b5cd6a7542da8ddbf990d6b84df0ca8df0c5f1d2f2647ed5c2ff490b75b583f7d896525dc48bc5314dd52be10a41cad6cbf0727c784a2ea87dcb52feb70eacf96a3f0eb3a374e86a46f2e676bff64a9ea67fac86da6a9f516a107960d5b818bdc7a880ebe88201db6ced646b8d3ad9c10bf7081bbd48202d0f0a5e6e34c7d89037ae3a8cb2c3cb5b7b3f48311c0a76b55b54380df3ea8743a8ef74a9c4653d461e583e39eef0a8e8defd94d4b26d3eb04fe8138b3ba823fb2806b86afa98c12adc75d59a3cdee3f3f1be94e62244dca636504a7dfed5dbd21a44cf17b5d0bf58cbbcce302a40cb983e682b70d5ea324e3cee7fc6a2343ac0339efdf5b6fab6de6304ffb51357cc96f9470bfade848f747b8a004bced5c906cc037090a41bf8d0841ea2f2fec19f70b492d86618a5e09edccc0ba784ff9a066d70944c205a1d11775c203503a0f32b35ce36294e16e97818b04c8a023b9260a7dccbdec7d81ab789bd0d58e3b1dcf1b44e692b27f3ad36bc9795ce45cbe12980449481de1194b4d19995476a50ddf587216d33673b39bca37d24ddd0dcc395df8db753cdb34bcc00edf028366cee05f5995f16829106ac6063d9a5a4f9cd1bd95a7799b328703cc706862320e891f3d3a9807d82ec40b560ea9604bc0e437717a6e2b45481f75fc87e5b83ff9974e9962858baeb33c200cd83e17240282d45da5c0e7b8817e6ce7099613d0a3ae77b07f329f71e30947d7bfd33667f23ff2b052f77419ecb811a6e3ae29bf3aa399688ef6e4d01e1a92be81d8bf49303f0920ff205b29c5c1e8cd342668762c1d0f234f1c2f447318dba83429255fe8a758da57c8cc357424b9401acb770464e20762eead8ffa6a26748ccfce25880f849d11c87adbb3d682847af756e7b91d1007b2578f6afe741b650c37823521a30671de263286c89f96f773c802e615ea28549ec6b0796a8221530b56fc74cbbf57b06d95706a2951006f51b924587befb213cec64aacafa005fb7c15eb66b51002b9b379d1c302eb17fa24aaefa34828fc1a03ddff3f724c143dea2c38f0975bb2169881984bd865ce9d9f3c2c517032ed54cf2ec4ae5ffd0cbf1748f88e3e1a5ecf34cb5d6fb58778e059571b7ace6432d91bc89a2ad151014a34b3b32c753699a29d0a6cda9c1bc689dfef6ea85189c27b38b6df3538a14de2f06940fd417c88f987aadd3708f7231e90577f1bd6ad16d7bddceec4e31591a5c6b621315f52ea70665d47d810b99c29d81ccc7ee05614ffe728d8ca2009ee99a4687306e73c7e0e0d7e62517477064f4df90fb189b34f28d7ead94de101e531140ce58e12134c0ed75dff546667668b75b7aaf750cd20b903e341b5e04c3a13d7672d3075c409354a125aa7f04e0fb0d89cd284ba8605e7006f02a63489d8283484df0511e3d4c1b557932e61bb491e473d25980156f012984df33cbdb7e282101248704f59077a5aa42c4285c8cf0f270a617fd8c49f68f801f617f916e6d5b2be4b14a9610ec88c9f21f4fbd91c351d7506582eb278595eb797fa89db7c06064a2de13203650a6c40737cfc5888ec646297ce991a5860c0f7a22742c7ba835c8a46d6a38b62e43982a97ea0f2741c4d294f2c522940d6d6bc74651d61926008ec78a77cb9303ebf7bec81a9bc33f692bcecd05c8ea1cc54125497998119e675bf349d1ac62145a7db46ac6baa0ad51f55cbe2375aee47ee4841a2239065764c715010407fb208bcbc61e0a59fb08125f1b31febcf0e241751cb245731946e6b0f255c773ccddb751a39cd784ac141d0a3fd876459eb297704dfa424e9622dc6aa1465491de8af8424fafb1f638cdd1defae0166a9faef5b5e809981b4aa6184dafba1dcc101effd6aa7a3ca82378f5a0395f81fda3e8ccc68e9ea0310dd5779f8e3306ba7d90e586ca97769f12c4a035e7265ff960f0f6d5029e8f70a6a1ee1203fc971e1322421173738dfa368f50b2002588e1ac1dc1e0c37450f49b713824e6fcd093fa1e08397f060667995a28c721d5b32ccfd0f06409b0ed30cccdef3e5fa962869d1415ceee1b17972666d1415b1de2481900cd9702874146fb314feea101861253c4aff9a817e5d53214255a56afe712d64a8fe2edc15cdead97ee39594a5b2cf110aabcaf721d73eb0e12639b5732cc53c5aa38986b47ee89712a26765e3ab5773e2329db6bdd6581aefa111cd51e488909718b77d6d4c9385378ecfbd735fa7983053c6810d9d4f1b2e59c57c4c61c14697a6d81fb7ca8650a3f6b0938381b4cc3743b7756ac1cbdec3f8612bbc86f94c29fc853993235463d389838d837497d7d8e2aa6df9d2b31d5783c00d904e82b4ffc8233ae91bd054fd910954b5aa62e3aed87e2f62a5e5f8c90caa8b7d689c478273cf67f9d0c3bd9a71a310cfa41400e583c691a44c7cc19732e4d34fd5549eb359ad2cfb186ce60da37ab0d657f5fa51a873c6733c3dc6b2112869f94bcdd3a963b5ad924657dcb80f83a768b160205308d24c164e152c3d29d97bacf22deb9507319c76a39982f10b0b601449e09654fb25a881351773b05e85629de76164bcd16ff488d3f731edf61efdd6835fc8f84f2c97e63c4b5e738a39b62f5478bf793158176c3394a28a8ba16dd26bcccab971da86bfca8170aed624968913f3a4aeba4f84ca7e70b21c3ec1c2e43e2e5e2c6a4235e2f67558b7107d2e0f2e1935522ef8f379b529eeb03bd0de1eac9fbe8d61efea3a569aab63531632c6c8d6c667ef33f1f1c9e545f7cceed8dd14a592f21e84a3fbfba965e9790a6ae8d8b591d363c937781d4a07a753cbfda9822ac63b16325f6b843029a219514ea1ca204285532a5988c68442849cc237dc0723b444e4f6365c44575c8e103b7adf9ce4dcd055198cf745032dfedac24298ae0c9b64e1730f07b597bcce737ffc5cd7a2ba3a4e4b290b56a9531fa48c66af153befcb337c24d8a211f2569d636106b4363ece6038b86d01a39366ad0cf66992ea8cce78bfc3cea1e6cff29ab391cfec59f6ef63a72ae62ad9032d9a38eef0438e21db13802ae83107cb211ffab9c114df50539e0c4612597b1974fdfc533cda51cf239c86ad2dc15c7924547de16552d28f63aca58242988e6dfb53a6cdf12c8f5437f867c893ebaeee26a75094ae645914f1797718125e8d47e7b11a83237ae0eee082b9c0556f78d452ed49f73870dcf155273d7f275e366c7e440e6a8d0ce897076fd173fef3bb44249259e31069b83e88714f0dba72dd7bd102c9eff86a191fc444d62ea48ab744eb46596f3db37764e35179b75bd35ae24844e802a842747144f60859f80119f4c63fccd05283f2e1f4bfa9615df10a33fc78700cc4eb7beb41b197854a8e4cb9c602cd77904d27b703db07a79c6a8021f9231f06f4f15b0c98282d48bf951e250753aeb9b5dd4a1b629f6db58bdfa5f23e110c58f85fac210c5ca5ca0b6d21165ccbcc518c8e198770fc28be876efeb473b8b02f3b119f06bc7123bf4d448c711d7431e6aef1763d0f50b71b4d7655dde4ed5b94e2b25fda5a3c3eb74c213ce916f76c932eee16c6fe83e98a8e18653ec8a9495a7694dacd871ac38a6d305a0efbc1fb014220a02b0cb19432c924c2efb90d3207ea8b43772ddcef441ffe1ed6f4b975215c27eebc192ab28cc40dd7b9aabaae456b39c871aaba4e8c965de47b9ce43aece32318d3769418767700d2a4a45a39c8d78be93944d4db94be0826d089e5acfbd1b09853608c27a93aa13117106ff0c2456a10871b5d026fe7e134a8d35f7627bdfefec048327189ed9ce5e6cfcc2525d780f2279b15b5d1f70700c7443cfbaa98b5bad313360dc032231f5da912a920681a124a02a74e01b01320d96b3e6892aa4d4244a35d29cf745040e14e735c07c06d7a62c1a547ee49c63a3470a5eef334890f5d001e32e0e833423391c5561600be83c607fa4551db0b1734ac9cfa7de28d08604ffaa40269b9b9a046438dcd2eb37696f08a1ab7e9f33249216be4691e6b9d295bba8c1a26a84b5c4fc4e45422c22f3f78a13147452762436421c8b385c6a1e99871610b6c8155e1af35d0724906f9e6328d6c7dffefc7d27569b632c3b7ee08e8899d1fd0b9e46b9665890649314b0caf6f09b2ef8df9050c6d102f3d6cc3837970d421524e65c812519046a5f8a069e94bb853fd1500bbd8a7cbed635e9c2064ab3fbbd70c24f50898a1307f07e817cf430fb13cbb00ee6b96287f556f208b596a15a2188956799dc9c535981a83249605122731ab286a1d72551c82a88cd8db547b7bec600e09112267f788ba9529f7b26b5ab4eefaf87d00febdf8ba4bba5074ebedf2e5749920e0518611699b842784d560898a026d6c0a237d4786405c6651e2a0d72345c127dd790de5d89ffa059d8a2ae94b4432a975c424b1f0d98de0ab324efcf388d7dee0ef919c7a145d23a083abf42a6501a7294d279db08c4853a848e1a187f0e080ef55cbdd53327e21d768b0e0784b117287977cd77960c9bd9a85da0ee78ed396250953173d59b377ddb845326809887e11dfe314e72bad0084790e59b8f7beed86c76a882cf27332ce4ee3b8d07ddc8b91f2747c94b74570340004214e5661590e275e1d4e4e1b0ee71c312347e002ec3232673c637c41cdf0497e34e22da53da18a6c3e97ae2a50132e6e650e03ca0d531182540f935ff3cf7e13347f3ef8b035ed3e3da8e5a26a0418fe443750f9aaf81d995101b5d558c1a948b754fbfb6d67f9139f63ad2df1e22d049a99a0147fb5a699e692dd8946f9f537988b6bac6688641c330c1e197efa47fa6b1bcb73fc3942e7b405a49ce6a62df0400a76a2c8342a26bac880d0876e7bc910e4bdab0abeee0aa5ecf2db3a7ecdf1ee2e0fa9d39002e2c4b372e6dcfb012cf08ce559032ddd4500aa1abcdf173faf9d48b0bf8ab7c74e43cdbc241e6840d3737fe07fa379f5848b654f3f99798f77a47a318fb0e07e3a7bf782152f0c451d6984a749c73018a2705f54223e5f1ed98024fd31a8f41d657366252d193813ea08983dd1286223b437b6422655c63405aa95ba7bf18ecef9975c05352d1f09c75d016c637a4192f4da8a0de77f29a24426a3faba41ab30116e18a1874e715196169923fe6c7a30845cd20923c8370242b3cfc629aaffb1e0aad7d294c74452713424584291cd775a21ce91dff78776eda77757612a888d3ad70c9df82aafe1c2866d1a7c0cdfb8dd6e33cfed9476d049081ec7124c9a40f9d138083c593141780645bed7176e4928c2313ac32bdf74ad20fbb5aa0a95a1c49d093d039437c1b451fcfddcea482b635af5b6381b59256b7d185646a79d3f2bec31efe3655057d45a23a7b450e5c52a9eb9ae1d258f663a9a253f8c7ed661adf2b9ec0d70a7c2ffaacad0bf649b5bdfd74dbee689449b73f9925582f3ff2a934af483413c39c354d4914a858f6a7c57cf2ac6dc0e94c894f318dcec38ad90a201891fdda58b52ad312338fca6d062366814c01d31221c56f40bf532c7a0112d2acc800d40b31c6f5013b8ad7520a1a48c15d86dae8dc0a26dcc3d9c2c9bc502ee71782dc27aa4a8dd38198d80e954d60798a07658aaa95f4606ed7320a1110c53d3477171d81fcae9d7a2c7ab8b914790f252718eb76deb6e3ab7bc6eb197fea8345e147550f14102de21f0f8126858634e7c4a4195121b414dfeb5fe5fb8cf99a1fd489d0371684d84b2ebb30ef0057b91dd5702060c7777bf6ed6a0256a6fa8dc3aa442f106dce571611b2f9bf6ca9563c9bfbe2ff1f219790f2e567c9b52876ff5cdd4d0402676a967bbacf2b83585debcf765a390f4ddf8f446d05950181e5fd338d90dc50feb337d3f001db1ed33dc9535eb13201143738d0117ac289581f3ef456d0f2c1c805c09df6c34c09beac18f44c2f7be7b9fb1bb367add217668370247d9037684ab49b01e982b4e5ff8b068315acea36df1fe51fe773a9c5cf21946e9e177f257b788565ec84b2d3e064f3ac39fcaa319c0a5e0d9361edea7be41bf6e7e2c64ffe1e2d313feb327294e5775e93b2ace96e7086583ea2fc36e50f09cbc9106f43cfa7371078d8c245bab7c6240c1cba70e64f3c7f7654faca374cfe3d80f4b213f61635fb6602be770776b41e31c2ad49d64e3912ae118a7e105caa96076ab4d9a37c42137d427c8d685eae290a82ac3925520814e864ca3b39338fd3e9c64035b9931e349291cc597772547154a60462bf5e23b3e079fe28eaa2747cd63d614eaeb75dd21484dfce4f36ee36d87d384f408840dc2349a8f12244726f621bf317c63c59833c02fae7229c290365207b7b179c27bd97d67deb2fece6c8615ab5b5ac23382c0d1bb17407d7af40ab5b52b3c5c6b3883cadd6e5cc542d9e2fb2f80cbdabadc13c8705c11d1fd9436ed165905c70366c06c6b5855a8171690352389af07ae5ef8db58c0acca0c256f6f256db5db3a7fa2b771da26db3ea88af728e42e796c88981746089a671269d9fd7bfefec3a23b86849ff58fb70abd7e7b589d5d676d5141f4856ddc7bbeff3b3df5bc9895d08346f017774d8dadd6cb552f3950756fc9c625e0dbab9853d3ee73bc062d50dfaef925e98b9eb4b4727e2ba372b3f2c77777029c405900c9305605c13a3d3a2758edb2fecdbae7ff980087c085beab649d444ca562d5774ef9cd62fdffd58382cbf01c79b4b1eef4f4aed04dbf8099d209e96b9392a0a2f897cdfb423067f1db70bf84db924478db74ed48459fe894cd1af48942a5f9c66d605a5d00a966cadf82a4e4dee90a94c735c6f1be6ece605cef384f3e680042911830492139791b6393bb7bcbd76295b50d4fb4a5be00c4ba48267beabe100f4e7f636d2b67267bfcf0cb67468fe2658c3076f8b28d51b66578e41445e0550552d429df1c572de71c97db4856d34c03b722487e0cced9fa728e81a84a3181f06b05d50b3864135cc190fe7661d7fb8ad55554fae143fbd6aae6c91a4bd1db130db2384b39f74cd099a728c9e9efdbda2350affc025002c039b5c6b6b4f2c211edae20702b962285cfcc2674187dc4963977d56eb0d6c3f78fdb7c46a2b9dbce782cdd08d017c1ad766f3b697d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5912d27d0ce6da9ad99507d8e3eb665a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
